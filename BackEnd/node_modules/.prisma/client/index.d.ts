
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Cargo
 * 
 */
export type Cargo = $Result.DefaultSelection<Prisma.$CargoPayload>
/**
 * Model Carrera
 * 
 */
export type Carrera = $Result.DefaultSelection<Prisma.$CarreraPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model PlanEstudios
 * 
 */
export type PlanEstudios = $Result.DefaultSelection<Prisma.$PlanEstudiosPayload>
/**
 * Model Cuatrimestre
 * 
 */
export type Cuatrimestre = $Result.DefaultSelection<Prisma.$CuatrimestrePayload>
/**
 * Model Materia
 * 
 */
export type Materia = $Result.DefaultSelection<Prisma.$MateriaPayload>
/**
 * Model Curso
 * 
 */
export type Curso = $Result.DefaultSelection<Prisma.$CursoPayload>
/**
 * Model Matricula
 * 
 */
export type Matricula = $Result.DefaultSelection<Prisma.$MatriculaPayload>
/**
 * Model OfertaAcademica
 * 
 */
export type OfertaAcademica = $Result.DefaultSelection<Prisma.$OfertaAcademicaPayload>
/**
 * Model HistoricoAcademico
 * 
 */
export type HistoricoAcademico = $Result.DefaultSelection<Prisma.$HistoricoAcademicoPayload>
/**
 * Model Auditoria
 * 
 */
export type Auditoria = $Result.DefaultSelection<Prisma.$AuditoriaPayload>
/**
 * Model EncabezadoFactura
 * 
 */
export type EncabezadoFactura = $Result.DefaultSelection<Prisma.$EncabezadoFacturaPayload>
/**
 * Model DetalleFactura
 * 
 */
export type DetalleFactura = $Result.DefaultSelection<Prisma.$DetalleFacturaPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Cargos
 * const cargos = await prisma.cargo.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Cargos
   * const cargos = await prisma.cargo.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.cargo`: Exposes CRUD operations for the **Cargo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cargos
    * const cargos = await prisma.cargo.findMany()
    * ```
    */
  get cargo(): Prisma.CargoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carrera`: Exposes CRUD operations for the **Carrera** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carreras
    * const carreras = await prisma.carrera.findMany()
    * ```
    */
  get carrera(): Prisma.CarreraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planEstudios`: Exposes CRUD operations for the **PlanEstudios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanEstudios
    * const planEstudios = await prisma.planEstudios.findMany()
    * ```
    */
  get planEstudios(): Prisma.PlanEstudiosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cuatrimestre`: Exposes CRUD operations for the **Cuatrimestre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cuatrimestres
    * const cuatrimestres = await prisma.cuatrimestre.findMany()
    * ```
    */
  get cuatrimestre(): Prisma.CuatrimestreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materia`: Exposes CRUD operations for the **Materia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materias
    * const materias = await prisma.materia.findMany()
    * ```
    */
  get materia(): Prisma.MateriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.curso`: Exposes CRUD operations for the **Curso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cursos
    * const cursos = await prisma.curso.findMany()
    * ```
    */
  get curso(): Prisma.CursoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matricula`: Exposes CRUD operations for the **Matricula** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matriculas
    * const matriculas = await prisma.matricula.findMany()
    * ```
    */
  get matricula(): Prisma.MatriculaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ofertaAcademica`: Exposes CRUD operations for the **OfertaAcademica** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfertaAcademicas
    * const ofertaAcademicas = await prisma.ofertaAcademica.findMany()
    * ```
    */
  get ofertaAcademica(): Prisma.OfertaAcademicaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.historicoAcademico`: Exposes CRUD operations for the **HistoricoAcademico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistoricoAcademicos
    * const historicoAcademicos = await prisma.historicoAcademico.findMany()
    * ```
    */
  get historicoAcademico(): Prisma.HistoricoAcademicoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditoria`: Exposes CRUD operations for the **Auditoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditorias
    * const auditorias = await prisma.auditoria.findMany()
    * ```
    */
  get auditoria(): Prisma.AuditoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encabezadoFactura`: Exposes CRUD operations for the **EncabezadoFactura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncabezadoFacturas
    * const encabezadoFacturas = await prisma.encabezadoFactura.findMany()
    * ```
    */
  get encabezadoFactura(): Prisma.EncabezadoFacturaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.detalleFactura`: Exposes CRUD operations for the **DetalleFactura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetalleFacturas
    * const detalleFacturas = await prisma.detalleFactura.findMany()
    * ```
    */
  get detalleFactura(): Prisma.DetalleFacturaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.0
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Cargo: 'Cargo',
    Carrera: 'Carrera',
    Usuario: 'Usuario',
    PlanEstudios: 'PlanEstudios',
    Cuatrimestre: 'Cuatrimestre',
    Materia: 'Materia',
    Curso: 'Curso',
    Matricula: 'Matricula',
    OfertaAcademica: 'OfertaAcademica',
    HistoricoAcademico: 'HistoricoAcademico',
    Auditoria: 'Auditoria',
    EncabezadoFactura: 'EncabezadoFactura',
    DetalleFactura: 'DetalleFactura'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "cargo" | "carrera" | "usuario" | "planEstudios" | "cuatrimestre" | "materia" | "curso" | "matricula" | "ofertaAcademica" | "historicoAcademico" | "auditoria" | "encabezadoFactura" | "detalleFactura"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Cargo: {
        payload: Prisma.$CargoPayload<ExtArgs>
        fields: Prisma.CargoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CargoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CargoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>
          }
          findFirst: {
            args: Prisma.CargoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CargoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>
          }
          findMany: {
            args: Prisma.CargoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>[]
          }
          create: {
            args: Prisma.CargoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>
          }
          createMany: {
            args: Prisma.CargoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CargoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>
          }
          update: {
            args: Prisma.CargoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>
          }
          deleteMany: {
            args: Prisma.CargoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CargoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CargoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>
          }
          aggregate: {
            args: Prisma.CargoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCargo>
          }
          groupBy: {
            args: Prisma.CargoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CargoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CargoCountArgs<ExtArgs>
            result: $Utils.Optional<CargoCountAggregateOutputType> | number
          }
        }
      }
      Carrera: {
        payload: Prisma.$CarreraPayload<ExtArgs>
        fields: Prisma.CarreraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarreraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarreraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>
          }
          findFirst: {
            args: Prisma.CarreraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarreraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>
          }
          findMany: {
            args: Prisma.CarreraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>[]
          }
          create: {
            args: Prisma.CarreraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>
          }
          createMany: {
            args: Prisma.CarreraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CarreraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>
          }
          update: {
            args: Prisma.CarreraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>
          }
          deleteMany: {
            args: Prisma.CarreraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarreraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CarreraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarreraPayload>
          }
          aggregate: {
            args: Prisma.CarreraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarrera>
          }
          groupBy: {
            args: Prisma.CarreraGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarreraGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarreraCountArgs<ExtArgs>
            result: $Utils.Optional<CarreraCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      PlanEstudios: {
        payload: Prisma.$PlanEstudiosPayload<ExtArgs>
        fields: Prisma.PlanEstudiosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanEstudiosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEstudiosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanEstudiosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEstudiosPayload>
          }
          findFirst: {
            args: Prisma.PlanEstudiosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEstudiosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanEstudiosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEstudiosPayload>
          }
          findMany: {
            args: Prisma.PlanEstudiosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEstudiosPayload>[]
          }
          create: {
            args: Prisma.PlanEstudiosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEstudiosPayload>
          }
          createMany: {
            args: Prisma.PlanEstudiosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlanEstudiosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEstudiosPayload>
          }
          update: {
            args: Prisma.PlanEstudiosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEstudiosPayload>
          }
          deleteMany: {
            args: Prisma.PlanEstudiosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanEstudiosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanEstudiosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanEstudiosPayload>
          }
          aggregate: {
            args: Prisma.PlanEstudiosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanEstudios>
          }
          groupBy: {
            args: Prisma.PlanEstudiosGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanEstudiosGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanEstudiosCountArgs<ExtArgs>
            result: $Utils.Optional<PlanEstudiosCountAggregateOutputType> | number
          }
        }
      }
      Cuatrimestre: {
        payload: Prisma.$CuatrimestrePayload<ExtArgs>
        fields: Prisma.CuatrimestreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CuatrimestreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuatrimestrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CuatrimestreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuatrimestrePayload>
          }
          findFirst: {
            args: Prisma.CuatrimestreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuatrimestrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CuatrimestreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuatrimestrePayload>
          }
          findMany: {
            args: Prisma.CuatrimestreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuatrimestrePayload>[]
          }
          create: {
            args: Prisma.CuatrimestreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuatrimestrePayload>
          }
          createMany: {
            args: Prisma.CuatrimestreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CuatrimestreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuatrimestrePayload>
          }
          update: {
            args: Prisma.CuatrimestreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuatrimestrePayload>
          }
          deleteMany: {
            args: Prisma.CuatrimestreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CuatrimestreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CuatrimestreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CuatrimestrePayload>
          }
          aggregate: {
            args: Prisma.CuatrimestreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCuatrimestre>
          }
          groupBy: {
            args: Prisma.CuatrimestreGroupByArgs<ExtArgs>
            result: $Utils.Optional<CuatrimestreGroupByOutputType>[]
          }
          count: {
            args: Prisma.CuatrimestreCountArgs<ExtArgs>
            result: $Utils.Optional<CuatrimestreCountAggregateOutputType> | number
          }
        }
      }
      Materia: {
        payload: Prisma.$MateriaPayload<ExtArgs>
        fields: Prisma.MateriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MateriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MateriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          findFirst: {
            args: Prisma.MateriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MateriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          findMany: {
            args: Prisma.MateriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>[]
          }
          create: {
            args: Prisma.MateriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          createMany: {
            args: Prisma.MateriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MateriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          update: {
            args: Prisma.MateriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          deleteMany: {
            args: Prisma.MateriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MateriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MateriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MateriaPayload>
          }
          aggregate: {
            args: Prisma.MateriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMateria>
          }
          groupBy: {
            args: Prisma.MateriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MateriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MateriaCountArgs<ExtArgs>
            result: $Utils.Optional<MateriaCountAggregateOutputType> | number
          }
        }
      }
      Curso: {
        payload: Prisma.$CursoPayload<ExtArgs>
        fields: Prisma.CursoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CursoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CursoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          findFirst: {
            args: Prisma.CursoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CursoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          findMany: {
            args: Prisma.CursoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>[]
          }
          create: {
            args: Prisma.CursoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          createMany: {
            args: Prisma.CursoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CursoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          update: {
            args: Prisma.CursoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          deleteMany: {
            args: Prisma.CursoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CursoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CursoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          aggregate: {
            args: Prisma.CursoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurso>
          }
          groupBy: {
            args: Prisma.CursoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CursoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CursoCountArgs<ExtArgs>
            result: $Utils.Optional<CursoCountAggregateOutputType> | number
          }
        }
      }
      Matricula: {
        payload: Prisma.$MatriculaPayload<ExtArgs>
        fields: Prisma.MatriculaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatriculaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatriculaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>
          }
          findFirst: {
            args: Prisma.MatriculaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatriculaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>
          }
          findMany: {
            args: Prisma.MatriculaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>[]
          }
          create: {
            args: Prisma.MatriculaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>
          }
          createMany: {
            args: Prisma.MatriculaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MatriculaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>
          }
          update: {
            args: Prisma.MatriculaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>
          }
          deleteMany: {
            args: Prisma.MatriculaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatriculaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatriculaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>
          }
          aggregate: {
            args: Prisma.MatriculaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatricula>
          }
          groupBy: {
            args: Prisma.MatriculaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatriculaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatriculaCountArgs<ExtArgs>
            result: $Utils.Optional<MatriculaCountAggregateOutputType> | number
          }
        }
      }
      OfertaAcademica: {
        payload: Prisma.$OfertaAcademicaPayload<ExtArgs>
        fields: Prisma.OfertaAcademicaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfertaAcademicaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfertaAcademicaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfertaAcademicaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfertaAcademicaPayload>
          }
          findFirst: {
            args: Prisma.OfertaAcademicaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfertaAcademicaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfertaAcademicaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfertaAcademicaPayload>
          }
          findMany: {
            args: Prisma.OfertaAcademicaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfertaAcademicaPayload>[]
          }
          create: {
            args: Prisma.OfertaAcademicaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfertaAcademicaPayload>
          }
          createMany: {
            args: Prisma.OfertaAcademicaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OfertaAcademicaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfertaAcademicaPayload>
          }
          update: {
            args: Prisma.OfertaAcademicaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfertaAcademicaPayload>
          }
          deleteMany: {
            args: Prisma.OfertaAcademicaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfertaAcademicaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfertaAcademicaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfertaAcademicaPayload>
          }
          aggregate: {
            args: Prisma.OfertaAcademicaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOfertaAcademica>
          }
          groupBy: {
            args: Prisma.OfertaAcademicaGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfertaAcademicaGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfertaAcademicaCountArgs<ExtArgs>
            result: $Utils.Optional<OfertaAcademicaCountAggregateOutputType> | number
          }
        }
      }
      HistoricoAcademico: {
        payload: Prisma.$HistoricoAcademicoPayload<ExtArgs>
        fields: Prisma.HistoricoAcademicoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistoricoAcademicoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoAcademicoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistoricoAcademicoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoAcademicoPayload>
          }
          findFirst: {
            args: Prisma.HistoricoAcademicoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoAcademicoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistoricoAcademicoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoAcademicoPayload>
          }
          findMany: {
            args: Prisma.HistoricoAcademicoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoAcademicoPayload>[]
          }
          create: {
            args: Prisma.HistoricoAcademicoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoAcademicoPayload>
          }
          createMany: {
            args: Prisma.HistoricoAcademicoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HistoricoAcademicoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoAcademicoPayload>
          }
          update: {
            args: Prisma.HistoricoAcademicoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoAcademicoPayload>
          }
          deleteMany: {
            args: Prisma.HistoricoAcademicoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HistoricoAcademicoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HistoricoAcademicoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoricoAcademicoPayload>
          }
          aggregate: {
            args: Prisma.HistoricoAcademicoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistoricoAcademico>
          }
          groupBy: {
            args: Prisma.HistoricoAcademicoGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistoricoAcademicoGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistoricoAcademicoCountArgs<ExtArgs>
            result: $Utils.Optional<HistoricoAcademicoCountAggregateOutputType> | number
          }
        }
      }
      Auditoria: {
        payload: Prisma.$AuditoriaPayload<ExtArgs>
        fields: Prisma.AuditoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>
          }
          findFirst: {
            args: Prisma.AuditoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>
          }
          findMany: {
            args: Prisma.AuditoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>[]
          }
          create: {
            args: Prisma.AuditoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>
          }
          createMany: {
            args: Prisma.AuditoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>
          }
          update: {
            args: Prisma.AuditoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>
          }
          deleteMany: {
            args: Prisma.AuditoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>
          }
          aggregate: {
            args: Prisma.AuditoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditoria>
          }
          groupBy: {
            args: Prisma.AuditoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditoriaCountArgs<ExtArgs>
            result: $Utils.Optional<AuditoriaCountAggregateOutputType> | number
          }
        }
      }
      EncabezadoFactura: {
        payload: Prisma.$EncabezadoFacturaPayload<ExtArgs>
        fields: Prisma.EncabezadoFacturaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncabezadoFacturaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncabezadoFacturaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncabezadoFacturaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncabezadoFacturaPayload>
          }
          findFirst: {
            args: Prisma.EncabezadoFacturaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncabezadoFacturaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncabezadoFacturaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncabezadoFacturaPayload>
          }
          findMany: {
            args: Prisma.EncabezadoFacturaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncabezadoFacturaPayload>[]
          }
          create: {
            args: Prisma.EncabezadoFacturaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncabezadoFacturaPayload>
          }
          createMany: {
            args: Prisma.EncabezadoFacturaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EncabezadoFacturaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncabezadoFacturaPayload>
          }
          update: {
            args: Prisma.EncabezadoFacturaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncabezadoFacturaPayload>
          }
          deleteMany: {
            args: Prisma.EncabezadoFacturaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncabezadoFacturaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncabezadoFacturaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncabezadoFacturaPayload>
          }
          aggregate: {
            args: Prisma.EncabezadoFacturaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncabezadoFactura>
          }
          groupBy: {
            args: Prisma.EncabezadoFacturaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncabezadoFacturaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncabezadoFacturaCountArgs<ExtArgs>
            result: $Utils.Optional<EncabezadoFacturaCountAggregateOutputType> | number
          }
        }
      }
      DetalleFactura: {
        payload: Prisma.$DetalleFacturaPayload<ExtArgs>
        fields: Prisma.DetalleFacturaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetalleFacturaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleFacturaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetalleFacturaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleFacturaPayload>
          }
          findFirst: {
            args: Prisma.DetalleFacturaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleFacturaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetalleFacturaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleFacturaPayload>
          }
          findMany: {
            args: Prisma.DetalleFacturaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleFacturaPayload>[]
          }
          create: {
            args: Prisma.DetalleFacturaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleFacturaPayload>
          }
          createMany: {
            args: Prisma.DetalleFacturaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DetalleFacturaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleFacturaPayload>
          }
          update: {
            args: Prisma.DetalleFacturaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleFacturaPayload>
          }
          deleteMany: {
            args: Prisma.DetalleFacturaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DetalleFacturaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DetalleFacturaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetalleFacturaPayload>
          }
          aggregate: {
            args: Prisma.DetalleFacturaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetalleFactura>
          }
          groupBy: {
            args: Prisma.DetalleFacturaGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetalleFacturaGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetalleFacturaCountArgs<ExtArgs>
            result: $Utils.Optional<DetalleFacturaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    cargo?: CargoOmit
    carrera?: CarreraOmit
    usuario?: UsuarioOmit
    planEstudios?: PlanEstudiosOmit
    cuatrimestre?: CuatrimestreOmit
    materia?: MateriaOmit
    curso?: CursoOmit
    matricula?: MatriculaOmit
    ofertaAcademica?: OfertaAcademicaOmit
    historicoAcademico?: HistoricoAcademicoOmit
    auditoria?: AuditoriaOmit
    encabezadoFactura?: EncabezadoFacturaOmit
    detalleFactura?: DetalleFacturaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CargoCountOutputType
   */

  export type CargoCountOutputType = {
    Usuario: number
  }

  export type CargoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | CargoCountOutputTypeCountUsuarioArgs
  }

  // Custom InputTypes
  /**
   * CargoCountOutputType without action
   */
  export type CargoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CargoCountOutputType
     */
    select?: CargoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CargoCountOutputType without action
   */
  export type CargoCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }


  /**
   * Count Type CarreraCountOutputType
   */

  export type CarreraCountOutputType = {
    OfertaAcademica: number
    PlanEstudios: number
    Usuario: number
    EncabezadoFactura: number
  }

  export type CarreraCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OfertaAcademica?: boolean | CarreraCountOutputTypeCountOfertaAcademicaArgs
    PlanEstudios?: boolean | CarreraCountOutputTypeCountPlanEstudiosArgs
    Usuario?: boolean | CarreraCountOutputTypeCountUsuarioArgs
    EncabezadoFactura?: boolean | CarreraCountOutputTypeCountEncabezadoFacturaArgs
  }

  // Custom InputTypes
  /**
   * CarreraCountOutputType without action
   */
  export type CarreraCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarreraCountOutputType
     */
    select?: CarreraCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CarreraCountOutputType without action
   */
  export type CarreraCountOutputTypeCountOfertaAcademicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfertaAcademicaWhereInput
  }

  /**
   * CarreraCountOutputType without action
   */
  export type CarreraCountOutputTypeCountPlanEstudiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanEstudiosWhereInput
  }

  /**
   * CarreraCountOutputType without action
   */
  export type CarreraCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }

  /**
   * CarreraCountOutputType without action
   */
  export type CarreraCountOutputTypeCountEncabezadoFacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncabezadoFacturaWhereInput
  }


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    Curso: number
    HistoricoAcademico: number
    Auditoria: number
    EncabezadoFactura: number
    Matricula: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Curso?: boolean | UsuarioCountOutputTypeCountCursoArgs
    HistoricoAcademico?: boolean | UsuarioCountOutputTypeCountHistoricoAcademicoArgs
    Auditoria?: boolean | UsuarioCountOutputTypeCountAuditoriaArgs
    EncabezadoFactura?: boolean | UsuarioCountOutputTypeCountEncabezadoFacturaArgs
    Matricula?: boolean | UsuarioCountOutputTypeCountMatriculaArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountCursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountHistoricoAcademicoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoricoAcademicoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditoriaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountEncabezadoFacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncabezadoFacturaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountMatriculaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatriculaWhereInput
  }


  /**
   * Count Type PlanEstudiosCountOutputType
   */

  export type PlanEstudiosCountOutputType = {
    Materia: number
  }

  export type PlanEstudiosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Materia?: boolean | PlanEstudiosCountOutputTypeCountMateriaArgs
  }

  // Custom InputTypes
  /**
   * PlanEstudiosCountOutputType without action
   */
  export type PlanEstudiosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEstudiosCountOutputType
     */
    select?: PlanEstudiosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanEstudiosCountOutputType without action
   */
  export type PlanEstudiosCountOutputTypeCountMateriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MateriaWhereInput
  }


  /**
   * Count Type CuatrimestreCountOutputType
   */

  export type CuatrimestreCountOutputType = {
    OfertaAcademica: number
    Curso: number
    EncabezadoFactura: number
  }

  export type CuatrimestreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OfertaAcademica?: boolean | CuatrimestreCountOutputTypeCountOfertaAcademicaArgs
    Curso?: boolean | CuatrimestreCountOutputTypeCountCursoArgs
    EncabezadoFactura?: boolean | CuatrimestreCountOutputTypeCountEncabezadoFacturaArgs
  }

  // Custom InputTypes
  /**
   * CuatrimestreCountOutputType without action
   */
  export type CuatrimestreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CuatrimestreCountOutputType
     */
    select?: CuatrimestreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CuatrimestreCountOutputType without action
   */
  export type CuatrimestreCountOutputTypeCountOfertaAcademicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfertaAcademicaWhereInput
  }

  /**
   * CuatrimestreCountOutputType without action
   */
  export type CuatrimestreCountOutputTypeCountCursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoWhereInput
  }

  /**
   * CuatrimestreCountOutputType without action
   */
  export type CuatrimestreCountOutputTypeCountEncabezadoFacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncabezadoFacturaWhereInput
  }


  /**
   * Count Type MateriaCountOutputType
   */

  export type MateriaCountOutputType = {
    Curso: number
  }

  export type MateriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Curso?: boolean | MateriaCountOutputTypeCountCursoArgs
  }

  // Custom InputTypes
  /**
   * MateriaCountOutputType without action
   */
  export type MateriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MateriaCountOutputType
     */
    select?: MateriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MateriaCountOutputType without action
   */
  export type MateriaCountOutputTypeCountCursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoWhereInput
  }


  /**
   * Count Type CursoCountOutputType
   */

  export type CursoCountOutputType = {
    DetalleFactura: number
    OfertaAcademica: number
    HistoricoAcademico: number
    CuMatricula: number
  }

  export type CursoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DetalleFactura?: boolean | CursoCountOutputTypeCountDetalleFacturaArgs
    OfertaAcademica?: boolean | CursoCountOutputTypeCountOfertaAcademicaArgs
    HistoricoAcademico?: boolean | CursoCountOutputTypeCountHistoricoAcademicoArgs
    CuMatricula?: boolean | CursoCountOutputTypeCountCuMatriculaArgs
  }

  // Custom InputTypes
  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCountOutputType
     */
    select?: CursoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeCountDetalleFacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleFacturaWhereInput
  }

  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeCountOfertaAcademicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfertaAcademicaWhereInput
  }

  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeCountHistoricoAcademicoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoricoAcademicoWhereInput
  }

  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeCountCuMatriculaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatriculaWhereInput
  }


  /**
   * Count Type EncabezadoFacturaCountOutputType
   */

  export type EncabezadoFacturaCountOutputType = {
    DetalleFactura: number
  }

  export type EncabezadoFacturaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DetalleFactura?: boolean | EncabezadoFacturaCountOutputTypeCountDetalleFacturaArgs
  }

  // Custom InputTypes
  /**
   * EncabezadoFacturaCountOutputType without action
   */
  export type EncabezadoFacturaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFacturaCountOutputType
     */
    select?: EncabezadoFacturaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncabezadoFacturaCountOutputType without action
   */
  export type EncabezadoFacturaCountOutputTypeCountDetalleFacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleFacturaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Cargo
   */

  export type AggregateCargo = {
    _count: CargoCountAggregateOutputType | null
    _avg: CargoAvgAggregateOutputType | null
    _sum: CargoSumAggregateOutputType | null
    _min: CargoMinAggregateOutputType | null
    _max: CargoMaxAggregateOutputType | null
  }

  export type CargoAvgAggregateOutputType = {
    id: number | null
  }

  export type CargoSumAggregateOutputType = {
    id: number | null
  }

  export type CargoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type CargoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type CargoCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type CargoAvgAggregateInputType = {
    id?: true
  }

  export type CargoSumAggregateInputType = {
    id?: true
  }

  export type CargoMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type CargoMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type CargoCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type CargoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cargo to aggregate.
     */
    where?: CargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cargos to fetch.
     */
    orderBy?: CargoOrderByWithRelationInput | CargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cargos
    **/
    _count?: true | CargoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CargoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CargoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CargoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CargoMaxAggregateInputType
  }

  export type GetCargoAggregateType<T extends CargoAggregateArgs> = {
        [P in keyof T & keyof AggregateCargo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCargo[P]>
      : GetScalarType<T[P], AggregateCargo[P]>
  }




  export type CargoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CargoWhereInput
    orderBy?: CargoOrderByWithAggregationInput | CargoOrderByWithAggregationInput[]
    by: CargoScalarFieldEnum[] | CargoScalarFieldEnum
    having?: CargoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CargoCountAggregateInputType | true
    _avg?: CargoAvgAggregateInputType
    _sum?: CargoSumAggregateInputType
    _min?: CargoMinAggregateInputType
    _max?: CargoMaxAggregateInputType
  }

  export type CargoGroupByOutputType = {
    id: number
    nombre: string
    _count: CargoCountAggregateOutputType | null
    _avg: CargoAvgAggregateOutputType | null
    _sum: CargoSumAggregateOutputType | null
    _min: CargoMinAggregateOutputType | null
    _max: CargoMaxAggregateOutputType | null
  }

  type GetCargoGroupByPayload<T extends CargoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CargoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CargoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CargoGroupByOutputType[P]>
            : GetScalarType<T[P], CargoGroupByOutputType[P]>
        }
      >
    >


  export type CargoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    Usuario?: boolean | Cargo$UsuarioArgs<ExtArgs>
    _count?: boolean | CargoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cargo"]>



  export type CargoSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type CargoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre", ExtArgs["result"]["cargo"]>
  export type CargoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | Cargo$UsuarioArgs<ExtArgs>
    _count?: boolean | CargoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CargoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cargo"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["cargo"]>
    composites: {}
  }

  type CargoGetPayload<S extends boolean | null | undefined | CargoDefaultArgs> = $Result.GetResult<Prisma.$CargoPayload, S>

  type CargoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CargoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CargoCountAggregateInputType | true
    }

  export interface CargoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cargo'], meta: { name: 'Cargo' } }
    /**
     * Find zero or one Cargo that matches the filter.
     * @param {CargoFindUniqueArgs} args - Arguments to find a Cargo
     * @example
     * // Get one Cargo
     * const cargo = await prisma.cargo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CargoFindUniqueArgs>(args: SelectSubset<T, CargoFindUniqueArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Cargo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CargoFindUniqueOrThrowArgs} args - Arguments to find a Cargo
     * @example
     * // Get one Cargo
     * const cargo = await prisma.cargo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CargoFindUniqueOrThrowArgs>(args: SelectSubset<T, CargoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Cargo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoFindFirstArgs} args - Arguments to find a Cargo
     * @example
     * // Get one Cargo
     * const cargo = await prisma.cargo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CargoFindFirstArgs>(args?: SelectSubset<T, CargoFindFirstArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Cargo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoFindFirstOrThrowArgs} args - Arguments to find a Cargo
     * @example
     * // Get one Cargo
     * const cargo = await prisma.cargo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CargoFindFirstOrThrowArgs>(args?: SelectSubset<T, CargoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Cargos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cargos
     * const cargos = await prisma.cargo.findMany()
     * 
     * // Get first 10 Cargos
     * const cargos = await prisma.cargo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cargoWithIdOnly = await prisma.cargo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CargoFindManyArgs>(args?: SelectSubset<T, CargoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Cargo.
     * @param {CargoCreateArgs} args - Arguments to create a Cargo.
     * @example
     * // Create one Cargo
     * const Cargo = await prisma.cargo.create({
     *   data: {
     *     // ... data to create a Cargo
     *   }
     * })
     * 
     */
    create<T extends CargoCreateArgs>(args: SelectSubset<T, CargoCreateArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Cargos.
     * @param {CargoCreateManyArgs} args - Arguments to create many Cargos.
     * @example
     * // Create many Cargos
     * const cargo = await prisma.cargo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CargoCreateManyArgs>(args?: SelectSubset<T, CargoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cargo.
     * @param {CargoDeleteArgs} args - Arguments to delete one Cargo.
     * @example
     * // Delete one Cargo
     * const Cargo = await prisma.cargo.delete({
     *   where: {
     *     // ... filter to delete one Cargo
     *   }
     * })
     * 
     */
    delete<T extends CargoDeleteArgs>(args: SelectSubset<T, CargoDeleteArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Cargo.
     * @param {CargoUpdateArgs} args - Arguments to update one Cargo.
     * @example
     * // Update one Cargo
     * const cargo = await prisma.cargo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CargoUpdateArgs>(args: SelectSubset<T, CargoUpdateArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Cargos.
     * @param {CargoDeleteManyArgs} args - Arguments to filter Cargos to delete.
     * @example
     * // Delete a few Cargos
     * const { count } = await prisma.cargo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CargoDeleteManyArgs>(args?: SelectSubset<T, CargoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cargos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cargos
     * const cargo = await prisma.cargo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CargoUpdateManyArgs>(args: SelectSubset<T, CargoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cargo.
     * @param {CargoUpsertArgs} args - Arguments to update or create a Cargo.
     * @example
     * // Update or create a Cargo
     * const cargo = await prisma.cargo.upsert({
     *   create: {
     *     // ... data to create a Cargo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cargo we want to update
     *   }
     * })
     */
    upsert<T extends CargoUpsertArgs>(args: SelectSubset<T, CargoUpsertArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Cargos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoCountArgs} args - Arguments to filter Cargos to count.
     * @example
     * // Count the number of Cargos
     * const count = await prisma.cargo.count({
     *   where: {
     *     // ... the filter for the Cargos we want to count
     *   }
     * })
    **/
    count<T extends CargoCountArgs>(
      args?: Subset<T, CargoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CargoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cargo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CargoAggregateArgs>(args: Subset<T, CargoAggregateArgs>): Prisma.PrismaPromise<GetCargoAggregateType<T>>

    /**
     * Group by Cargo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CargoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CargoGroupByArgs['orderBy'] }
        : { orderBy?: CargoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CargoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCargoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cargo model
   */
  readonly fields: CargoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cargo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CargoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuario<T extends Cargo$UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, Cargo$UsuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cargo model
   */ 
  interface CargoFieldRefs {
    readonly id: FieldRef<"Cargo", 'Int'>
    readonly nombre: FieldRef<"Cargo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cargo findUnique
   */
  export type CargoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * Filter, which Cargo to fetch.
     */
    where: CargoWhereUniqueInput
  }

  /**
   * Cargo findUniqueOrThrow
   */
  export type CargoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * Filter, which Cargo to fetch.
     */
    where: CargoWhereUniqueInput
  }

  /**
   * Cargo findFirst
   */
  export type CargoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * Filter, which Cargo to fetch.
     */
    where?: CargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cargos to fetch.
     */
    orderBy?: CargoOrderByWithRelationInput | CargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cargos.
     */
    cursor?: CargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cargos.
     */
    distinct?: CargoScalarFieldEnum | CargoScalarFieldEnum[]
  }

  /**
   * Cargo findFirstOrThrow
   */
  export type CargoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * Filter, which Cargo to fetch.
     */
    where?: CargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cargos to fetch.
     */
    orderBy?: CargoOrderByWithRelationInput | CargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cargos.
     */
    cursor?: CargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cargos.
     */
    distinct?: CargoScalarFieldEnum | CargoScalarFieldEnum[]
  }

  /**
   * Cargo findMany
   */
  export type CargoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * Filter, which Cargos to fetch.
     */
    where?: CargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cargos to fetch.
     */
    orderBy?: CargoOrderByWithRelationInput | CargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cargos.
     */
    cursor?: CargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cargos.
     */
    skip?: number
    distinct?: CargoScalarFieldEnum | CargoScalarFieldEnum[]
  }

  /**
   * Cargo create
   */
  export type CargoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * The data needed to create a Cargo.
     */
    data: XOR<CargoCreateInput, CargoUncheckedCreateInput>
  }

  /**
   * Cargo createMany
   */
  export type CargoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cargos.
     */
    data: CargoCreateManyInput | CargoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cargo update
   */
  export type CargoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * The data needed to update a Cargo.
     */
    data: XOR<CargoUpdateInput, CargoUncheckedUpdateInput>
    /**
     * Choose, which Cargo to update.
     */
    where: CargoWhereUniqueInput
  }

  /**
   * Cargo updateMany
   */
  export type CargoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cargos.
     */
    data: XOR<CargoUpdateManyMutationInput, CargoUncheckedUpdateManyInput>
    /**
     * Filter which Cargos to update
     */
    where?: CargoWhereInput
    /**
     * Limit how many Cargos to update.
     */
    limit?: number
  }

  /**
   * Cargo upsert
   */
  export type CargoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * The filter to search for the Cargo to update in case it exists.
     */
    where: CargoWhereUniqueInput
    /**
     * In case the Cargo found by the `where` argument doesn't exist, create a new Cargo with this data.
     */
    create: XOR<CargoCreateInput, CargoUncheckedCreateInput>
    /**
     * In case the Cargo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CargoUpdateInput, CargoUncheckedUpdateInput>
  }

  /**
   * Cargo delete
   */
  export type CargoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * Filter which Cargo to delete.
     */
    where: CargoWhereUniqueInput
  }

  /**
   * Cargo deleteMany
   */
  export type CargoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cargos to delete
     */
    where?: CargoWhereInput
    /**
     * Limit how many Cargos to delete.
     */
    limit?: number
  }

  /**
   * Cargo.Usuario
   */
  export type Cargo$UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Cargo without action
   */
  export type CargoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
  }


  /**
   * Model Carrera
   */

  export type AggregateCarrera = {
    _count: CarreraCountAggregateOutputType | null
    _avg: CarreraAvgAggregateOutputType | null
    _sum: CarreraSumAggregateOutputType | null
    _min: CarreraMinAggregateOutputType | null
    _max: CarreraMaxAggregateOutputType | null
  }

  export type CarreraAvgAggregateOutputType = {
    id: number | null
  }

  export type CarreraSumAggregateOutputType = {
    id: number | null
  }

  export type CarreraMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    especialidad: string | null
  }

  export type CarreraMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    especialidad: string | null
  }

  export type CarreraCountAggregateOutputType = {
    id: number
    nombre: number
    especialidad: number
    _all: number
  }


  export type CarreraAvgAggregateInputType = {
    id?: true
  }

  export type CarreraSumAggregateInputType = {
    id?: true
  }

  export type CarreraMinAggregateInputType = {
    id?: true
    nombre?: true
    especialidad?: true
  }

  export type CarreraMaxAggregateInputType = {
    id?: true
    nombre?: true
    especialidad?: true
  }

  export type CarreraCountAggregateInputType = {
    id?: true
    nombre?: true
    especialidad?: true
    _all?: true
  }

  export type CarreraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carrera to aggregate.
     */
    where?: CarreraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carreras to fetch.
     */
    orderBy?: CarreraOrderByWithRelationInput | CarreraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarreraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carreras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carreras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carreras
    **/
    _count?: true | CarreraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarreraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarreraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarreraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarreraMaxAggregateInputType
  }

  export type GetCarreraAggregateType<T extends CarreraAggregateArgs> = {
        [P in keyof T & keyof AggregateCarrera]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarrera[P]>
      : GetScalarType<T[P], AggregateCarrera[P]>
  }




  export type CarreraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarreraWhereInput
    orderBy?: CarreraOrderByWithAggregationInput | CarreraOrderByWithAggregationInput[]
    by: CarreraScalarFieldEnum[] | CarreraScalarFieldEnum
    having?: CarreraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarreraCountAggregateInputType | true
    _avg?: CarreraAvgAggregateInputType
    _sum?: CarreraSumAggregateInputType
    _min?: CarreraMinAggregateInputType
    _max?: CarreraMaxAggregateInputType
  }

  export type CarreraGroupByOutputType = {
    id: number
    nombre: string
    especialidad: string
    _count: CarreraCountAggregateOutputType | null
    _avg: CarreraAvgAggregateOutputType | null
    _sum: CarreraSumAggregateOutputType | null
    _min: CarreraMinAggregateOutputType | null
    _max: CarreraMaxAggregateOutputType | null
  }

  type GetCarreraGroupByPayload<T extends CarreraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarreraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarreraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarreraGroupByOutputType[P]>
            : GetScalarType<T[P], CarreraGroupByOutputType[P]>
        }
      >
    >


  export type CarreraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    especialidad?: boolean
    OfertaAcademica?: boolean | Carrera$OfertaAcademicaArgs<ExtArgs>
    PlanEstudios?: boolean | Carrera$PlanEstudiosArgs<ExtArgs>
    Usuario?: boolean | Carrera$UsuarioArgs<ExtArgs>
    EncabezadoFactura?: boolean | Carrera$EncabezadoFacturaArgs<ExtArgs>
    _count?: boolean | CarreraCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carrera"]>



  export type CarreraSelectScalar = {
    id?: boolean
    nombre?: boolean
    especialidad?: boolean
  }

  export type CarreraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "especialidad", ExtArgs["result"]["carrera"]>
  export type CarreraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OfertaAcademica?: boolean | Carrera$OfertaAcademicaArgs<ExtArgs>
    PlanEstudios?: boolean | Carrera$PlanEstudiosArgs<ExtArgs>
    Usuario?: boolean | Carrera$UsuarioArgs<ExtArgs>
    EncabezadoFactura?: boolean | Carrera$EncabezadoFacturaArgs<ExtArgs>
    _count?: boolean | CarreraCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CarreraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Carrera"
    objects: {
      OfertaAcademica: Prisma.$OfertaAcademicaPayload<ExtArgs>[]
      PlanEstudios: Prisma.$PlanEstudiosPayload<ExtArgs>[]
      Usuario: Prisma.$UsuarioPayload<ExtArgs>[]
      EncabezadoFactura: Prisma.$EncabezadoFacturaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      especialidad: string
    }, ExtArgs["result"]["carrera"]>
    composites: {}
  }

  type CarreraGetPayload<S extends boolean | null | undefined | CarreraDefaultArgs> = $Result.GetResult<Prisma.$CarreraPayload, S>

  type CarreraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CarreraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CarreraCountAggregateInputType | true
    }

  export interface CarreraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Carrera'], meta: { name: 'Carrera' } }
    /**
     * Find zero or one Carrera that matches the filter.
     * @param {CarreraFindUniqueArgs} args - Arguments to find a Carrera
     * @example
     * // Get one Carrera
     * const carrera = await prisma.carrera.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarreraFindUniqueArgs>(args: SelectSubset<T, CarreraFindUniqueArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Carrera that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CarreraFindUniqueOrThrowArgs} args - Arguments to find a Carrera
     * @example
     * // Get one Carrera
     * const carrera = await prisma.carrera.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarreraFindUniqueOrThrowArgs>(args: SelectSubset<T, CarreraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Carrera that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraFindFirstArgs} args - Arguments to find a Carrera
     * @example
     * // Get one Carrera
     * const carrera = await prisma.carrera.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarreraFindFirstArgs>(args?: SelectSubset<T, CarreraFindFirstArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Carrera that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraFindFirstOrThrowArgs} args - Arguments to find a Carrera
     * @example
     * // Get one Carrera
     * const carrera = await prisma.carrera.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarreraFindFirstOrThrowArgs>(args?: SelectSubset<T, CarreraFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Carreras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carreras
     * const carreras = await prisma.carrera.findMany()
     * 
     * // Get first 10 Carreras
     * const carreras = await prisma.carrera.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carreraWithIdOnly = await prisma.carrera.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CarreraFindManyArgs>(args?: SelectSubset<T, CarreraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Carrera.
     * @param {CarreraCreateArgs} args - Arguments to create a Carrera.
     * @example
     * // Create one Carrera
     * const Carrera = await prisma.carrera.create({
     *   data: {
     *     // ... data to create a Carrera
     *   }
     * })
     * 
     */
    create<T extends CarreraCreateArgs>(args: SelectSubset<T, CarreraCreateArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Carreras.
     * @param {CarreraCreateManyArgs} args - Arguments to create many Carreras.
     * @example
     * // Create many Carreras
     * const carrera = await prisma.carrera.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarreraCreateManyArgs>(args?: SelectSubset<T, CarreraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Carrera.
     * @param {CarreraDeleteArgs} args - Arguments to delete one Carrera.
     * @example
     * // Delete one Carrera
     * const Carrera = await prisma.carrera.delete({
     *   where: {
     *     // ... filter to delete one Carrera
     *   }
     * })
     * 
     */
    delete<T extends CarreraDeleteArgs>(args: SelectSubset<T, CarreraDeleteArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Carrera.
     * @param {CarreraUpdateArgs} args - Arguments to update one Carrera.
     * @example
     * // Update one Carrera
     * const carrera = await prisma.carrera.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarreraUpdateArgs>(args: SelectSubset<T, CarreraUpdateArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Carreras.
     * @param {CarreraDeleteManyArgs} args - Arguments to filter Carreras to delete.
     * @example
     * // Delete a few Carreras
     * const { count } = await prisma.carrera.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarreraDeleteManyArgs>(args?: SelectSubset<T, CarreraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carreras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carreras
     * const carrera = await prisma.carrera.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarreraUpdateManyArgs>(args: SelectSubset<T, CarreraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Carrera.
     * @param {CarreraUpsertArgs} args - Arguments to update or create a Carrera.
     * @example
     * // Update or create a Carrera
     * const carrera = await prisma.carrera.upsert({
     *   create: {
     *     // ... data to create a Carrera
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carrera we want to update
     *   }
     * })
     */
    upsert<T extends CarreraUpsertArgs>(args: SelectSubset<T, CarreraUpsertArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Carreras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraCountArgs} args - Arguments to filter Carreras to count.
     * @example
     * // Count the number of Carreras
     * const count = await prisma.carrera.count({
     *   where: {
     *     // ... the filter for the Carreras we want to count
     *   }
     * })
    **/
    count<T extends CarreraCountArgs>(
      args?: Subset<T, CarreraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarreraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carrera.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarreraAggregateArgs>(args: Subset<T, CarreraAggregateArgs>): Prisma.PrismaPromise<GetCarreraAggregateType<T>>

    /**
     * Group by Carrera.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarreraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarreraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarreraGroupByArgs['orderBy'] }
        : { orderBy?: CarreraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarreraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarreraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Carrera model
   */
  readonly fields: CarreraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Carrera.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarreraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OfertaAcademica<T extends Carrera$OfertaAcademicaArgs<ExtArgs> = {}>(args?: Subset<T, Carrera$OfertaAcademicaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfertaAcademicaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    PlanEstudios<T extends Carrera$PlanEstudiosArgs<ExtArgs> = {}>(args?: Subset<T, Carrera$PlanEstudiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanEstudiosPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Usuario<T extends Carrera$UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, Carrera$UsuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    EncabezadoFactura<T extends Carrera$EncabezadoFacturaArgs<ExtArgs> = {}>(args?: Subset<T, Carrera$EncabezadoFacturaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Carrera model
   */ 
  interface CarreraFieldRefs {
    readonly id: FieldRef<"Carrera", 'Int'>
    readonly nombre: FieldRef<"Carrera", 'String'>
    readonly especialidad: FieldRef<"Carrera", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Carrera findUnique
   */
  export type CarreraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * Filter, which Carrera to fetch.
     */
    where: CarreraWhereUniqueInput
  }

  /**
   * Carrera findUniqueOrThrow
   */
  export type CarreraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * Filter, which Carrera to fetch.
     */
    where: CarreraWhereUniqueInput
  }

  /**
   * Carrera findFirst
   */
  export type CarreraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * Filter, which Carrera to fetch.
     */
    where?: CarreraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carreras to fetch.
     */
    orderBy?: CarreraOrderByWithRelationInput | CarreraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carreras.
     */
    cursor?: CarreraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carreras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carreras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carreras.
     */
    distinct?: CarreraScalarFieldEnum | CarreraScalarFieldEnum[]
  }

  /**
   * Carrera findFirstOrThrow
   */
  export type CarreraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * Filter, which Carrera to fetch.
     */
    where?: CarreraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carreras to fetch.
     */
    orderBy?: CarreraOrderByWithRelationInput | CarreraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carreras.
     */
    cursor?: CarreraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carreras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carreras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carreras.
     */
    distinct?: CarreraScalarFieldEnum | CarreraScalarFieldEnum[]
  }

  /**
   * Carrera findMany
   */
  export type CarreraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * Filter, which Carreras to fetch.
     */
    where?: CarreraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carreras to fetch.
     */
    orderBy?: CarreraOrderByWithRelationInput | CarreraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carreras.
     */
    cursor?: CarreraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carreras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carreras.
     */
    skip?: number
    distinct?: CarreraScalarFieldEnum | CarreraScalarFieldEnum[]
  }

  /**
   * Carrera create
   */
  export type CarreraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * The data needed to create a Carrera.
     */
    data: XOR<CarreraCreateInput, CarreraUncheckedCreateInput>
  }

  /**
   * Carrera createMany
   */
  export type CarreraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carreras.
     */
    data: CarreraCreateManyInput | CarreraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Carrera update
   */
  export type CarreraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * The data needed to update a Carrera.
     */
    data: XOR<CarreraUpdateInput, CarreraUncheckedUpdateInput>
    /**
     * Choose, which Carrera to update.
     */
    where: CarreraWhereUniqueInput
  }

  /**
   * Carrera updateMany
   */
  export type CarreraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carreras.
     */
    data: XOR<CarreraUpdateManyMutationInput, CarreraUncheckedUpdateManyInput>
    /**
     * Filter which Carreras to update
     */
    where?: CarreraWhereInput
    /**
     * Limit how many Carreras to update.
     */
    limit?: number
  }

  /**
   * Carrera upsert
   */
  export type CarreraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * The filter to search for the Carrera to update in case it exists.
     */
    where: CarreraWhereUniqueInput
    /**
     * In case the Carrera found by the `where` argument doesn't exist, create a new Carrera with this data.
     */
    create: XOR<CarreraCreateInput, CarreraUncheckedCreateInput>
    /**
     * In case the Carrera was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarreraUpdateInput, CarreraUncheckedUpdateInput>
  }

  /**
   * Carrera delete
   */
  export type CarreraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
    /**
     * Filter which Carrera to delete.
     */
    where: CarreraWhereUniqueInput
  }

  /**
   * Carrera deleteMany
   */
  export type CarreraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carreras to delete
     */
    where?: CarreraWhereInput
    /**
     * Limit how many Carreras to delete.
     */
    limit?: number
  }

  /**
   * Carrera.OfertaAcademica
   */
  export type Carrera$OfertaAcademicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
    where?: OfertaAcademicaWhereInput
    orderBy?: OfertaAcademicaOrderByWithRelationInput | OfertaAcademicaOrderByWithRelationInput[]
    cursor?: OfertaAcademicaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfertaAcademicaScalarFieldEnum | OfertaAcademicaScalarFieldEnum[]
  }

  /**
   * Carrera.PlanEstudios
   */
  export type Carrera$PlanEstudiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEstudios
     */
    select?: PlanEstudiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEstudios
     */
    omit?: PlanEstudiosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanEstudiosInclude<ExtArgs> | null
    where?: PlanEstudiosWhereInput
    orderBy?: PlanEstudiosOrderByWithRelationInput | PlanEstudiosOrderByWithRelationInput[]
    cursor?: PlanEstudiosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanEstudiosScalarFieldEnum | PlanEstudiosScalarFieldEnum[]
  }

  /**
   * Carrera.Usuario
   */
  export type Carrera$UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Carrera.EncabezadoFactura
   */
  export type Carrera$EncabezadoFacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
    where?: EncabezadoFacturaWhereInput
    orderBy?: EncabezadoFacturaOrderByWithRelationInput | EncabezadoFacturaOrderByWithRelationInput[]
    cursor?: EncabezadoFacturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncabezadoFacturaScalarFieldEnum | EncabezadoFacturaScalarFieldEnum[]
  }

  /**
   * Carrera without action
   */
  export type CarreraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carrera
     */
    select?: CarreraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carrera
     */
    omit?: CarreraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarreraInclude<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
    id_cargo: number | null
    id_carrera: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
    id_cargo: number | null
    id_carrera: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    cedula: string | null
    nombre: string | null
    apellidos: string | null
    fecha_nacimiento: string | null
    correo: string | null
    contrasena: string | null
    id_cargo: number | null
    id_carrera: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    cedula: string | null
    nombre: string | null
    apellidos: string | null
    fecha_nacimiento: string | null
    correo: string | null
    contrasena: string | null
    id_cargo: number | null
    id_carrera: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    cedula: number
    nombre: number
    apellidos: number
    fecha_nacimiento: number
    correo: number
    contrasena: number
    id_cargo: number
    id_carrera: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
    id_cargo?: true
    id_carrera?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
    id_cargo?: true
    id_carrera?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    cedula?: true
    nombre?: true
    apellidos?: true
    fecha_nacimiento?: true
    correo?: true
    contrasena?: true
    id_cargo?: true
    id_carrera?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    cedula?: true
    nombre?: true
    apellidos?: true
    fecha_nacimiento?: true
    correo?: true
    contrasena?: true
    id_cargo?: true
    id_carrera?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    cedula?: true
    nombre?: true
    apellidos?: true
    fecha_nacimiento?: true
    correo?: true
    contrasena?: true
    id_cargo?: true
    id_carrera?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    id_cargo: number
    id_carrera: number
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cedula?: boolean
    nombre?: boolean
    apellidos?: boolean
    fecha_nacimiento?: boolean
    correo?: boolean
    contrasena?: boolean
    id_cargo?: boolean
    id_carrera?: boolean
    Cargo?: boolean | CargoDefaultArgs<ExtArgs>
    Carrera?: boolean | CarreraDefaultArgs<ExtArgs>
    Curso?: boolean | Usuario$CursoArgs<ExtArgs>
    HistoricoAcademico?: boolean | Usuario$HistoricoAcademicoArgs<ExtArgs>
    Auditoria?: boolean | Usuario$AuditoriaArgs<ExtArgs>
    EncabezadoFactura?: boolean | Usuario$EncabezadoFacturaArgs<ExtArgs>
    Matricula?: boolean | Usuario$MatriculaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>



  export type UsuarioSelectScalar = {
    id?: boolean
    cedula?: boolean
    nombre?: boolean
    apellidos?: boolean
    fecha_nacimiento?: boolean
    correo?: boolean
    contrasena?: boolean
    id_cargo?: boolean
    id_carrera?: boolean
  }

  export type UsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cedula" | "nombre" | "apellidos" | "fecha_nacimiento" | "correo" | "contrasena" | "id_cargo" | "id_carrera", ExtArgs["result"]["usuario"]>
  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cargo?: boolean | CargoDefaultArgs<ExtArgs>
    Carrera?: boolean | CarreraDefaultArgs<ExtArgs>
    Curso?: boolean | Usuario$CursoArgs<ExtArgs>
    HistoricoAcademico?: boolean | Usuario$HistoricoAcademicoArgs<ExtArgs>
    Auditoria?: boolean | Usuario$AuditoriaArgs<ExtArgs>
    EncabezadoFactura?: boolean | Usuario$EncabezadoFacturaArgs<ExtArgs>
    Matricula?: boolean | Usuario$MatriculaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      Cargo: Prisma.$CargoPayload<ExtArgs>
      Carrera: Prisma.$CarreraPayload<ExtArgs>
      Curso: Prisma.$CursoPayload<ExtArgs>[]
      HistoricoAcademico: Prisma.$HistoricoAcademicoPayload<ExtArgs>[]
      Auditoria: Prisma.$AuditoriaPayload<ExtArgs>[]
      EncabezadoFactura: Prisma.$EncabezadoFacturaPayload<ExtArgs>[]
      Matricula: Prisma.$MatriculaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cedula: string
      nombre: string
      apellidos: string
      fecha_nacimiento: string
      correo: string
      contrasena: string
      id_cargo: number
      id_carrera: number
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Cargo<T extends CargoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CargoDefaultArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Carrera<T extends CarreraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CarreraDefaultArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Curso<T extends Usuario$CursoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$CursoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    HistoricoAcademico<T extends Usuario$HistoricoAcademicoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$HistoricoAcademicoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoricoAcademicoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Auditoria<T extends Usuario$AuditoriaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$AuditoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    EncabezadoFactura<T extends Usuario$EncabezadoFacturaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$EncabezadoFacturaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Matricula<T extends Usuario$MatriculaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$MatriculaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly cedula: FieldRef<"Usuario", 'String'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly apellidos: FieldRef<"Usuario", 'String'>
    readonly fecha_nacimiento: FieldRef<"Usuario", 'String'>
    readonly correo: FieldRef<"Usuario", 'String'>
    readonly contrasena: FieldRef<"Usuario", 'String'>
    readonly id_cargo: FieldRef<"Usuario", 'Int'>
    readonly id_carrera: FieldRef<"Usuario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuario.Curso
   */
  export type Usuario$CursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    where?: CursoWhereInput
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    cursor?: CursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Usuario.HistoricoAcademico
   */
  export type Usuario$HistoricoAcademicoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoAcademico
     */
    select?: HistoricoAcademicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoAcademico
     */
    omit?: HistoricoAcademicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoricoAcademicoInclude<ExtArgs> | null
    where?: HistoricoAcademicoWhereInput
    orderBy?: HistoricoAcademicoOrderByWithRelationInput | HistoricoAcademicoOrderByWithRelationInput[]
    cursor?: HistoricoAcademicoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoricoAcademicoScalarFieldEnum | HistoricoAcademicoScalarFieldEnum[]
  }

  /**
   * Usuario.Auditoria
   */
  export type Usuario$AuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriaInclude<ExtArgs> | null
    where?: AuditoriaWhereInput
    orderBy?: AuditoriaOrderByWithRelationInput | AuditoriaOrderByWithRelationInput[]
    cursor?: AuditoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * Usuario.EncabezadoFactura
   */
  export type Usuario$EncabezadoFacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
    where?: EncabezadoFacturaWhereInput
    orderBy?: EncabezadoFacturaOrderByWithRelationInput | EncabezadoFacturaOrderByWithRelationInput[]
    cursor?: EncabezadoFacturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncabezadoFacturaScalarFieldEnum | EncabezadoFacturaScalarFieldEnum[]
  }

  /**
   * Usuario.Matricula
   */
  export type Usuario$MatriculaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Matricula
     */
    omit?: MatriculaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    where?: MatriculaWhereInput
    orderBy?: MatriculaOrderByWithRelationInput | MatriculaOrderByWithRelationInput[]
    cursor?: MatriculaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatriculaScalarFieldEnum | MatriculaScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model PlanEstudios
   */

  export type AggregatePlanEstudios = {
    _count: PlanEstudiosCountAggregateOutputType | null
    _avg: PlanEstudiosAvgAggregateOutputType | null
    _sum: PlanEstudiosSumAggregateOutputType | null
    _min: PlanEstudiosMinAggregateOutputType | null
    _max: PlanEstudiosMaxAggregateOutputType | null
  }

  export type PlanEstudiosAvgAggregateOutputType = {
    id: number | null
    anno: number | null
    id_carrera: number | null
  }

  export type PlanEstudiosSumAggregateOutputType = {
    id: number | null
    anno: number | null
    id_carrera: number | null
  }

  export type PlanEstudiosMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    anno: number | null
    id_carrera: number | null
  }

  export type PlanEstudiosMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    anno: number | null
    id_carrera: number | null
  }

  export type PlanEstudiosCountAggregateOutputType = {
    id: number
    nombre: number
    anno: number
    id_carrera: number
    _all: number
  }


  export type PlanEstudiosAvgAggregateInputType = {
    id?: true
    anno?: true
    id_carrera?: true
  }

  export type PlanEstudiosSumAggregateInputType = {
    id?: true
    anno?: true
    id_carrera?: true
  }

  export type PlanEstudiosMinAggregateInputType = {
    id?: true
    nombre?: true
    anno?: true
    id_carrera?: true
  }

  export type PlanEstudiosMaxAggregateInputType = {
    id?: true
    nombre?: true
    anno?: true
    id_carrera?: true
  }

  export type PlanEstudiosCountAggregateInputType = {
    id?: true
    nombre?: true
    anno?: true
    id_carrera?: true
    _all?: true
  }

  export type PlanEstudiosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanEstudios to aggregate.
     */
    where?: PlanEstudiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanEstudios to fetch.
     */
    orderBy?: PlanEstudiosOrderByWithRelationInput | PlanEstudiosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanEstudiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanEstudios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanEstudios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanEstudios
    **/
    _count?: true | PlanEstudiosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanEstudiosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanEstudiosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanEstudiosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanEstudiosMaxAggregateInputType
  }

  export type GetPlanEstudiosAggregateType<T extends PlanEstudiosAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanEstudios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanEstudios[P]>
      : GetScalarType<T[P], AggregatePlanEstudios[P]>
  }




  export type PlanEstudiosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanEstudiosWhereInput
    orderBy?: PlanEstudiosOrderByWithAggregationInput | PlanEstudiosOrderByWithAggregationInput[]
    by: PlanEstudiosScalarFieldEnum[] | PlanEstudiosScalarFieldEnum
    having?: PlanEstudiosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanEstudiosCountAggregateInputType | true
    _avg?: PlanEstudiosAvgAggregateInputType
    _sum?: PlanEstudiosSumAggregateInputType
    _min?: PlanEstudiosMinAggregateInputType
    _max?: PlanEstudiosMaxAggregateInputType
  }

  export type PlanEstudiosGroupByOutputType = {
    id: number
    nombre: string
    anno: number
    id_carrera: number
    _count: PlanEstudiosCountAggregateOutputType | null
    _avg: PlanEstudiosAvgAggregateOutputType | null
    _sum: PlanEstudiosSumAggregateOutputType | null
    _min: PlanEstudiosMinAggregateOutputType | null
    _max: PlanEstudiosMaxAggregateOutputType | null
  }

  type GetPlanEstudiosGroupByPayload<T extends PlanEstudiosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanEstudiosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanEstudiosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanEstudiosGroupByOutputType[P]>
            : GetScalarType<T[P], PlanEstudiosGroupByOutputType[P]>
        }
      >
    >


  export type PlanEstudiosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    anno?: boolean
    id_carrera?: boolean
    Carrera?: boolean | CarreraDefaultArgs<ExtArgs>
    Materia?: boolean | PlanEstudios$MateriaArgs<ExtArgs>
    _count?: boolean | PlanEstudiosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planEstudios"]>



  export type PlanEstudiosSelectScalar = {
    id?: boolean
    nombre?: boolean
    anno?: boolean
    id_carrera?: boolean
  }

  export type PlanEstudiosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "anno" | "id_carrera", ExtArgs["result"]["planEstudios"]>
  export type PlanEstudiosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Carrera?: boolean | CarreraDefaultArgs<ExtArgs>
    Materia?: boolean | PlanEstudios$MateriaArgs<ExtArgs>
    _count?: boolean | PlanEstudiosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PlanEstudiosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanEstudios"
    objects: {
      Carrera: Prisma.$CarreraPayload<ExtArgs>
      Materia: Prisma.$MateriaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      anno: number
      id_carrera: number
    }, ExtArgs["result"]["planEstudios"]>
    composites: {}
  }

  type PlanEstudiosGetPayload<S extends boolean | null | undefined | PlanEstudiosDefaultArgs> = $Result.GetResult<Prisma.$PlanEstudiosPayload, S>

  type PlanEstudiosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanEstudiosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanEstudiosCountAggregateInputType | true
    }

  export interface PlanEstudiosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanEstudios'], meta: { name: 'PlanEstudios' } }
    /**
     * Find zero or one PlanEstudios that matches the filter.
     * @param {PlanEstudiosFindUniqueArgs} args - Arguments to find a PlanEstudios
     * @example
     * // Get one PlanEstudios
     * const planEstudios = await prisma.planEstudios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanEstudiosFindUniqueArgs>(args: SelectSubset<T, PlanEstudiosFindUniqueArgs<ExtArgs>>): Prisma__PlanEstudiosClient<$Result.GetResult<Prisma.$PlanEstudiosPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PlanEstudios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanEstudiosFindUniqueOrThrowArgs} args - Arguments to find a PlanEstudios
     * @example
     * // Get one PlanEstudios
     * const planEstudios = await prisma.planEstudios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanEstudiosFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanEstudiosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanEstudiosClient<$Result.GetResult<Prisma.$PlanEstudiosPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PlanEstudios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEstudiosFindFirstArgs} args - Arguments to find a PlanEstudios
     * @example
     * // Get one PlanEstudios
     * const planEstudios = await prisma.planEstudios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanEstudiosFindFirstArgs>(args?: SelectSubset<T, PlanEstudiosFindFirstArgs<ExtArgs>>): Prisma__PlanEstudiosClient<$Result.GetResult<Prisma.$PlanEstudiosPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PlanEstudios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEstudiosFindFirstOrThrowArgs} args - Arguments to find a PlanEstudios
     * @example
     * // Get one PlanEstudios
     * const planEstudios = await prisma.planEstudios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanEstudiosFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanEstudiosFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanEstudiosClient<$Result.GetResult<Prisma.$PlanEstudiosPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PlanEstudios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEstudiosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanEstudios
     * const planEstudios = await prisma.planEstudios.findMany()
     * 
     * // Get first 10 PlanEstudios
     * const planEstudios = await prisma.planEstudios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planEstudiosWithIdOnly = await prisma.planEstudios.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanEstudiosFindManyArgs>(args?: SelectSubset<T, PlanEstudiosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanEstudiosPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PlanEstudios.
     * @param {PlanEstudiosCreateArgs} args - Arguments to create a PlanEstudios.
     * @example
     * // Create one PlanEstudios
     * const PlanEstudios = await prisma.planEstudios.create({
     *   data: {
     *     // ... data to create a PlanEstudios
     *   }
     * })
     * 
     */
    create<T extends PlanEstudiosCreateArgs>(args: SelectSubset<T, PlanEstudiosCreateArgs<ExtArgs>>): Prisma__PlanEstudiosClient<$Result.GetResult<Prisma.$PlanEstudiosPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PlanEstudios.
     * @param {PlanEstudiosCreateManyArgs} args - Arguments to create many PlanEstudios.
     * @example
     * // Create many PlanEstudios
     * const planEstudios = await prisma.planEstudios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanEstudiosCreateManyArgs>(args?: SelectSubset<T, PlanEstudiosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlanEstudios.
     * @param {PlanEstudiosDeleteArgs} args - Arguments to delete one PlanEstudios.
     * @example
     * // Delete one PlanEstudios
     * const PlanEstudios = await prisma.planEstudios.delete({
     *   where: {
     *     // ... filter to delete one PlanEstudios
     *   }
     * })
     * 
     */
    delete<T extends PlanEstudiosDeleteArgs>(args: SelectSubset<T, PlanEstudiosDeleteArgs<ExtArgs>>): Prisma__PlanEstudiosClient<$Result.GetResult<Prisma.$PlanEstudiosPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PlanEstudios.
     * @param {PlanEstudiosUpdateArgs} args - Arguments to update one PlanEstudios.
     * @example
     * // Update one PlanEstudios
     * const planEstudios = await prisma.planEstudios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanEstudiosUpdateArgs>(args: SelectSubset<T, PlanEstudiosUpdateArgs<ExtArgs>>): Prisma__PlanEstudiosClient<$Result.GetResult<Prisma.$PlanEstudiosPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PlanEstudios.
     * @param {PlanEstudiosDeleteManyArgs} args - Arguments to filter PlanEstudios to delete.
     * @example
     * // Delete a few PlanEstudios
     * const { count } = await prisma.planEstudios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanEstudiosDeleteManyArgs>(args?: SelectSubset<T, PlanEstudiosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanEstudios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEstudiosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanEstudios
     * const planEstudios = await prisma.planEstudios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanEstudiosUpdateManyArgs>(args: SelectSubset<T, PlanEstudiosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanEstudios.
     * @param {PlanEstudiosUpsertArgs} args - Arguments to update or create a PlanEstudios.
     * @example
     * // Update or create a PlanEstudios
     * const planEstudios = await prisma.planEstudios.upsert({
     *   create: {
     *     // ... data to create a PlanEstudios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanEstudios we want to update
     *   }
     * })
     */
    upsert<T extends PlanEstudiosUpsertArgs>(args: SelectSubset<T, PlanEstudiosUpsertArgs<ExtArgs>>): Prisma__PlanEstudiosClient<$Result.GetResult<Prisma.$PlanEstudiosPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PlanEstudios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEstudiosCountArgs} args - Arguments to filter PlanEstudios to count.
     * @example
     * // Count the number of PlanEstudios
     * const count = await prisma.planEstudios.count({
     *   where: {
     *     // ... the filter for the PlanEstudios we want to count
     *   }
     * })
    **/
    count<T extends PlanEstudiosCountArgs>(
      args?: Subset<T, PlanEstudiosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanEstudiosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanEstudios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEstudiosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanEstudiosAggregateArgs>(args: Subset<T, PlanEstudiosAggregateArgs>): Prisma.PrismaPromise<GetPlanEstudiosAggregateType<T>>

    /**
     * Group by PlanEstudios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanEstudiosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanEstudiosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanEstudiosGroupByArgs['orderBy'] }
        : { orderBy?: PlanEstudiosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanEstudiosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanEstudiosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanEstudios model
   */
  readonly fields: PlanEstudiosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanEstudios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanEstudiosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Carrera<T extends CarreraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CarreraDefaultArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Materia<T extends PlanEstudios$MateriaArgs<ExtArgs> = {}>(args?: Subset<T, PlanEstudios$MateriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanEstudios model
   */ 
  interface PlanEstudiosFieldRefs {
    readonly id: FieldRef<"PlanEstudios", 'Int'>
    readonly nombre: FieldRef<"PlanEstudios", 'String'>
    readonly anno: FieldRef<"PlanEstudios", 'Int'>
    readonly id_carrera: FieldRef<"PlanEstudios", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PlanEstudios findUnique
   */
  export type PlanEstudiosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEstudios
     */
    select?: PlanEstudiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEstudios
     */
    omit?: PlanEstudiosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanEstudiosInclude<ExtArgs> | null
    /**
     * Filter, which PlanEstudios to fetch.
     */
    where: PlanEstudiosWhereUniqueInput
  }

  /**
   * PlanEstudios findUniqueOrThrow
   */
  export type PlanEstudiosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEstudios
     */
    select?: PlanEstudiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEstudios
     */
    omit?: PlanEstudiosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanEstudiosInclude<ExtArgs> | null
    /**
     * Filter, which PlanEstudios to fetch.
     */
    where: PlanEstudiosWhereUniqueInput
  }

  /**
   * PlanEstudios findFirst
   */
  export type PlanEstudiosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEstudios
     */
    select?: PlanEstudiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEstudios
     */
    omit?: PlanEstudiosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanEstudiosInclude<ExtArgs> | null
    /**
     * Filter, which PlanEstudios to fetch.
     */
    where?: PlanEstudiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanEstudios to fetch.
     */
    orderBy?: PlanEstudiosOrderByWithRelationInput | PlanEstudiosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanEstudios.
     */
    cursor?: PlanEstudiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanEstudios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanEstudios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanEstudios.
     */
    distinct?: PlanEstudiosScalarFieldEnum | PlanEstudiosScalarFieldEnum[]
  }

  /**
   * PlanEstudios findFirstOrThrow
   */
  export type PlanEstudiosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEstudios
     */
    select?: PlanEstudiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEstudios
     */
    omit?: PlanEstudiosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanEstudiosInclude<ExtArgs> | null
    /**
     * Filter, which PlanEstudios to fetch.
     */
    where?: PlanEstudiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanEstudios to fetch.
     */
    orderBy?: PlanEstudiosOrderByWithRelationInput | PlanEstudiosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanEstudios.
     */
    cursor?: PlanEstudiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanEstudios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanEstudios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanEstudios.
     */
    distinct?: PlanEstudiosScalarFieldEnum | PlanEstudiosScalarFieldEnum[]
  }

  /**
   * PlanEstudios findMany
   */
  export type PlanEstudiosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEstudios
     */
    select?: PlanEstudiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEstudios
     */
    omit?: PlanEstudiosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanEstudiosInclude<ExtArgs> | null
    /**
     * Filter, which PlanEstudios to fetch.
     */
    where?: PlanEstudiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanEstudios to fetch.
     */
    orderBy?: PlanEstudiosOrderByWithRelationInput | PlanEstudiosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanEstudios.
     */
    cursor?: PlanEstudiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanEstudios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanEstudios.
     */
    skip?: number
    distinct?: PlanEstudiosScalarFieldEnum | PlanEstudiosScalarFieldEnum[]
  }

  /**
   * PlanEstudios create
   */
  export type PlanEstudiosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEstudios
     */
    select?: PlanEstudiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEstudios
     */
    omit?: PlanEstudiosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanEstudiosInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanEstudios.
     */
    data: XOR<PlanEstudiosCreateInput, PlanEstudiosUncheckedCreateInput>
  }

  /**
   * PlanEstudios createMany
   */
  export type PlanEstudiosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanEstudios.
     */
    data: PlanEstudiosCreateManyInput | PlanEstudiosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanEstudios update
   */
  export type PlanEstudiosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEstudios
     */
    select?: PlanEstudiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEstudios
     */
    omit?: PlanEstudiosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanEstudiosInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanEstudios.
     */
    data: XOR<PlanEstudiosUpdateInput, PlanEstudiosUncheckedUpdateInput>
    /**
     * Choose, which PlanEstudios to update.
     */
    where: PlanEstudiosWhereUniqueInput
  }

  /**
   * PlanEstudios updateMany
   */
  export type PlanEstudiosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanEstudios.
     */
    data: XOR<PlanEstudiosUpdateManyMutationInput, PlanEstudiosUncheckedUpdateManyInput>
    /**
     * Filter which PlanEstudios to update
     */
    where?: PlanEstudiosWhereInput
    /**
     * Limit how many PlanEstudios to update.
     */
    limit?: number
  }

  /**
   * PlanEstudios upsert
   */
  export type PlanEstudiosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEstudios
     */
    select?: PlanEstudiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEstudios
     */
    omit?: PlanEstudiosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanEstudiosInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanEstudios to update in case it exists.
     */
    where: PlanEstudiosWhereUniqueInput
    /**
     * In case the PlanEstudios found by the `where` argument doesn't exist, create a new PlanEstudios with this data.
     */
    create: XOR<PlanEstudiosCreateInput, PlanEstudiosUncheckedCreateInput>
    /**
     * In case the PlanEstudios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanEstudiosUpdateInput, PlanEstudiosUncheckedUpdateInput>
  }

  /**
   * PlanEstudios delete
   */
  export type PlanEstudiosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEstudios
     */
    select?: PlanEstudiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEstudios
     */
    omit?: PlanEstudiosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanEstudiosInclude<ExtArgs> | null
    /**
     * Filter which PlanEstudios to delete.
     */
    where: PlanEstudiosWhereUniqueInput
  }

  /**
   * PlanEstudios deleteMany
   */
  export type PlanEstudiosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanEstudios to delete
     */
    where?: PlanEstudiosWhereInput
    /**
     * Limit how many PlanEstudios to delete.
     */
    limit?: number
  }

  /**
   * PlanEstudios.Materia
   */
  export type PlanEstudios$MateriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    where?: MateriaWhereInput
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    cursor?: MateriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MateriaScalarFieldEnum | MateriaScalarFieldEnum[]
  }

  /**
   * PlanEstudios without action
   */
  export type PlanEstudiosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanEstudios
     */
    select?: PlanEstudiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanEstudios
     */
    omit?: PlanEstudiosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanEstudiosInclude<ExtArgs> | null
  }


  /**
   * Model Cuatrimestre
   */

  export type AggregateCuatrimestre = {
    _count: CuatrimestreCountAggregateOutputType | null
    _avg: CuatrimestreAvgAggregateOutputType | null
    _sum: CuatrimestreSumAggregateOutputType | null
    _min: CuatrimestreMinAggregateOutputType | null
    _max: CuatrimestreMaxAggregateOutputType | null
  }

  export type CuatrimestreAvgAggregateOutputType = {
    id: number | null
    numero_cuatrimestre: number | null
    anno: number | null
  }

  export type CuatrimestreSumAggregateOutputType = {
    id: number | null
    numero_cuatrimestre: number | null
    anno: number | null
  }

  export type CuatrimestreMinAggregateOutputType = {
    id: number | null
    numero_cuatrimestre: number | null
    anno: number | null
  }

  export type CuatrimestreMaxAggregateOutputType = {
    id: number | null
    numero_cuatrimestre: number | null
    anno: number | null
  }

  export type CuatrimestreCountAggregateOutputType = {
    id: number
    numero_cuatrimestre: number
    anno: number
    _all: number
  }


  export type CuatrimestreAvgAggregateInputType = {
    id?: true
    numero_cuatrimestre?: true
    anno?: true
  }

  export type CuatrimestreSumAggregateInputType = {
    id?: true
    numero_cuatrimestre?: true
    anno?: true
  }

  export type CuatrimestreMinAggregateInputType = {
    id?: true
    numero_cuatrimestre?: true
    anno?: true
  }

  export type CuatrimestreMaxAggregateInputType = {
    id?: true
    numero_cuatrimestre?: true
    anno?: true
  }

  export type CuatrimestreCountAggregateInputType = {
    id?: true
    numero_cuatrimestre?: true
    anno?: true
    _all?: true
  }

  export type CuatrimestreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cuatrimestre to aggregate.
     */
    where?: CuatrimestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuatrimestres to fetch.
     */
    orderBy?: CuatrimestreOrderByWithRelationInput | CuatrimestreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CuatrimestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuatrimestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuatrimestres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cuatrimestres
    **/
    _count?: true | CuatrimestreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CuatrimestreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CuatrimestreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CuatrimestreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CuatrimestreMaxAggregateInputType
  }

  export type GetCuatrimestreAggregateType<T extends CuatrimestreAggregateArgs> = {
        [P in keyof T & keyof AggregateCuatrimestre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCuatrimestre[P]>
      : GetScalarType<T[P], AggregateCuatrimestre[P]>
  }




  export type CuatrimestreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CuatrimestreWhereInput
    orderBy?: CuatrimestreOrderByWithAggregationInput | CuatrimestreOrderByWithAggregationInput[]
    by: CuatrimestreScalarFieldEnum[] | CuatrimestreScalarFieldEnum
    having?: CuatrimestreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CuatrimestreCountAggregateInputType | true
    _avg?: CuatrimestreAvgAggregateInputType
    _sum?: CuatrimestreSumAggregateInputType
    _min?: CuatrimestreMinAggregateInputType
    _max?: CuatrimestreMaxAggregateInputType
  }

  export type CuatrimestreGroupByOutputType = {
    id: number
    numero_cuatrimestre: number
    anno: number
    _count: CuatrimestreCountAggregateOutputType | null
    _avg: CuatrimestreAvgAggregateOutputType | null
    _sum: CuatrimestreSumAggregateOutputType | null
    _min: CuatrimestreMinAggregateOutputType | null
    _max: CuatrimestreMaxAggregateOutputType | null
  }

  type GetCuatrimestreGroupByPayload<T extends CuatrimestreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CuatrimestreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CuatrimestreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CuatrimestreGroupByOutputType[P]>
            : GetScalarType<T[P], CuatrimestreGroupByOutputType[P]>
        }
      >
    >


  export type CuatrimestreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero_cuatrimestre?: boolean
    anno?: boolean
    OfertaAcademica?: boolean | Cuatrimestre$OfertaAcademicaArgs<ExtArgs>
    Curso?: boolean | Cuatrimestre$CursoArgs<ExtArgs>
    EncabezadoFactura?: boolean | Cuatrimestre$EncabezadoFacturaArgs<ExtArgs>
    _count?: boolean | CuatrimestreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cuatrimestre"]>



  export type CuatrimestreSelectScalar = {
    id?: boolean
    numero_cuatrimestre?: boolean
    anno?: boolean
  }

  export type CuatrimestreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numero_cuatrimestre" | "anno", ExtArgs["result"]["cuatrimestre"]>
  export type CuatrimestreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OfertaAcademica?: boolean | Cuatrimestre$OfertaAcademicaArgs<ExtArgs>
    Curso?: boolean | Cuatrimestre$CursoArgs<ExtArgs>
    EncabezadoFactura?: boolean | Cuatrimestre$EncabezadoFacturaArgs<ExtArgs>
    _count?: boolean | CuatrimestreCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CuatrimestrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cuatrimestre"
    objects: {
      OfertaAcademica: Prisma.$OfertaAcademicaPayload<ExtArgs>[]
      Curso: Prisma.$CursoPayload<ExtArgs>[]
      EncabezadoFactura: Prisma.$EncabezadoFacturaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      numero_cuatrimestre: number
      anno: number
    }, ExtArgs["result"]["cuatrimestre"]>
    composites: {}
  }

  type CuatrimestreGetPayload<S extends boolean | null | undefined | CuatrimestreDefaultArgs> = $Result.GetResult<Prisma.$CuatrimestrePayload, S>

  type CuatrimestreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CuatrimestreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CuatrimestreCountAggregateInputType | true
    }

  export interface CuatrimestreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cuatrimestre'], meta: { name: 'Cuatrimestre' } }
    /**
     * Find zero or one Cuatrimestre that matches the filter.
     * @param {CuatrimestreFindUniqueArgs} args - Arguments to find a Cuatrimestre
     * @example
     * // Get one Cuatrimestre
     * const cuatrimestre = await prisma.cuatrimestre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CuatrimestreFindUniqueArgs>(args: SelectSubset<T, CuatrimestreFindUniqueArgs<ExtArgs>>): Prisma__CuatrimestreClient<$Result.GetResult<Prisma.$CuatrimestrePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Cuatrimestre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CuatrimestreFindUniqueOrThrowArgs} args - Arguments to find a Cuatrimestre
     * @example
     * // Get one Cuatrimestre
     * const cuatrimestre = await prisma.cuatrimestre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CuatrimestreFindUniqueOrThrowArgs>(args: SelectSubset<T, CuatrimestreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CuatrimestreClient<$Result.GetResult<Prisma.$CuatrimestrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Cuatrimestre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuatrimestreFindFirstArgs} args - Arguments to find a Cuatrimestre
     * @example
     * // Get one Cuatrimestre
     * const cuatrimestre = await prisma.cuatrimestre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CuatrimestreFindFirstArgs>(args?: SelectSubset<T, CuatrimestreFindFirstArgs<ExtArgs>>): Prisma__CuatrimestreClient<$Result.GetResult<Prisma.$CuatrimestrePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Cuatrimestre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuatrimestreFindFirstOrThrowArgs} args - Arguments to find a Cuatrimestre
     * @example
     * // Get one Cuatrimestre
     * const cuatrimestre = await prisma.cuatrimestre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CuatrimestreFindFirstOrThrowArgs>(args?: SelectSubset<T, CuatrimestreFindFirstOrThrowArgs<ExtArgs>>): Prisma__CuatrimestreClient<$Result.GetResult<Prisma.$CuatrimestrePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Cuatrimestres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuatrimestreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cuatrimestres
     * const cuatrimestres = await prisma.cuatrimestre.findMany()
     * 
     * // Get first 10 Cuatrimestres
     * const cuatrimestres = await prisma.cuatrimestre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cuatrimestreWithIdOnly = await prisma.cuatrimestre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CuatrimestreFindManyArgs>(args?: SelectSubset<T, CuatrimestreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CuatrimestrePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Cuatrimestre.
     * @param {CuatrimestreCreateArgs} args - Arguments to create a Cuatrimestre.
     * @example
     * // Create one Cuatrimestre
     * const Cuatrimestre = await prisma.cuatrimestre.create({
     *   data: {
     *     // ... data to create a Cuatrimestre
     *   }
     * })
     * 
     */
    create<T extends CuatrimestreCreateArgs>(args: SelectSubset<T, CuatrimestreCreateArgs<ExtArgs>>): Prisma__CuatrimestreClient<$Result.GetResult<Prisma.$CuatrimestrePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Cuatrimestres.
     * @param {CuatrimestreCreateManyArgs} args - Arguments to create many Cuatrimestres.
     * @example
     * // Create many Cuatrimestres
     * const cuatrimestre = await prisma.cuatrimestre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CuatrimestreCreateManyArgs>(args?: SelectSubset<T, CuatrimestreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cuatrimestre.
     * @param {CuatrimestreDeleteArgs} args - Arguments to delete one Cuatrimestre.
     * @example
     * // Delete one Cuatrimestre
     * const Cuatrimestre = await prisma.cuatrimestre.delete({
     *   where: {
     *     // ... filter to delete one Cuatrimestre
     *   }
     * })
     * 
     */
    delete<T extends CuatrimestreDeleteArgs>(args: SelectSubset<T, CuatrimestreDeleteArgs<ExtArgs>>): Prisma__CuatrimestreClient<$Result.GetResult<Prisma.$CuatrimestrePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Cuatrimestre.
     * @param {CuatrimestreUpdateArgs} args - Arguments to update one Cuatrimestre.
     * @example
     * // Update one Cuatrimestre
     * const cuatrimestre = await prisma.cuatrimestre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CuatrimestreUpdateArgs>(args: SelectSubset<T, CuatrimestreUpdateArgs<ExtArgs>>): Prisma__CuatrimestreClient<$Result.GetResult<Prisma.$CuatrimestrePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Cuatrimestres.
     * @param {CuatrimestreDeleteManyArgs} args - Arguments to filter Cuatrimestres to delete.
     * @example
     * // Delete a few Cuatrimestres
     * const { count } = await prisma.cuatrimestre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CuatrimestreDeleteManyArgs>(args?: SelectSubset<T, CuatrimestreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cuatrimestres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuatrimestreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cuatrimestres
     * const cuatrimestre = await prisma.cuatrimestre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CuatrimestreUpdateManyArgs>(args: SelectSubset<T, CuatrimestreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cuatrimestre.
     * @param {CuatrimestreUpsertArgs} args - Arguments to update or create a Cuatrimestre.
     * @example
     * // Update or create a Cuatrimestre
     * const cuatrimestre = await prisma.cuatrimestre.upsert({
     *   create: {
     *     // ... data to create a Cuatrimestre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cuatrimestre we want to update
     *   }
     * })
     */
    upsert<T extends CuatrimestreUpsertArgs>(args: SelectSubset<T, CuatrimestreUpsertArgs<ExtArgs>>): Prisma__CuatrimestreClient<$Result.GetResult<Prisma.$CuatrimestrePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Cuatrimestres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuatrimestreCountArgs} args - Arguments to filter Cuatrimestres to count.
     * @example
     * // Count the number of Cuatrimestres
     * const count = await prisma.cuatrimestre.count({
     *   where: {
     *     // ... the filter for the Cuatrimestres we want to count
     *   }
     * })
    **/
    count<T extends CuatrimestreCountArgs>(
      args?: Subset<T, CuatrimestreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CuatrimestreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cuatrimestre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuatrimestreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CuatrimestreAggregateArgs>(args: Subset<T, CuatrimestreAggregateArgs>): Prisma.PrismaPromise<GetCuatrimestreAggregateType<T>>

    /**
     * Group by Cuatrimestre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CuatrimestreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CuatrimestreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CuatrimestreGroupByArgs['orderBy'] }
        : { orderBy?: CuatrimestreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CuatrimestreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCuatrimestreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cuatrimestre model
   */
  readonly fields: CuatrimestreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cuatrimestre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CuatrimestreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OfertaAcademica<T extends Cuatrimestre$OfertaAcademicaArgs<ExtArgs> = {}>(args?: Subset<T, Cuatrimestre$OfertaAcademicaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfertaAcademicaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Curso<T extends Cuatrimestre$CursoArgs<ExtArgs> = {}>(args?: Subset<T, Cuatrimestre$CursoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    EncabezadoFactura<T extends Cuatrimestre$EncabezadoFacturaArgs<ExtArgs> = {}>(args?: Subset<T, Cuatrimestre$EncabezadoFacturaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cuatrimestre model
   */ 
  interface CuatrimestreFieldRefs {
    readonly id: FieldRef<"Cuatrimestre", 'Int'>
    readonly numero_cuatrimestre: FieldRef<"Cuatrimestre", 'Int'>
    readonly anno: FieldRef<"Cuatrimestre", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Cuatrimestre findUnique
   */
  export type CuatrimestreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuatrimestre
     */
    select?: CuatrimestreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuatrimestre
     */
    omit?: CuatrimestreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuatrimestreInclude<ExtArgs> | null
    /**
     * Filter, which Cuatrimestre to fetch.
     */
    where: CuatrimestreWhereUniqueInput
  }

  /**
   * Cuatrimestre findUniqueOrThrow
   */
  export type CuatrimestreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuatrimestre
     */
    select?: CuatrimestreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuatrimestre
     */
    omit?: CuatrimestreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuatrimestreInclude<ExtArgs> | null
    /**
     * Filter, which Cuatrimestre to fetch.
     */
    where: CuatrimestreWhereUniqueInput
  }

  /**
   * Cuatrimestre findFirst
   */
  export type CuatrimestreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuatrimestre
     */
    select?: CuatrimestreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuatrimestre
     */
    omit?: CuatrimestreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuatrimestreInclude<ExtArgs> | null
    /**
     * Filter, which Cuatrimestre to fetch.
     */
    where?: CuatrimestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuatrimestres to fetch.
     */
    orderBy?: CuatrimestreOrderByWithRelationInput | CuatrimestreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cuatrimestres.
     */
    cursor?: CuatrimestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuatrimestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuatrimestres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cuatrimestres.
     */
    distinct?: CuatrimestreScalarFieldEnum | CuatrimestreScalarFieldEnum[]
  }

  /**
   * Cuatrimestre findFirstOrThrow
   */
  export type CuatrimestreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuatrimestre
     */
    select?: CuatrimestreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuatrimestre
     */
    omit?: CuatrimestreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuatrimestreInclude<ExtArgs> | null
    /**
     * Filter, which Cuatrimestre to fetch.
     */
    where?: CuatrimestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuatrimestres to fetch.
     */
    orderBy?: CuatrimestreOrderByWithRelationInput | CuatrimestreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cuatrimestres.
     */
    cursor?: CuatrimestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuatrimestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuatrimestres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cuatrimestres.
     */
    distinct?: CuatrimestreScalarFieldEnum | CuatrimestreScalarFieldEnum[]
  }

  /**
   * Cuatrimestre findMany
   */
  export type CuatrimestreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuatrimestre
     */
    select?: CuatrimestreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuatrimestre
     */
    omit?: CuatrimestreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuatrimestreInclude<ExtArgs> | null
    /**
     * Filter, which Cuatrimestres to fetch.
     */
    where?: CuatrimestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cuatrimestres to fetch.
     */
    orderBy?: CuatrimestreOrderByWithRelationInput | CuatrimestreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cuatrimestres.
     */
    cursor?: CuatrimestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cuatrimestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cuatrimestres.
     */
    skip?: number
    distinct?: CuatrimestreScalarFieldEnum | CuatrimestreScalarFieldEnum[]
  }

  /**
   * Cuatrimestre create
   */
  export type CuatrimestreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuatrimestre
     */
    select?: CuatrimestreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuatrimestre
     */
    omit?: CuatrimestreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuatrimestreInclude<ExtArgs> | null
    /**
     * The data needed to create a Cuatrimestre.
     */
    data: XOR<CuatrimestreCreateInput, CuatrimestreUncheckedCreateInput>
  }

  /**
   * Cuatrimestre createMany
   */
  export type CuatrimestreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cuatrimestres.
     */
    data: CuatrimestreCreateManyInput | CuatrimestreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cuatrimestre update
   */
  export type CuatrimestreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuatrimestre
     */
    select?: CuatrimestreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuatrimestre
     */
    omit?: CuatrimestreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuatrimestreInclude<ExtArgs> | null
    /**
     * The data needed to update a Cuatrimestre.
     */
    data: XOR<CuatrimestreUpdateInput, CuatrimestreUncheckedUpdateInput>
    /**
     * Choose, which Cuatrimestre to update.
     */
    where: CuatrimestreWhereUniqueInput
  }

  /**
   * Cuatrimestre updateMany
   */
  export type CuatrimestreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cuatrimestres.
     */
    data: XOR<CuatrimestreUpdateManyMutationInput, CuatrimestreUncheckedUpdateManyInput>
    /**
     * Filter which Cuatrimestres to update
     */
    where?: CuatrimestreWhereInput
    /**
     * Limit how many Cuatrimestres to update.
     */
    limit?: number
  }

  /**
   * Cuatrimestre upsert
   */
  export type CuatrimestreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuatrimestre
     */
    select?: CuatrimestreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuatrimestre
     */
    omit?: CuatrimestreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuatrimestreInclude<ExtArgs> | null
    /**
     * The filter to search for the Cuatrimestre to update in case it exists.
     */
    where: CuatrimestreWhereUniqueInput
    /**
     * In case the Cuatrimestre found by the `where` argument doesn't exist, create a new Cuatrimestre with this data.
     */
    create: XOR<CuatrimestreCreateInput, CuatrimestreUncheckedCreateInput>
    /**
     * In case the Cuatrimestre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CuatrimestreUpdateInput, CuatrimestreUncheckedUpdateInput>
  }

  /**
   * Cuatrimestre delete
   */
  export type CuatrimestreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuatrimestre
     */
    select?: CuatrimestreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuatrimestre
     */
    omit?: CuatrimestreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuatrimestreInclude<ExtArgs> | null
    /**
     * Filter which Cuatrimestre to delete.
     */
    where: CuatrimestreWhereUniqueInput
  }

  /**
   * Cuatrimestre deleteMany
   */
  export type CuatrimestreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cuatrimestres to delete
     */
    where?: CuatrimestreWhereInput
    /**
     * Limit how many Cuatrimestres to delete.
     */
    limit?: number
  }

  /**
   * Cuatrimestre.OfertaAcademica
   */
  export type Cuatrimestre$OfertaAcademicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
    where?: OfertaAcademicaWhereInput
    orderBy?: OfertaAcademicaOrderByWithRelationInput | OfertaAcademicaOrderByWithRelationInput[]
    cursor?: OfertaAcademicaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfertaAcademicaScalarFieldEnum | OfertaAcademicaScalarFieldEnum[]
  }

  /**
   * Cuatrimestre.Curso
   */
  export type Cuatrimestre$CursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    where?: CursoWhereInput
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    cursor?: CursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Cuatrimestre.EncabezadoFactura
   */
  export type Cuatrimestre$EncabezadoFacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
    where?: EncabezadoFacturaWhereInput
    orderBy?: EncabezadoFacturaOrderByWithRelationInput | EncabezadoFacturaOrderByWithRelationInput[]
    cursor?: EncabezadoFacturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncabezadoFacturaScalarFieldEnum | EncabezadoFacturaScalarFieldEnum[]
  }

  /**
   * Cuatrimestre without action
   */
  export type CuatrimestreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cuatrimestre
     */
    select?: CuatrimestreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cuatrimestre
     */
    omit?: CuatrimestreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CuatrimestreInclude<ExtArgs> | null
  }


  /**
   * Model Materia
   */

  export type AggregateMateria = {
    _count: MateriaCountAggregateOutputType | null
    _avg: MateriaAvgAggregateOutputType | null
    _sum: MateriaSumAggregateOutputType | null
    _min: MateriaMinAggregateOutputType | null
    _max: MateriaMaxAggregateOutputType | null
  }

  export type MateriaAvgAggregateOutputType = {
    id: number | null
    id_plan_estudios: number | null
  }

  export type MateriaSumAggregateOutputType = {
    id: number | null
    id_plan_estudios: number | null
  }

  export type MateriaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    codigo: string | null
    id_plan_estudios: number | null
  }

  export type MateriaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    codigo: string | null
    id_plan_estudios: number | null
  }

  export type MateriaCountAggregateOutputType = {
    id: number
    nombre: number
    codigo: number
    id_plan_estudios: number
    _all: number
  }


  export type MateriaAvgAggregateInputType = {
    id?: true
    id_plan_estudios?: true
  }

  export type MateriaSumAggregateInputType = {
    id?: true
    id_plan_estudios?: true
  }

  export type MateriaMinAggregateInputType = {
    id?: true
    nombre?: true
    codigo?: true
    id_plan_estudios?: true
  }

  export type MateriaMaxAggregateInputType = {
    id?: true
    nombre?: true
    codigo?: true
    id_plan_estudios?: true
  }

  export type MateriaCountAggregateInputType = {
    id?: true
    nombre?: true
    codigo?: true
    id_plan_estudios?: true
    _all?: true
  }

  export type MateriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materia to aggregate.
     */
    where?: MateriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materias to fetch.
     */
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MateriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materias
    **/
    _count?: true | MateriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MateriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MateriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MateriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MateriaMaxAggregateInputType
  }

  export type GetMateriaAggregateType<T extends MateriaAggregateArgs> = {
        [P in keyof T & keyof AggregateMateria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMateria[P]>
      : GetScalarType<T[P], AggregateMateria[P]>
  }




  export type MateriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MateriaWhereInput
    orderBy?: MateriaOrderByWithAggregationInput | MateriaOrderByWithAggregationInput[]
    by: MateriaScalarFieldEnum[] | MateriaScalarFieldEnum
    having?: MateriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MateriaCountAggregateInputType | true
    _avg?: MateriaAvgAggregateInputType
    _sum?: MateriaSumAggregateInputType
    _min?: MateriaMinAggregateInputType
    _max?: MateriaMaxAggregateInputType
  }

  export type MateriaGroupByOutputType = {
    id: number
    nombre: string
    codigo: string
    id_plan_estudios: number
    _count: MateriaCountAggregateOutputType | null
    _avg: MateriaAvgAggregateOutputType | null
    _sum: MateriaSumAggregateOutputType | null
    _min: MateriaMinAggregateOutputType | null
    _max: MateriaMaxAggregateOutputType | null
  }

  type GetMateriaGroupByPayload<T extends MateriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MateriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MateriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MateriaGroupByOutputType[P]>
            : GetScalarType<T[P], MateriaGroupByOutputType[P]>
        }
      >
    >


  export type MateriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    codigo?: boolean
    id_plan_estudios?: boolean
    PlanEstudios?: boolean | PlanEstudiosDefaultArgs<ExtArgs>
    Curso?: boolean | Materia$CursoArgs<ExtArgs>
    _count?: boolean | MateriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materia"]>



  export type MateriaSelectScalar = {
    id?: boolean
    nombre?: boolean
    codigo?: boolean
    id_plan_estudios?: boolean
  }

  export type MateriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "codigo" | "id_plan_estudios", ExtArgs["result"]["materia"]>
  export type MateriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PlanEstudios?: boolean | PlanEstudiosDefaultArgs<ExtArgs>
    Curso?: boolean | Materia$CursoArgs<ExtArgs>
    _count?: boolean | MateriaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MateriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Materia"
    objects: {
      PlanEstudios: Prisma.$PlanEstudiosPayload<ExtArgs>
      Curso: Prisma.$CursoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      codigo: string
      id_plan_estudios: number
    }, ExtArgs["result"]["materia"]>
    composites: {}
  }

  type MateriaGetPayload<S extends boolean | null | undefined | MateriaDefaultArgs> = $Result.GetResult<Prisma.$MateriaPayload, S>

  type MateriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MateriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MateriaCountAggregateInputType | true
    }

  export interface MateriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Materia'], meta: { name: 'Materia' } }
    /**
     * Find zero or one Materia that matches the filter.
     * @param {MateriaFindUniqueArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MateriaFindUniqueArgs>(args: SelectSubset<T, MateriaFindUniqueArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Materia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MateriaFindUniqueOrThrowArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MateriaFindUniqueOrThrowArgs>(args: SelectSubset<T, MateriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Materia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaFindFirstArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MateriaFindFirstArgs>(args?: SelectSubset<T, MateriaFindFirstArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Materia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaFindFirstOrThrowArgs} args - Arguments to find a Materia
     * @example
     * // Get one Materia
     * const materia = await prisma.materia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MateriaFindFirstOrThrowArgs>(args?: SelectSubset<T, MateriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Materias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materias
     * const materias = await prisma.materia.findMany()
     * 
     * // Get first 10 Materias
     * const materias = await prisma.materia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materiaWithIdOnly = await prisma.materia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MateriaFindManyArgs>(args?: SelectSubset<T, MateriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Materia.
     * @param {MateriaCreateArgs} args - Arguments to create a Materia.
     * @example
     * // Create one Materia
     * const Materia = await prisma.materia.create({
     *   data: {
     *     // ... data to create a Materia
     *   }
     * })
     * 
     */
    create<T extends MateriaCreateArgs>(args: SelectSubset<T, MateriaCreateArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Materias.
     * @param {MateriaCreateManyArgs} args - Arguments to create many Materias.
     * @example
     * // Create many Materias
     * const materia = await prisma.materia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MateriaCreateManyArgs>(args?: SelectSubset<T, MateriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Materia.
     * @param {MateriaDeleteArgs} args - Arguments to delete one Materia.
     * @example
     * // Delete one Materia
     * const Materia = await prisma.materia.delete({
     *   where: {
     *     // ... filter to delete one Materia
     *   }
     * })
     * 
     */
    delete<T extends MateriaDeleteArgs>(args: SelectSubset<T, MateriaDeleteArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Materia.
     * @param {MateriaUpdateArgs} args - Arguments to update one Materia.
     * @example
     * // Update one Materia
     * const materia = await prisma.materia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MateriaUpdateArgs>(args: SelectSubset<T, MateriaUpdateArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Materias.
     * @param {MateriaDeleteManyArgs} args - Arguments to filter Materias to delete.
     * @example
     * // Delete a few Materias
     * const { count } = await prisma.materia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MateriaDeleteManyArgs>(args?: SelectSubset<T, MateriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materias
     * const materia = await prisma.materia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MateriaUpdateManyArgs>(args: SelectSubset<T, MateriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Materia.
     * @param {MateriaUpsertArgs} args - Arguments to update or create a Materia.
     * @example
     * // Update or create a Materia
     * const materia = await prisma.materia.upsert({
     *   create: {
     *     // ... data to create a Materia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materia we want to update
     *   }
     * })
     */
    upsert<T extends MateriaUpsertArgs>(args: SelectSubset<T, MateriaUpsertArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Materias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaCountArgs} args - Arguments to filter Materias to count.
     * @example
     * // Count the number of Materias
     * const count = await prisma.materia.count({
     *   where: {
     *     // ... the filter for the Materias we want to count
     *   }
     * })
    **/
    count<T extends MateriaCountArgs>(
      args?: Subset<T, MateriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MateriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MateriaAggregateArgs>(args: Subset<T, MateriaAggregateArgs>): Prisma.PrismaPromise<GetMateriaAggregateType<T>>

    /**
     * Group by Materia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MateriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MateriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MateriaGroupByArgs['orderBy'] }
        : { orderBy?: MateriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MateriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMateriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Materia model
   */
  readonly fields: MateriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Materia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MateriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PlanEstudios<T extends PlanEstudiosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanEstudiosDefaultArgs<ExtArgs>>): Prisma__PlanEstudiosClient<$Result.GetResult<Prisma.$PlanEstudiosPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Curso<T extends Materia$CursoArgs<ExtArgs> = {}>(args?: Subset<T, Materia$CursoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Materia model
   */ 
  interface MateriaFieldRefs {
    readonly id: FieldRef<"Materia", 'Int'>
    readonly nombre: FieldRef<"Materia", 'String'>
    readonly codigo: FieldRef<"Materia", 'String'>
    readonly id_plan_estudios: FieldRef<"Materia", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Materia findUnique
   */
  export type MateriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materia to fetch.
     */
    where: MateriaWhereUniqueInput
  }

  /**
   * Materia findUniqueOrThrow
   */
  export type MateriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materia to fetch.
     */
    where: MateriaWhereUniqueInput
  }

  /**
   * Materia findFirst
   */
  export type MateriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materia to fetch.
     */
    where?: MateriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materias to fetch.
     */
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materias.
     */
    cursor?: MateriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materias.
     */
    distinct?: MateriaScalarFieldEnum | MateriaScalarFieldEnum[]
  }

  /**
   * Materia findFirstOrThrow
   */
  export type MateriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materia to fetch.
     */
    where?: MateriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materias to fetch.
     */
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materias.
     */
    cursor?: MateriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materias.
     */
    distinct?: MateriaScalarFieldEnum | MateriaScalarFieldEnum[]
  }

  /**
   * Materia findMany
   */
  export type MateriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter, which Materias to fetch.
     */
    where?: MateriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materias to fetch.
     */
    orderBy?: MateriaOrderByWithRelationInput | MateriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materias.
     */
    cursor?: MateriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materias.
     */
    skip?: number
    distinct?: MateriaScalarFieldEnum | MateriaScalarFieldEnum[]
  }

  /**
   * Materia create
   */
  export type MateriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Materia.
     */
    data: XOR<MateriaCreateInput, MateriaUncheckedCreateInput>
  }

  /**
   * Materia createMany
   */
  export type MateriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materias.
     */
    data: MateriaCreateManyInput | MateriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Materia update
   */
  export type MateriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Materia.
     */
    data: XOR<MateriaUpdateInput, MateriaUncheckedUpdateInput>
    /**
     * Choose, which Materia to update.
     */
    where: MateriaWhereUniqueInput
  }

  /**
   * Materia updateMany
   */
  export type MateriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materias.
     */
    data: XOR<MateriaUpdateManyMutationInput, MateriaUncheckedUpdateManyInput>
    /**
     * Filter which Materias to update
     */
    where?: MateriaWhereInput
    /**
     * Limit how many Materias to update.
     */
    limit?: number
  }

  /**
   * Materia upsert
   */
  export type MateriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Materia to update in case it exists.
     */
    where: MateriaWhereUniqueInput
    /**
     * In case the Materia found by the `where` argument doesn't exist, create a new Materia with this data.
     */
    create: XOR<MateriaCreateInput, MateriaUncheckedCreateInput>
    /**
     * In case the Materia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MateriaUpdateInput, MateriaUncheckedUpdateInput>
  }

  /**
   * Materia delete
   */
  export type MateriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
    /**
     * Filter which Materia to delete.
     */
    where: MateriaWhereUniqueInput
  }

  /**
   * Materia deleteMany
   */
  export type MateriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materias to delete
     */
    where?: MateriaWhereInput
    /**
     * Limit how many Materias to delete.
     */
    limit?: number
  }

  /**
   * Materia.Curso
   */
  export type Materia$CursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    where?: CursoWhereInput
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    cursor?: CursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Materia without action
   */
  export type MateriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materia
     */
    select?: MateriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Materia
     */
    omit?: MateriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MateriaInclude<ExtArgs> | null
  }


  /**
   * Model Curso
   */

  export type AggregateCurso = {
    _count: CursoCountAggregateOutputType | null
    _avg: CursoAvgAggregateOutputType | null
    _sum: CursoSumAggregateOutputType | null
    _min: CursoMinAggregateOutputType | null
    _max: CursoMaxAggregateOutputType | null
  }

  export type CursoAvgAggregateOutputType = {
    id: number | null
    id_materia: number | null
    id_docente: number | null
    id_cuatrimestre: number | null
  }

  export type CursoSumAggregateOutputType = {
    id: number | null
    id_materia: number | null
    id_docente: number | null
    id_cuatrimestre: number | null
  }

  export type CursoMinAggregateOutputType = {
    id: number | null
    id_materia: number | null
    id_docente: number | null
    horario: string | null
    aula: string | null
    id_cuatrimestre: number | null
  }

  export type CursoMaxAggregateOutputType = {
    id: number | null
    id_materia: number | null
    id_docente: number | null
    horario: string | null
    aula: string | null
    id_cuatrimestre: number | null
  }

  export type CursoCountAggregateOutputType = {
    id: number
    id_materia: number
    id_docente: number
    horario: number
    aula: number
    id_cuatrimestre: number
    _all: number
  }


  export type CursoAvgAggregateInputType = {
    id?: true
    id_materia?: true
    id_docente?: true
    id_cuatrimestre?: true
  }

  export type CursoSumAggregateInputType = {
    id?: true
    id_materia?: true
    id_docente?: true
    id_cuatrimestre?: true
  }

  export type CursoMinAggregateInputType = {
    id?: true
    id_materia?: true
    id_docente?: true
    horario?: true
    aula?: true
    id_cuatrimestre?: true
  }

  export type CursoMaxAggregateInputType = {
    id?: true
    id_materia?: true
    id_docente?: true
    horario?: true
    aula?: true
    id_cuatrimestre?: true
  }

  export type CursoCountAggregateInputType = {
    id?: true
    id_materia?: true
    id_docente?: true
    horario?: true
    aula?: true
    id_cuatrimestre?: true
    _all?: true
  }

  export type CursoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Curso to aggregate.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cursos
    **/
    _count?: true | CursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CursoMaxAggregateInputType
  }

  export type GetCursoAggregateType<T extends CursoAggregateArgs> = {
        [P in keyof T & keyof AggregateCurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurso[P]>
      : GetScalarType<T[P], AggregateCurso[P]>
  }




  export type CursoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoWhereInput
    orderBy?: CursoOrderByWithAggregationInput | CursoOrderByWithAggregationInput[]
    by: CursoScalarFieldEnum[] | CursoScalarFieldEnum
    having?: CursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CursoCountAggregateInputType | true
    _avg?: CursoAvgAggregateInputType
    _sum?: CursoSumAggregateInputType
    _min?: CursoMinAggregateInputType
    _max?: CursoMaxAggregateInputType
  }

  export type CursoGroupByOutputType = {
    id: number
    id_materia: number
    id_docente: number
    horario: string
    aula: string
    id_cuatrimestre: number
    _count: CursoCountAggregateOutputType | null
    _avg: CursoAvgAggregateOutputType | null
    _sum: CursoSumAggregateOutputType | null
    _min: CursoMinAggregateOutputType | null
    _max: CursoMaxAggregateOutputType | null
  }

  type GetCursoGroupByPayload<T extends CursoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CursoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CursoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CursoGroupByOutputType[P]>
            : GetScalarType<T[P], CursoGroupByOutputType[P]>
        }
      >
    >


  export type CursoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_materia?: boolean
    id_docente?: boolean
    horario?: boolean
    aula?: boolean
    id_cuatrimestre?: boolean
    Materia?: boolean | MateriaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Cuatrimestre?: boolean | CuatrimestreDefaultArgs<ExtArgs>
    DetalleFactura?: boolean | Curso$DetalleFacturaArgs<ExtArgs>
    OfertaAcademica?: boolean | Curso$OfertaAcademicaArgs<ExtArgs>
    HistoricoAcademico?: boolean | Curso$HistoricoAcademicoArgs<ExtArgs>
    CuMatricula?: boolean | Curso$CuMatriculaArgs<ExtArgs>
    _count?: boolean | CursoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["curso"]>



  export type CursoSelectScalar = {
    id?: boolean
    id_materia?: boolean
    id_docente?: boolean
    horario?: boolean
    aula?: boolean
    id_cuatrimestre?: boolean
  }

  export type CursoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_materia" | "id_docente" | "horario" | "aula" | "id_cuatrimestre", ExtArgs["result"]["curso"]>
  export type CursoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Materia?: boolean | MateriaDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Cuatrimestre?: boolean | CuatrimestreDefaultArgs<ExtArgs>
    DetalleFactura?: boolean | Curso$DetalleFacturaArgs<ExtArgs>
    OfertaAcademica?: boolean | Curso$OfertaAcademicaArgs<ExtArgs>
    HistoricoAcademico?: boolean | Curso$HistoricoAcademicoArgs<ExtArgs>
    CuMatricula?: boolean | Curso$CuMatriculaArgs<ExtArgs>
    _count?: boolean | CursoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CursoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Curso"
    objects: {
      Materia: Prisma.$MateriaPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
      Cuatrimestre: Prisma.$CuatrimestrePayload<ExtArgs>
      DetalleFactura: Prisma.$DetalleFacturaPayload<ExtArgs>[]
      OfertaAcademica: Prisma.$OfertaAcademicaPayload<ExtArgs>[]
      HistoricoAcademico: Prisma.$HistoricoAcademicoPayload<ExtArgs>[]
      CuMatricula: Prisma.$MatriculaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_materia: number
      id_docente: number
      horario: string
      aula: string
      id_cuatrimestre: number
    }, ExtArgs["result"]["curso"]>
    composites: {}
  }

  type CursoGetPayload<S extends boolean | null | undefined | CursoDefaultArgs> = $Result.GetResult<Prisma.$CursoPayload, S>

  type CursoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CursoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CursoCountAggregateInputType | true
    }

  export interface CursoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Curso'], meta: { name: 'Curso' } }
    /**
     * Find zero or one Curso that matches the filter.
     * @param {CursoFindUniqueArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CursoFindUniqueArgs>(args: SelectSubset<T, CursoFindUniqueArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Curso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CursoFindUniqueOrThrowArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CursoFindUniqueOrThrowArgs>(args: SelectSubset<T, CursoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Curso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindFirstArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CursoFindFirstArgs>(args?: SelectSubset<T, CursoFindFirstArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Curso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindFirstOrThrowArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CursoFindFirstOrThrowArgs>(args?: SelectSubset<T, CursoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Cursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cursos
     * const cursos = await prisma.curso.findMany()
     * 
     * // Get first 10 Cursos
     * const cursos = await prisma.curso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cursoWithIdOnly = await prisma.curso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CursoFindManyArgs>(args?: SelectSubset<T, CursoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Curso.
     * @param {CursoCreateArgs} args - Arguments to create a Curso.
     * @example
     * // Create one Curso
     * const Curso = await prisma.curso.create({
     *   data: {
     *     // ... data to create a Curso
     *   }
     * })
     * 
     */
    create<T extends CursoCreateArgs>(args: SelectSubset<T, CursoCreateArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Cursos.
     * @param {CursoCreateManyArgs} args - Arguments to create many Cursos.
     * @example
     * // Create many Cursos
     * const curso = await prisma.curso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CursoCreateManyArgs>(args?: SelectSubset<T, CursoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Curso.
     * @param {CursoDeleteArgs} args - Arguments to delete one Curso.
     * @example
     * // Delete one Curso
     * const Curso = await prisma.curso.delete({
     *   where: {
     *     // ... filter to delete one Curso
     *   }
     * })
     * 
     */
    delete<T extends CursoDeleteArgs>(args: SelectSubset<T, CursoDeleteArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Curso.
     * @param {CursoUpdateArgs} args - Arguments to update one Curso.
     * @example
     * // Update one Curso
     * const curso = await prisma.curso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CursoUpdateArgs>(args: SelectSubset<T, CursoUpdateArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Cursos.
     * @param {CursoDeleteManyArgs} args - Arguments to filter Cursos to delete.
     * @example
     * // Delete a few Cursos
     * const { count } = await prisma.curso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CursoDeleteManyArgs>(args?: SelectSubset<T, CursoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cursos
     * const curso = await prisma.curso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CursoUpdateManyArgs>(args: SelectSubset<T, CursoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Curso.
     * @param {CursoUpsertArgs} args - Arguments to update or create a Curso.
     * @example
     * // Update or create a Curso
     * const curso = await prisma.curso.upsert({
     *   create: {
     *     // ... data to create a Curso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Curso we want to update
     *   }
     * })
     */
    upsert<T extends CursoUpsertArgs>(args: SelectSubset<T, CursoUpsertArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCountArgs} args - Arguments to filter Cursos to count.
     * @example
     * // Count the number of Cursos
     * const count = await prisma.curso.count({
     *   where: {
     *     // ... the filter for the Cursos we want to count
     *   }
     * })
    **/
    count<T extends CursoCountArgs>(
      args?: Subset<T, CursoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Curso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CursoAggregateArgs>(args: Subset<T, CursoAggregateArgs>): Prisma.PrismaPromise<GetCursoAggregateType<T>>

    /**
     * Group by Curso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CursoGroupByArgs['orderBy'] }
        : { orderBy?: CursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCursoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Curso model
   */
  readonly fields: CursoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Curso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CursoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Materia<T extends MateriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MateriaDefaultArgs<ExtArgs>>): Prisma__MateriaClient<$Result.GetResult<Prisma.$MateriaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Cuatrimestre<T extends CuatrimestreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CuatrimestreDefaultArgs<ExtArgs>>): Prisma__CuatrimestreClient<$Result.GetResult<Prisma.$CuatrimestrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    DetalleFactura<T extends Curso$DetalleFacturaArgs<ExtArgs> = {}>(args?: Subset<T, Curso$DetalleFacturaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleFacturaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    OfertaAcademica<T extends Curso$OfertaAcademicaArgs<ExtArgs> = {}>(args?: Subset<T, Curso$OfertaAcademicaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfertaAcademicaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    HistoricoAcademico<T extends Curso$HistoricoAcademicoArgs<ExtArgs> = {}>(args?: Subset<T, Curso$HistoricoAcademicoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoricoAcademicoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    CuMatricula<T extends Curso$CuMatriculaArgs<ExtArgs> = {}>(args?: Subset<T, Curso$CuMatriculaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Curso model
   */ 
  interface CursoFieldRefs {
    readonly id: FieldRef<"Curso", 'Int'>
    readonly id_materia: FieldRef<"Curso", 'Int'>
    readonly id_docente: FieldRef<"Curso", 'Int'>
    readonly horario: FieldRef<"Curso", 'String'>
    readonly aula: FieldRef<"Curso", 'String'>
    readonly id_cuatrimestre: FieldRef<"Curso", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Curso findUnique
   */
  export type CursoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso findUniqueOrThrow
   */
  export type CursoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso findFirst
   */
  export type CursoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cursos.
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cursos.
     */
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Curso findFirstOrThrow
   */
  export type CursoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cursos.
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cursos.
     */
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Curso findMany
   */
  export type CursoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Cursos to fetch.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cursos.
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Curso create
   */
  export type CursoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * The data needed to create a Curso.
     */
    data: XOR<CursoCreateInput, CursoUncheckedCreateInput>
  }

  /**
   * Curso createMany
   */
  export type CursoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cursos.
     */
    data: CursoCreateManyInput | CursoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Curso update
   */
  export type CursoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * The data needed to update a Curso.
     */
    data: XOR<CursoUpdateInput, CursoUncheckedUpdateInput>
    /**
     * Choose, which Curso to update.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso updateMany
   */
  export type CursoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cursos.
     */
    data: XOR<CursoUpdateManyMutationInput, CursoUncheckedUpdateManyInput>
    /**
     * Filter which Cursos to update
     */
    where?: CursoWhereInput
    /**
     * Limit how many Cursos to update.
     */
    limit?: number
  }

  /**
   * Curso upsert
   */
  export type CursoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * The filter to search for the Curso to update in case it exists.
     */
    where: CursoWhereUniqueInput
    /**
     * In case the Curso found by the `where` argument doesn't exist, create a new Curso with this data.
     */
    create: XOR<CursoCreateInput, CursoUncheckedCreateInput>
    /**
     * In case the Curso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CursoUpdateInput, CursoUncheckedUpdateInput>
  }

  /**
   * Curso delete
   */
  export type CursoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter which Curso to delete.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso deleteMany
   */
  export type CursoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cursos to delete
     */
    where?: CursoWhereInput
    /**
     * Limit how many Cursos to delete.
     */
    limit?: number
  }

  /**
   * Curso.DetalleFactura
   */
  export type Curso$DetalleFacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleFactura
     */
    select?: DetalleFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleFactura
     */
    omit?: DetalleFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleFacturaInclude<ExtArgs> | null
    where?: DetalleFacturaWhereInput
    orderBy?: DetalleFacturaOrderByWithRelationInput | DetalleFacturaOrderByWithRelationInput[]
    cursor?: DetalleFacturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetalleFacturaScalarFieldEnum | DetalleFacturaScalarFieldEnum[]
  }

  /**
   * Curso.OfertaAcademica
   */
  export type Curso$OfertaAcademicaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
    where?: OfertaAcademicaWhereInput
    orderBy?: OfertaAcademicaOrderByWithRelationInput | OfertaAcademicaOrderByWithRelationInput[]
    cursor?: OfertaAcademicaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfertaAcademicaScalarFieldEnum | OfertaAcademicaScalarFieldEnum[]
  }

  /**
   * Curso.HistoricoAcademico
   */
  export type Curso$HistoricoAcademicoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoAcademico
     */
    select?: HistoricoAcademicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoAcademico
     */
    omit?: HistoricoAcademicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoricoAcademicoInclude<ExtArgs> | null
    where?: HistoricoAcademicoWhereInput
    orderBy?: HistoricoAcademicoOrderByWithRelationInput | HistoricoAcademicoOrderByWithRelationInput[]
    cursor?: HistoricoAcademicoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoricoAcademicoScalarFieldEnum | HistoricoAcademicoScalarFieldEnum[]
  }

  /**
   * Curso.CuMatricula
   */
  export type Curso$CuMatriculaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Matricula
     */
    omit?: MatriculaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    where?: MatriculaWhereInput
    orderBy?: MatriculaOrderByWithRelationInput | MatriculaOrderByWithRelationInput[]
    cursor?: MatriculaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatriculaScalarFieldEnum | MatriculaScalarFieldEnum[]
  }

  /**
   * Curso without action
   */
  export type CursoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curso
     */
    omit?: CursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
  }


  /**
   * Model Matricula
   */

  export type AggregateMatricula = {
    _count: MatriculaCountAggregateOutputType | null
    _avg: MatriculaAvgAggregateOutputType | null
    _sum: MatriculaSumAggregateOutputType | null
    _min: MatriculaMinAggregateOutputType | null
    _max: MatriculaMaxAggregateOutputType | null
  }

  export type MatriculaAvgAggregateOutputType = {
    id: number | null
    id_usuario: number | null
    id_curso: number | null
  }

  export type MatriculaSumAggregateOutputType = {
    id: number | null
    id_usuario: number | null
    id_curso: number | null
  }

  export type MatriculaMinAggregateOutputType = {
    id: number | null
    id_usuario: number | null
    id_curso: number | null
    fecha: Date | null
    estado: string | null
  }

  export type MatriculaMaxAggregateOutputType = {
    id: number | null
    id_usuario: number | null
    id_curso: number | null
    fecha: Date | null
    estado: string | null
  }

  export type MatriculaCountAggregateOutputType = {
    id: number
    id_usuario: number
    id_curso: number
    fecha: number
    estado: number
    _all: number
  }


  export type MatriculaAvgAggregateInputType = {
    id?: true
    id_usuario?: true
    id_curso?: true
  }

  export type MatriculaSumAggregateInputType = {
    id?: true
    id_usuario?: true
    id_curso?: true
  }

  export type MatriculaMinAggregateInputType = {
    id?: true
    id_usuario?: true
    id_curso?: true
    fecha?: true
    estado?: true
  }

  export type MatriculaMaxAggregateInputType = {
    id?: true
    id_usuario?: true
    id_curso?: true
    fecha?: true
    estado?: true
  }

  export type MatriculaCountAggregateInputType = {
    id?: true
    id_usuario?: true
    id_curso?: true
    fecha?: true
    estado?: true
    _all?: true
  }

  export type MatriculaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matricula to aggregate.
     */
    where?: MatriculaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matriculas to fetch.
     */
    orderBy?: MatriculaOrderByWithRelationInput | MatriculaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatriculaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matriculas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matriculas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matriculas
    **/
    _count?: true | MatriculaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatriculaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatriculaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatriculaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatriculaMaxAggregateInputType
  }

  export type GetMatriculaAggregateType<T extends MatriculaAggregateArgs> = {
        [P in keyof T & keyof AggregateMatricula]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatricula[P]>
      : GetScalarType<T[P], AggregateMatricula[P]>
  }




  export type MatriculaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatriculaWhereInput
    orderBy?: MatriculaOrderByWithAggregationInput | MatriculaOrderByWithAggregationInput[]
    by: MatriculaScalarFieldEnum[] | MatriculaScalarFieldEnum
    having?: MatriculaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatriculaCountAggregateInputType | true
    _avg?: MatriculaAvgAggregateInputType
    _sum?: MatriculaSumAggregateInputType
    _min?: MatriculaMinAggregateInputType
    _max?: MatriculaMaxAggregateInputType
  }

  export type MatriculaGroupByOutputType = {
    id: number
    id_usuario: number
    id_curso: number
    fecha: Date
    estado: string
    _count: MatriculaCountAggregateOutputType | null
    _avg: MatriculaAvgAggregateOutputType | null
    _sum: MatriculaSumAggregateOutputType | null
    _min: MatriculaMinAggregateOutputType | null
    _max: MatriculaMaxAggregateOutputType | null
  }

  type GetMatriculaGroupByPayload<T extends MatriculaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatriculaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatriculaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatriculaGroupByOutputType[P]>
            : GetScalarType<T[P], MatriculaGroupByOutputType[P]>
        }
      >
    >


  export type MatriculaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_usuario?: boolean
    id_curso?: boolean
    fecha?: boolean
    estado?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Curso?: boolean | CursoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matricula"]>



  export type MatriculaSelectScalar = {
    id?: boolean
    id_usuario?: boolean
    id_curso?: boolean
    fecha?: boolean
    estado?: boolean
  }

  export type MatriculaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_usuario" | "id_curso" | "fecha" | "estado", ExtArgs["result"]["matricula"]>
  export type MatriculaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Curso?: boolean | CursoDefaultArgs<ExtArgs>
  }

  export type $MatriculaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Matricula"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
      Curso: Prisma.$CursoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_usuario: number
      id_curso: number
      fecha: Date
      estado: string
    }, ExtArgs["result"]["matricula"]>
    composites: {}
  }

  type MatriculaGetPayload<S extends boolean | null | undefined | MatriculaDefaultArgs> = $Result.GetResult<Prisma.$MatriculaPayload, S>

  type MatriculaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatriculaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatriculaCountAggregateInputType | true
    }

  export interface MatriculaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Matricula'], meta: { name: 'Matricula' } }
    /**
     * Find zero or one Matricula that matches the filter.
     * @param {MatriculaFindUniqueArgs} args - Arguments to find a Matricula
     * @example
     * // Get one Matricula
     * const matricula = await prisma.matricula.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatriculaFindUniqueArgs>(args: SelectSubset<T, MatriculaFindUniqueArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Matricula that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatriculaFindUniqueOrThrowArgs} args - Arguments to find a Matricula
     * @example
     * // Get one Matricula
     * const matricula = await prisma.matricula.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatriculaFindUniqueOrThrowArgs>(args: SelectSubset<T, MatriculaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Matricula that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaFindFirstArgs} args - Arguments to find a Matricula
     * @example
     * // Get one Matricula
     * const matricula = await prisma.matricula.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatriculaFindFirstArgs>(args?: SelectSubset<T, MatriculaFindFirstArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Matricula that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaFindFirstOrThrowArgs} args - Arguments to find a Matricula
     * @example
     * // Get one Matricula
     * const matricula = await prisma.matricula.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatriculaFindFirstOrThrowArgs>(args?: SelectSubset<T, MatriculaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Matriculas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matriculas
     * const matriculas = await prisma.matricula.findMany()
     * 
     * // Get first 10 Matriculas
     * const matriculas = await prisma.matricula.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matriculaWithIdOnly = await prisma.matricula.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatriculaFindManyArgs>(args?: SelectSubset<T, MatriculaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Matricula.
     * @param {MatriculaCreateArgs} args - Arguments to create a Matricula.
     * @example
     * // Create one Matricula
     * const Matricula = await prisma.matricula.create({
     *   data: {
     *     // ... data to create a Matricula
     *   }
     * })
     * 
     */
    create<T extends MatriculaCreateArgs>(args: SelectSubset<T, MatriculaCreateArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Matriculas.
     * @param {MatriculaCreateManyArgs} args - Arguments to create many Matriculas.
     * @example
     * // Create many Matriculas
     * const matricula = await prisma.matricula.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatriculaCreateManyArgs>(args?: SelectSubset<T, MatriculaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Matricula.
     * @param {MatriculaDeleteArgs} args - Arguments to delete one Matricula.
     * @example
     * // Delete one Matricula
     * const Matricula = await prisma.matricula.delete({
     *   where: {
     *     // ... filter to delete one Matricula
     *   }
     * })
     * 
     */
    delete<T extends MatriculaDeleteArgs>(args: SelectSubset<T, MatriculaDeleteArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Matricula.
     * @param {MatriculaUpdateArgs} args - Arguments to update one Matricula.
     * @example
     * // Update one Matricula
     * const matricula = await prisma.matricula.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatriculaUpdateArgs>(args: SelectSubset<T, MatriculaUpdateArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Matriculas.
     * @param {MatriculaDeleteManyArgs} args - Arguments to filter Matriculas to delete.
     * @example
     * // Delete a few Matriculas
     * const { count } = await prisma.matricula.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatriculaDeleteManyArgs>(args?: SelectSubset<T, MatriculaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matriculas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matriculas
     * const matricula = await prisma.matricula.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatriculaUpdateManyArgs>(args: SelectSubset<T, MatriculaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Matricula.
     * @param {MatriculaUpsertArgs} args - Arguments to update or create a Matricula.
     * @example
     * // Update or create a Matricula
     * const matricula = await prisma.matricula.upsert({
     *   create: {
     *     // ... data to create a Matricula
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Matricula we want to update
     *   }
     * })
     */
    upsert<T extends MatriculaUpsertArgs>(args: SelectSubset<T, MatriculaUpsertArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Matriculas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaCountArgs} args - Arguments to filter Matriculas to count.
     * @example
     * // Count the number of Matriculas
     * const count = await prisma.matricula.count({
     *   where: {
     *     // ... the filter for the Matriculas we want to count
     *   }
     * })
    **/
    count<T extends MatriculaCountArgs>(
      args?: Subset<T, MatriculaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatriculaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Matricula.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatriculaAggregateArgs>(args: Subset<T, MatriculaAggregateArgs>): Prisma.PrismaPromise<GetMatriculaAggregateType<T>>

    /**
     * Group by Matricula.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatriculaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatriculaGroupByArgs['orderBy'] }
        : { orderBy?: MatriculaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatriculaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatriculaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Matricula model
   */
  readonly fields: MatriculaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Matricula.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatriculaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Curso<T extends CursoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CursoDefaultArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Matricula model
   */ 
  interface MatriculaFieldRefs {
    readonly id: FieldRef<"Matricula", 'Int'>
    readonly id_usuario: FieldRef<"Matricula", 'Int'>
    readonly id_curso: FieldRef<"Matricula", 'Int'>
    readonly fecha: FieldRef<"Matricula", 'DateTime'>
    readonly estado: FieldRef<"Matricula", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Matricula findUnique
   */
  export type MatriculaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Matricula
     */
    omit?: MatriculaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * Filter, which Matricula to fetch.
     */
    where: MatriculaWhereUniqueInput
  }

  /**
   * Matricula findUniqueOrThrow
   */
  export type MatriculaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Matricula
     */
    omit?: MatriculaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * Filter, which Matricula to fetch.
     */
    where: MatriculaWhereUniqueInput
  }

  /**
   * Matricula findFirst
   */
  export type MatriculaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Matricula
     */
    omit?: MatriculaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * Filter, which Matricula to fetch.
     */
    where?: MatriculaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matriculas to fetch.
     */
    orderBy?: MatriculaOrderByWithRelationInput | MatriculaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matriculas.
     */
    cursor?: MatriculaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matriculas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matriculas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matriculas.
     */
    distinct?: MatriculaScalarFieldEnum | MatriculaScalarFieldEnum[]
  }

  /**
   * Matricula findFirstOrThrow
   */
  export type MatriculaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Matricula
     */
    omit?: MatriculaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * Filter, which Matricula to fetch.
     */
    where?: MatriculaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matriculas to fetch.
     */
    orderBy?: MatriculaOrderByWithRelationInput | MatriculaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matriculas.
     */
    cursor?: MatriculaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matriculas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matriculas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matriculas.
     */
    distinct?: MatriculaScalarFieldEnum | MatriculaScalarFieldEnum[]
  }

  /**
   * Matricula findMany
   */
  export type MatriculaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Matricula
     */
    omit?: MatriculaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * Filter, which Matriculas to fetch.
     */
    where?: MatriculaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matriculas to fetch.
     */
    orderBy?: MatriculaOrderByWithRelationInput | MatriculaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matriculas.
     */
    cursor?: MatriculaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matriculas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matriculas.
     */
    skip?: number
    distinct?: MatriculaScalarFieldEnum | MatriculaScalarFieldEnum[]
  }

  /**
   * Matricula create
   */
  export type MatriculaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Matricula
     */
    omit?: MatriculaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * The data needed to create a Matricula.
     */
    data: XOR<MatriculaCreateInput, MatriculaUncheckedCreateInput>
  }

  /**
   * Matricula createMany
   */
  export type MatriculaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matriculas.
     */
    data: MatriculaCreateManyInput | MatriculaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Matricula update
   */
  export type MatriculaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Matricula
     */
    omit?: MatriculaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * The data needed to update a Matricula.
     */
    data: XOR<MatriculaUpdateInput, MatriculaUncheckedUpdateInput>
    /**
     * Choose, which Matricula to update.
     */
    where: MatriculaWhereUniqueInput
  }

  /**
   * Matricula updateMany
   */
  export type MatriculaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matriculas.
     */
    data: XOR<MatriculaUpdateManyMutationInput, MatriculaUncheckedUpdateManyInput>
    /**
     * Filter which Matriculas to update
     */
    where?: MatriculaWhereInput
    /**
     * Limit how many Matriculas to update.
     */
    limit?: number
  }

  /**
   * Matricula upsert
   */
  export type MatriculaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Matricula
     */
    omit?: MatriculaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * The filter to search for the Matricula to update in case it exists.
     */
    where: MatriculaWhereUniqueInput
    /**
     * In case the Matricula found by the `where` argument doesn't exist, create a new Matricula with this data.
     */
    create: XOR<MatriculaCreateInput, MatriculaUncheckedCreateInput>
    /**
     * In case the Matricula was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatriculaUpdateInput, MatriculaUncheckedUpdateInput>
  }

  /**
   * Matricula delete
   */
  export type MatriculaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Matricula
     */
    omit?: MatriculaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * Filter which Matricula to delete.
     */
    where: MatriculaWhereUniqueInput
  }

  /**
   * Matricula deleteMany
   */
  export type MatriculaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matriculas to delete
     */
    where?: MatriculaWhereInput
    /**
     * Limit how many Matriculas to delete.
     */
    limit?: number
  }

  /**
   * Matricula without action
   */
  export type MatriculaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Matricula
     */
    omit?: MatriculaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
  }


  /**
   * Model OfertaAcademica
   */

  export type AggregateOfertaAcademica = {
    _count: OfertaAcademicaCountAggregateOutputType | null
    _avg: OfertaAcademicaAvgAggregateOutputType | null
    _sum: OfertaAcademicaSumAggregateOutputType | null
    _min: OfertaAcademicaMinAggregateOutputType | null
    _max: OfertaAcademicaMaxAggregateOutputType | null
  }

  export type OfertaAcademicaAvgAggregateOutputType = {
    id: number | null
    id_curso: number | null
    id_carrera: number | null
    id_cuatrimestre: number | null
  }

  export type OfertaAcademicaSumAggregateOutputType = {
    id: number | null
    id_curso: number | null
    id_carrera: number | null
    id_cuatrimestre: number | null
  }

  export type OfertaAcademicaMinAggregateOutputType = {
    id: number | null
    id_curso: number | null
    id_carrera: number | null
    id_cuatrimestre: number | null
    anno: string | null
  }

  export type OfertaAcademicaMaxAggregateOutputType = {
    id: number | null
    id_curso: number | null
    id_carrera: number | null
    id_cuatrimestre: number | null
    anno: string | null
  }

  export type OfertaAcademicaCountAggregateOutputType = {
    id: number
    id_curso: number
    id_carrera: number
    id_cuatrimestre: number
    anno: number
    _all: number
  }


  export type OfertaAcademicaAvgAggregateInputType = {
    id?: true
    id_curso?: true
    id_carrera?: true
    id_cuatrimestre?: true
  }

  export type OfertaAcademicaSumAggregateInputType = {
    id?: true
    id_curso?: true
    id_carrera?: true
    id_cuatrimestre?: true
  }

  export type OfertaAcademicaMinAggregateInputType = {
    id?: true
    id_curso?: true
    id_carrera?: true
    id_cuatrimestre?: true
    anno?: true
  }

  export type OfertaAcademicaMaxAggregateInputType = {
    id?: true
    id_curso?: true
    id_carrera?: true
    id_cuatrimestre?: true
    anno?: true
  }

  export type OfertaAcademicaCountAggregateInputType = {
    id?: true
    id_curso?: true
    id_carrera?: true
    id_cuatrimestre?: true
    anno?: true
    _all?: true
  }

  export type OfertaAcademicaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfertaAcademica to aggregate.
     */
    where?: OfertaAcademicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfertaAcademicas to fetch.
     */
    orderBy?: OfertaAcademicaOrderByWithRelationInput | OfertaAcademicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfertaAcademicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfertaAcademicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfertaAcademicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfertaAcademicas
    **/
    _count?: true | OfertaAcademicaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfertaAcademicaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfertaAcademicaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfertaAcademicaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfertaAcademicaMaxAggregateInputType
  }

  export type GetOfertaAcademicaAggregateType<T extends OfertaAcademicaAggregateArgs> = {
        [P in keyof T & keyof AggregateOfertaAcademica]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfertaAcademica[P]>
      : GetScalarType<T[P], AggregateOfertaAcademica[P]>
  }




  export type OfertaAcademicaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfertaAcademicaWhereInput
    orderBy?: OfertaAcademicaOrderByWithAggregationInput | OfertaAcademicaOrderByWithAggregationInput[]
    by: OfertaAcademicaScalarFieldEnum[] | OfertaAcademicaScalarFieldEnum
    having?: OfertaAcademicaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfertaAcademicaCountAggregateInputType | true
    _avg?: OfertaAcademicaAvgAggregateInputType
    _sum?: OfertaAcademicaSumAggregateInputType
    _min?: OfertaAcademicaMinAggregateInputType
    _max?: OfertaAcademicaMaxAggregateInputType
  }

  export type OfertaAcademicaGroupByOutputType = {
    id: number
    id_curso: number
    id_carrera: number
    id_cuatrimestre: number
    anno: string
    _count: OfertaAcademicaCountAggregateOutputType | null
    _avg: OfertaAcademicaAvgAggregateOutputType | null
    _sum: OfertaAcademicaSumAggregateOutputType | null
    _min: OfertaAcademicaMinAggregateOutputType | null
    _max: OfertaAcademicaMaxAggregateOutputType | null
  }

  type GetOfertaAcademicaGroupByPayload<T extends OfertaAcademicaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfertaAcademicaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfertaAcademicaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfertaAcademicaGroupByOutputType[P]>
            : GetScalarType<T[P], OfertaAcademicaGroupByOutputType[P]>
        }
      >
    >


  export type OfertaAcademicaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_curso?: boolean
    id_carrera?: boolean
    id_cuatrimestre?: boolean
    anno?: boolean
    Curso?: boolean | CursoDefaultArgs<ExtArgs>
    Cuatrimestre?: boolean | CuatrimestreDefaultArgs<ExtArgs>
    Carrera?: boolean | CarreraDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ofertaAcademica"]>



  export type OfertaAcademicaSelectScalar = {
    id?: boolean
    id_curso?: boolean
    id_carrera?: boolean
    id_cuatrimestre?: boolean
    anno?: boolean
  }

  export type OfertaAcademicaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_curso" | "id_carrera" | "id_cuatrimestre" | "anno", ExtArgs["result"]["ofertaAcademica"]>
  export type OfertaAcademicaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Curso?: boolean | CursoDefaultArgs<ExtArgs>
    Cuatrimestre?: boolean | CuatrimestreDefaultArgs<ExtArgs>
    Carrera?: boolean | CarreraDefaultArgs<ExtArgs>
  }

  export type $OfertaAcademicaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OfertaAcademica"
    objects: {
      Curso: Prisma.$CursoPayload<ExtArgs>
      Cuatrimestre: Prisma.$CuatrimestrePayload<ExtArgs>
      Carrera: Prisma.$CarreraPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_curso: number
      id_carrera: number
      id_cuatrimestre: number
      anno: string
    }, ExtArgs["result"]["ofertaAcademica"]>
    composites: {}
  }

  type OfertaAcademicaGetPayload<S extends boolean | null | undefined | OfertaAcademicaDefaultArgs> = $Result.GetResult<Prisma.$OfertaAcademicaPayload, S>

  type OfertaAcademicaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfertaAcademicaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfertaAcademicaCountAggregateInputType | true
    }

  export interface OfertaAcademicaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfertaAcademica'], meta: { name: 'OfertaAcademica' } }
    /**
     * Find zero or one OfertaAcademica that matches the filter.
     * @param {OfertaAcademicaFindUniqueArgs} args - Arguments to find a OfertaAcademica
     * @example
     * // Get one OfertaAcademica
     * const ofertaAcademica = await prisma.ofertaAcademica.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfertaAcademicaFindUniqueArgs>(args: SelectSubset<T, OfertaAcademicaFindUniqueArgs<ExtArgs>>): Prisma__OfertaAcademicaClient<$Result.GetResult<Prisma.$OfertaAcademicaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OfertaAcademica that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfertaAcademicaFindUniqueOrThrowArgs} args - Arguments to find a OfertaAcademica
     * @example
     * // Get one OfertaAcademica
     * const ofertaAcademica = await prisma.ofertaAcademica.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfertaAcademicaFindUniqueOrThrowArgs>(args: SelectSubset<T, OfertaAcademicaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfertaAcademicaClient<$Result.GetResult<Prisma.$OfertaAcademicaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OfertaAcademica that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfertaAcademicaFindFirstArgs} args - Arguments to find a OfertaAcademica
     * @example
     * // Get one OfertaAcademica
     * const ofertaAcademica = await prisma.ofertaAcademica.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfertaAcademicaFindFirstArgs>(args?: SelectSubset<T, OfertaAcademicaFindFirstArgs<ExtArgs>>): Prisma__OfertaAcademicaClient<$Result.GetResult<Prisma.$OfertaAcademicaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OfertaAcademica that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfertaAcademicaFindFirstOrThrowArgs} args - Arguments to find a OfertaAcademica
     * @example
     * // Get one OfertaAcademica
     * const ofertaAcademica = await prisma.ofertaAcademica.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfertaAcademicaFindFirstOrThrowArgs>(args?: SelectSubset<T, OfertaAcademicaFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfertaAcademicaClient<$Result.GetResult<Prisma.$OfertaAcademicaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OfertaAcademicas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfertaAcademicaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfertaAcademicas
     * const ofertaAcademicas = await prisma.ofertaAcademica.findMany()
     * 
     * // Get first 10 OfertaAcademicas
     * const ofertaAcademicas = await prisma.ofertaAcademica.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ofertaAcademicaWithIdOnly = await prisma.ofertaAcademica.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfertaAcademicaFindManyArgs>(args?: SelectSubset<T, OfertaAcademicaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfertaAcademicaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OfertaAcademica.
     * @param {OfertaAcademicaCreateArgs} args - Arguments to create a OfertaAcademica.
     * @example
     * // Create one OfertaAcademica
     * const OfertaAcademica = await prisma.ofertaAcademica.create({
     *   data: {
     *     // ... data to create a OfertaAcademica
     *   }
     * })
     * 
     */
    create<T extends OfertaAcademicaCreateArgs>(args: SelectSubset<T, OfertaAcademicaCreateArgs<ExtArgs>>): Prisma__OfertaAcademicaClient<$Result.GetResult<Prisma.$OfertaAcademicaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OfertaAcademicas.
     * @param {OfertaAcademicaCreateManyArgs} args - Arguments to create many OfertaAcademicas.
     * @example
     * // Create many OfertaAcademicas
     * const ofertaAcademica = await prisma.ofertaAcademica.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfertaAcademicaCreateManyArgs>(args?: SelectSubset<T, OfertaAcademicaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfertaAcademica.
     * @param {OfertaAcademicaDeleteArgs} args - Arguments to delete one OfertaAcademica.
     * @example
     * // Delete one OfertaAcademica
     * const OfertaAcademica = await prisma.ofertaAcademica.delete({
     *   where: {
     *     // ... filter to delete one OfertaAcademica
     *   }
     * })
     * 
     */
    delete<T extends OfertaAcademicaDeleteArgs>(args: SelectSubset<T, OfertaAcademicaDeleteArgs<ExtArgs>>): Prisma__OfertaAcademicaClient<$Result.GetResult<Prisma.$OfertaAcademicaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OfertaAcademica.
     * @param {OfertaAcademicaUpdateArgs} args - Arguments to update one OfertaAcademica.
     * @example
     * // Update one OfertaAcademica
     * const ofertaAcademica = await prisma.ofertaAcademica.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfertaAcademicaUpdateArgs>(args: SelectSubset<T, OfertaAcademicaUpdateArgs<ExtArgs>>): Prisma__OfertaAcademicaClient<$Result.GetResult<Prisma.$OfertaAcademicaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OfertaAcademicas.
     * @param {OfertaAcademicaDeleteManyArgs} args - Arguments to filter OfertaAcademicas to delete.
     * @example
     * // Delete a few OfertaAcademicas
     * const { count } = await prisma.ofertaAcademica.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfertaAcademicaDeleteManyArgs>(args?: SelectSubset<T, OfertaAcademicaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfertaAcademicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfertaAcademicaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfertaAcademicas
     * const ofertaAcademica = await prisma.ofertaAcademica.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfertaAcademicaUpdateManyArgs>(args: SelectSubset<T, OfertaAcademicaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfertaAcademica.
     * @param {OfertaAcademicaUpsertArgs} args - Arguments to update or create a OfertaAcademica.
     * @example
     * // Update or create a OfertaAcademica
     * const ofertaAcademica = await prisma.ofertaAcademica.upsert({
     *   create: {
     *     // ... data to create a OfertaAcademica
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfertaAcademica we want to update
     *   }
     * })
     */
    upsert<T extends OfertaAcademicaUpsertArgs>(args: SelectSubset<T, OfertaAcademicaUpsertArgs<ExtArgs>>): Prisma__OfertaAcademicaClient<$Result.GetResult<Prisma.$OfertaAcademicaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OfertaAcademicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfertaAcademicaCountArgs} args - Arguments to filter OfertaAcademicas to count.
     * @example
     * // Count the number of OfertaAcademicas
     * const count = await prisma.ofertaAcademica.count({
     *   where: {
     *     // ... the filter for the OfertaAcademicas we want to count
     *   }
     * })
    **/
    count<T extends OfertaAcademicaCountArgs>(
      args?: Subset<T, OfertaAcademicaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfertaAcademicaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfertaAcademica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfertaAcademicaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfertaAcademicaAggregateArgs>(args: Subset<T, OfertaAcademicaAggregateArgs>): Prisma.PrismaPromise<GetOfertaAcademicaAggregateType<T>>

    /**
     * Group by OfertaAcademica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfertaAcademicaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfertaAcademicaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfertaAcademicaGroupByArgs['orderBy'] }
        : { orderBy?: OfertaAcademicaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfertaAcademicaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfertaAcademicaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfertaAcademica model
   */
  readonly fields: OfertaAcademicaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfertaAcademica.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfertaAcademicaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Curso<T extends CursoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CursoDefaultArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Cuatrimestre<T extends CuatrimestreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CuatrimestreDefaultArgs<ExtArgs>>): Prisma__CuatrimestreClient<$Result.GetResult<Prisma.$CuatrimestrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Carrera<T extends CarreraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CarreraDefaultArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OfertaAcademica model
   */ 
  interface OfertaAcademicaFieldRefs {
    readonly id: FieldRef<"OfertaAcademica", 'Int'>
    readonly id_curso: FieldRef<"OfertaAcademica", 'Int'>
    readonly id_carrera: FieldRef<"OfertaAcademica", 'Int'>
    readonly id_cuatrimestre: FieldRef<"OfertaAcademica", 'Int'>
    readonly anno: FieldRef<"OfertaAcademica", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OfertaAcademica findUnique
   */
  export type OfertaAcademicaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
    /**
     * Filter, which OfertaAcademica to fetch.
     */
    where: OfertaAcademicaWhereUniqueInput
  }

  /**
   * OfertaAcademica findUniqueOrThrow
   */
  export type OfertaAcademicaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
    /**
     * Filter, which OfertaAcademica to fetch.
     */
    where: OfertaAcademicaWhereUniqueInput
  }

  /**
   * OfertaAcademica findFirst
   */
  export type OfertaAcademicaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
    /**
     * Filter, which OfertaAcademica to fetch.
     */
    where?: OfertaAcademicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfertaAcademicas to fetch.
     */
    orderBy?: OfertaAcademicaOrderByWithRelationInput | OfertaAcademicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfertaAcademicas.
     */
    cursor?: OfertaAcademicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfertaAcademicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfertaAcademicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfertaAcademicas.
     */
    distinct?: OfertaAcademicaScalarFieldEnum | OfertaAcademicaScalarFieldEnum[]
  }

  /**
   * OfertaAcademica findFirstOrThrow
   */
  export type OfertaAcademicaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
    /**
     * Filter, which OfertaAcademica to fetch.
     */
    where?: OfertaAcademicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfertaAcademicas to fetch.
     */
    orderBy?: OfertaAcademicaOrderByWithRelationInput | OfertaAcademicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfertaAcademicas.
     */
    cursor?: OfertaAcademicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfertaAcademicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfertaAcademicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfertaAcademicas.
     */
    distinct?: OfertaAcademicaScalarFieldEnum | OfertaAcademicaScalarFieldEnum[]
  }

  /**
   * OfertaAcademica findMany
   */
  export type OfertaAcademicaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
    /**
     * Filter, which OfertaAcademicas to fetch.
     */
    where?: OfertaAcademicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfertaAcademicas to fetch.
     */
    orderBy?: OfertaAcademicaOrderByWithRelationInput | OfertaAcademicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfertaAcademicas.
     */
    cursor?: OfertaAcademicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfertaAcademicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfertaAcademicas.
     */
    skip?: number
    distinct?: OfertaAcademicaScalarFieldEnum | OfertaAcademicaScalarFieldEnum[]
  }

  /**
   * OfertaAcademica create
   */
  export type OfertaAcademicaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
    /**
     * The data needed to create a OfertaAcademica.
     */
    data: XOR<OfertaAcademicaCreateInput, OfertaAcademicaUncheckedCreateInput>
  }

  /**
   * OfertaAcademica createMany
   */
  export type OfertaAcademicaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfertaAcademicas.
     */
    data: OfertaAcademicaCreateManyInput | OfertaAcademicaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OfertaAcademica update
   */
  export type OfertaAcademicaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
    /**
     * The data needed to update a OfertaAcademica.
     */
    data: XOR<OfertaAcademicaUpdateInput, OfertaAcademicaUncheckedUpdateInput>
    /**
     * Choose, which OfertaAcademica to update.
     */
    where: OfertaAcademicaWhereUniqueInput
  }

  /**
   * OfertaAcademica updateMany
   */
  export type OfertaAcademicaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfertaAcademicas.
     */
    data: XOR<OfertaAcademicaUpdateManyMutationInput, OfertaAcademicaUncheckedUpdateManyInput>
    /**
     * Filter which OfertaAcademicas to update
     */
    where?: OfertaAcademicaWhereInput
    /**
     * Limit how many OfertaAcademicas to update.
     */
    limit?: number
  }

  /**
   * OfertaAcademica upsert
   */
  export type OfertaAcademicaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
    /**
     * The filter to search for the OfertaAcademica to update in case it exists.
     */
    where: OfertaAcademicaWhereUniqueInput
    /**
     * In case the OfertaAcademica found by the `where` argument doesn't exist, create a new OfertaAcademica with this data.
     */
    create: XOR<OfertaAcademicaCreateInput, OfertaAcademicaUncheckedCreateInput>
    /**
     * In case the OfertaAcademica was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfertaAcademicaUpdateInput, OfertaAcademicaUncheckedUpdateInput>
  }

  /**
   * OfertaAcademica delete
   */
  export type OfertaAcademicaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
    /**
     * Filter which OfertaAcademica to delete.
     */
    where: OfertaAcademicaWhereUniqueInput
  }

  /**
   * OfertaAcademica deleteMany
   */
  export type OfertaAcademicaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfertaAcademicas to delete
     */
    where?: OfertaAcademicaWhereInput
    /**
     * Limit how many OfertaAcademicas to delete.
     */
    limit?: number
  }

  /**
   * OfertaAcademica without action
   */
  export type OfertaAcademicaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfertaAcademica
     */
    select?: OfertaAcademicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OfertaAcademica
     */
    omit?: OfertaAcademicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfertaAcademicaInclude<ExtArgs> | null
  }


  /**
   * Model HistoricoAcademico
   */

  export type AggregateHistoricoAcademico = {
    _count: HistoricoAcademicoCountAggregateOutputType | null
    _avg: HistoricoAcademicoAvgAggregateOutputType | null
    _sum: HistoricoAcademicoSumAggregateOutputType | null
    _min: HistoricoAcademicoMinAggregateOutputType | null
    _max: HistoricoAcademicoMaxAggregateOutputType | null
  }

  export type HistoricoAcademicoAvgAggregateOutputType = {
    id: number | null
    id_usuario: number | null
    id_curso: number | null
    nota: number | null
  }

  export type HistoricoAcademicoSumAggregateOutputType = {
    id: number | null
    id_usuario: number | null
    id_curso: number | null
    nota: number | null
  }

  export type HistoricoAcademicoMinAggregateOutputType = {
    id: number | null
    id_usuario: number | null
    id_curso: number | null
    nota: number | null
  }

  export type HistoricoAcademicoMaxAggregateOutputType = {
    id: number | null
    id_usuario: number | null
    id_curso: number | null
    nota: number | null
  }

  export type HistoricoAcademicoCountAggregateOutputType = {
    id: number
    id_usuario: number
    id_curso: number
    nota: number
    _all: number
  }


  export type HistoricoAcademicoAvgAggregateInputType = {
    id?: true
    id_usuario?: true
    id_curso?: true
    nota?: true
  }

  export type HistoricoAcademicoSumAggregateInputType = {
    id?: true
    id_usuario?: true
    id_curso?: true
    nota?: true
  }

  export type HistoricoAcademicoMinAggregateInputType = {
    id?: true
    id_usuario?: true
    id_curso?: true
    nota?: true
  }

  export type HistoricoAcademicoMaxAggregateInputType = {
    id?: true
    id_usuario?: true
    id_curso?: true
    nota?: true
  }

  export type HistoricoAcademicoCountAggregateInputType = {
    id?: true
    id_usuario?: true
    id_curso?: true
    nota?: true
    _all?: true
  }

  export type HistoricoAcademicoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistoricoAcademico to aggregate.
     */
    where?: HistoricoAcademicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoricoAcademicos to fetch.
     */
    orderBy?: HistoricoAcademicoOrderByWithRelationInput | HistoricoAcademicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistoricoAcademicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoricoAcademicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoricoAcademicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HistoricoAcademicos
    **/
    _count?: true | HistoricoAcademicoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoricoAcademicoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoricoAcademicoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoricoAcademicoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoricoAcademicoMaxAggregateInputType
  }

  export type GetHistoricoAcademicoAggregateType<T extends HistoricoAcademicoAggregateArgs> = {
        [P in keyof T & keyof AggregateHistoricoAcademico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistoricoAcademico[P]>
      : GetScalarType<T[P], AggregateHistoricoAcademico[P]>
  }




  export type HistoricoAcademicoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoricoAcademicoWhereInput
    orderBy?: HistoricoAcademicoOrderByWithAggregationInput | HistoricoAcademicoOrderByWithAggregationInput[]
    by: HistoricoAcademicoScalarFieldEnum[] | HistoricoAcademicoScalarFieldEnum
    having?: HistoricoAcademicoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoricoAcademicoCountAggregateInputType | true
    _avg?: HistoricoAcademicoAvgAggregateInputType
    _sum?: HistoricoAcademicoSumAggregateInputType
    _min?: HistoricoAcademicoMinAggregateInputType
    _max?: HistoricoAcademicoMaxAggregateInputType
  }

  export type HistoricoAcademicoGroupByOutputType = {
    id: number
    id_usuario: number
    id_curso: number
    nota: number
    _count: HistoricoAcademicoCountAggregateOutputType | null
    _avg: HistoricoAcademicoAvgAggregateOutputType | null
    _sum: HistoricoAcademicoSumAggregateOutputType | null
    _min: HistoricoAcademicoMinAggregateOutputType | null
    _max: HistoricoAcademicoMaxAggregateOutputType | null
  }

  type GetHistoricoAcademicoGroupByPayload<T extends HistoricoAcademicoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoricoAcademicoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoricoAcademicoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoricoAcademicoGroupByOutputType[P]>
            : GetScalarType<T[P], HistoricoAcademicoGroupByOutputType[P]>
        }
      >
    >


  export type HistoricoAcademicoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_usuario?: boolean
    id_curso?: boolean
    nota?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Curso?: boolean | CursoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historicoAcademico"]>



  export type HistoricoAcademicoSelectScalar = {
    id?: boolean
    id_usuario?: boolean
    id_curso?: boolean
    nota?: boolean
  }

  export type HistoricoAcademicoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_usuario" | "id_curso" | "nota", ExtArgs["result"]["historicoAcademico"]>
  export type HistoricoAcademicoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Curso?: boolean | CursoDefaultArgs<ExtArgs>
  }

  export type $HistoricoAcademicoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HistoricoAcademico"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
      Curso: Prisma.$CursoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_usuario: number
      id_curso: number
      nota: number
    }, ExtArgs["result"]["historicoAcademico"]>
    composites: {}
  }

  type HistoricoAcademicoGetPayload<S extends boolean | null | undefined | HistoricoAcademicoDefaultArgs> = $Result.GetResult<Prisma.$HistoricoAcademicoPayload, S>

  type HistoricoAcademicoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HistoricoAcademicoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistoricoAcademicoCountAggregateInputType | true
    }

  export interface HistoricoAcademicoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HistoricoAcademico'], meta: { name: 'HistoricoAcademico' } }
    /**
     * Find zero or one HistoricoAcademico that matches the filter.
     * @param {HistoricoAcademicoFindUniqueArgs} args - Arguments to find a HistoricoAcademico
     * @example
     * // Get one HistoricoAcademico
     * const historicoAcademico = await prisma.historicoAcademico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HistoricoAcademicoFindUniqueArgs>(args: SelectSubset<T, HistoricoAcademicoFindUniqueArgs<ExtArgs>>): Prisma__HistoricoAcademicoClient<$Result.GetResult<Prisma.$HistoricoAcademicoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one HistoricoAcademico that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HistoricoAcademicoFindUniqueOrThrowArgs} args - Arguments to find a HistoricoAcademico
     * @example
     * // Get one HistoricoAcademico
     * const historicoAcademico = await prisma.historicoAcademico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HistoricoAcademicoFindUniqueOrThrowArgs>(args: SelectSubset<T, HistoricoAcademicoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HistoricoAcademicoClient<$Result.GetResult<Prisma.$HistoricoAcademicoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first HistoricoAcademico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoAcademicoFindFirstArgs} args - Arguments to find a HistoricoAcademico
     * @example
     * // Get one HistoricoAcademico
     * const historicoAcademico = await prisma.historicoAcademico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HistoricoAcademicoFindFirstArgs>(args?: SelectSubset<T, HistoricoAcademicoFindFirstArgs<ExtArgs>>): Prisma__HistoricoAcademicoClient<$Result.GetResult<Prisma.$HistoricoAcademicoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first HistoricoAcademico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoAcademicoFindFirstOrThrowArgs} args - Arguments to find a HistoricoAcademico
     * @example
     * // Get one HistoricoAcademico
     * const historicoAcademico = await prisma.historicoAcademico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HistoricoAcademicoFindFirstOrThrowArgs>(args?: SelectSubset<T, HistoricoAcademicoFindFirstOrThrowArgs<ExtArgs>>): Prisma__HistoricoAcademicoClient<$Result.GetResult<Prisma.$HistoricoAcademicoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more HistoricoAcademicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoAcademicoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistoricoAcademicos
     * const historicoAcademicos = await prisma.historicoAcademico.findMany()
     * 
     * // Get first 10 HistoricoAcademicos
     * const historicoAcademicos = await prisma.historicoAcademico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historicoAcademicoWithIdOnly = await prisma.historicoAcademico.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HistoricoAcademicoFindManyArgs>(args?: SelectSubset<T, HistoricoAcademicoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoricoAcademicoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a HistoricoAcademico.
     * @param {HistoricoAcademicoCreateArgs} args - Arguments to create a HistoricoAcademico.
     * @example
     * // Create one HistoricoAcademico
     * const HistoricoAcademico = await prisma.historicoAcademico.create({
     *   data: {
     *     // ... data to create a HistoricoAcademico
     *   }
     * })
     * 
     */
    create<T extends HistoricoAcademicoCreateArgs>(args: SelectSubset<T, HistoricoAcademicoCreateArgs<ExtArgs>>): Prisma__HistoricoAcademicoClient<$Result.GetResult<Prisma.$HistoricoAcademicoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many HistoricoAcademicos.
     * @param {HistoricoAcademicoCreateManyArgs} args - Arguments to create many HistoricoAcademicos.
     * @example
     * // Create many HistoricoAcademicos
     * const historicoAcademico = await prisma.historicoAcademico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HistoricoAcademicoCreateManyArgs>(args?: SelectSubset<T, HistoricoAcademicoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HistoricoAcademico.
     * @param {HistoricoAcademicoDeleteArgs} args - Arguments to delete one HistoricoAcademico.
     * @example
     * // Delete one HistoricoAcademico
     * const HistoricoAcademico = await prisma.historicoAcademico.delete({
     *   where: {
     *     // ... filter to delete one HistoricoAcademico
     *   }
     * })
     * 
     */
    delete<T extends HistoricoAcademicoDeleteArgs>(args: SelectSubset<T, HistoricoAcademicoDeleteArgs<ExtArgs>>): Prisma__HistoricoAcademicoClient<$Result.GetResult<Prisma.$HistoricoAcademicoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one HistoricoAcademico.
     * @param {HistoricoAcademicoUpdateArgs} args - Arguments to update one HistoricoAcademico.
     * @example
     * // Update one HistoricoAcademico
     * const historicoAcademico = await prisma.historicoAcademico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HistoricoAcademicoUpdateArgs>(args: SelectSubset<T, HistoricoAcademicoUpdateArgs<ExtArgs>>): Prisma__HistoricoAcademicoClient<$Result.GetResult<Prisma.$HistoricoAcademicoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more HistoricoAcademicos.
     * @param {HistoricoAcademicoDeleteManyArgs} args - Arguments to filter HistoricoAcademicos to delete.
     * @example
     * // Delete a few HistoricoAcademicos
     * const { count } = await prisma.historicoAcademico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HistoricoAcademicoDeleteManyArgs>(args?: SelectSubset<T, HistoricoAcademicoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistoricoAcademicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoAcademicoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistoricoAcademicos
     * const historicoAcademico = await prisma.historicoAcademico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HistoricoAcademicoUpdateManyArgs>(args: SelectSubset<T, HistoricoAcademicoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HistoricoAcademico.
     * @param {HistoricoAcademicoUpsertArgs} args - Arguments to update or create a HistoricoAcademico.
     * @example
     * // Update or create a HistoricoAcademico
     * const historicoAcademico = await prisma.historicoAcademico.upsert({
     *   create: {
     *     // ... data to create a HistoricoAcademico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistoricoAcademico we want to update
     *   }
     * })
     */
    upsert<T extends HistoricoAcademicoUpsertArgs>(args: SelectSubset<T, HistoricoAcademicoUpsertArgs<ExtArgs>>): Prisma__HistoricoAcademicoClient<$Result.GetResult<Prisma.$HistoricoAcademicoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of HistoricoAcademicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoAcademicoCountArgs} args - Arguments to filter HistoricoAcademicos to count.
     * @example
     * // Count the number of HistoricoAcademicos
     * const count = await prisma.historicoAcademico.count({
     *   where: {
     *     // ... the filter for the HistoricoAcademicos we want to count
     *   }
     * })
    **/
    count<T extends HistoricoAcademicoCountArgs>(
      args?: Subset<T, HistoricoAcademicoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoricoAcademicoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistoricoAcademico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoAcademicoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoricoAcademicoAggregateArgs>(args: Subset<T, HistoricoAcademicoAggregateArgs>): Prisma.PrismaPromise<GetHistoricoAcademicoAggregateType<T>>

    /**
     * Group by HistoricoAcademico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoAcademicoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistoricoAcademicoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistoricoAcademicoGroupByArgs['orderBy'] }
        : { orderBy?: HistoricoAcademicoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistoricoAcademicoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoricoAcademicoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HistoricoAcademico model
   */
  readonly fields: HistoricoAcademicoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HistoricoAcademico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistoricoAcademicoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Curso<T extends CursoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CursoDefaultArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HistoricoAcademico model
   */ 
  interface HistoricoAcademicoFieldRefs {
    readonly id: FieldRef<"HistoricoAcademico", 'Int'>
    readonly id_usuario: FieldRef<"HistoricoAcademico", 'Int'>
    readonly id_curso: FieldRef<"HistoricoAcademico", 'Int'>
    readonly nota: FieldRef<"HistoricoAcademico", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * HistoricoAcademico findUnique
   */
  export type HistoricoAcademicoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoAcademico
     */
    select?: HistoricoAcademicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoAcademico
     */
    omit?: HistoricoAcademicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoricoAcademicoInclude<ExtArgs> | null
    /**
     * Filter, which HistoricoAcademico to fetch.
     */
    where: HistoricoAcademicoWhereUniqueInput
  }

  /**
   * HistoricoAcademico findUniqueOrThrow
   */
  export type HistoricoAcademicoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoAcademico
     */
    select?: HistoricoAcademicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoAcademico
     */
    omit?: HistoricoAcademicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoricoAcademicoInclude<ExtArgs> | null
    /**
     * Filter, which HistoricoAcademico to fetch.
     */
    where: HistoricoAcademicoWhereUniqueInput
  }

  /**
   * HistoricoAcademico findFirst
   */
  export type HistoricoAcademicoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoAcademico
     */
    select?: HistoricoAcademicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoAcademico
     */
    omit?: HistoricoAcademicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoricoAcademicoInclude<ExtArgs> | null
    /**
     * Filter, which HistoricoAcademico to fetch.
     */
    where?: HistoricoAcademicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoricoAcademicos to fetch.
     */
    orderBy?: HistoricoAcademicoOrderByWithRelationInput | HistoricoAcademicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistoricoAcademicos.
     */
    cursor?: HistoricoAcademicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoricoAcademicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoricoAcademicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistoricoAcademicos.
     */
    distinct?: HistoricoAcademicoScalarFieldEnum | HistoricoAcademicoScalarFieldEnum[]
  }

  /**
   * HistoricoAcademico findFirstOrThrow
   */
  export type HistoricoAcademicoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoAcademico
     */
    select?: HistoricoAcademicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoAcademico
     */
    omit?: HistoricoAcademicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoricoAcademicoInclude<ExtArgs> | null
    /**
     * Filter, which HistoricoAcademico to fetch.
     */
    where?: HistoricoAcademicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoricoAcademicos to fetch.
     */
    orderBy?: HistoricoAcademicoOrderByWithRelationInput | HistoricoAcademicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistoricoAcademicos.
     */
    cursor?: HistoricoAcademicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoricoAcademicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoricoAcademicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistoricoAcademicos.
     */
    distinct?: HistoricoAcademicoScalarFieldEnum | HistoricoAcademicoScalarFieldEnum[]
  }

  /**
   * HistoricoAcademico findMany
   */
  export type HistoricoAcademicoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoAcademico
     */
    select?: HistoricoAcademicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoAcademico
     */
    omit?: HistoricoAcademicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoricoAcademicoInclude<ExtArgs> | null
    /**
     * Filter, which HistoricoAcademicos to fetch.
     */
    where?: HistoricoAcademicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoricoAcademicos to fetch.
     */
    orderBy?: HistoricoAcademicoOrderByWithRelationInput | HistoricoAcademicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HistoricoAcademicos.
     */
    cursor?: HistoricoAcademicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoricoAcademicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoricoAcademicos.
     */
    skip?: number
    distinct?: HistoricoAcademicoScalarFieldEnum | HistoricoAcademicoScalarFieldEnum[]
  }

  /**
   * HistoricoAcademico create
   */
  export type HistoricoAcademicoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoAcademico
     */
    select?: HistoricoAcademicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoAcademico
     */
    omit?: HistoricoAcademicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoricoAcademicoInclude<ExtArgs> | null
    /**
     * The data needed to create a HistoricoAcademico.
     */
    data: XOR<HistoricoAcademicoCreateInput, HistoricoAcademicoUncheckedCreateInput>
  }

  /**
   * HistoricoAcademico createMany
   */
  export type HistoricoAcademicoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HistoricoAcademicos.
     */
    data: HistoricoAcademicoCreateManyInput | HistoricoAcademicoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HistoricoAcademico update
   */
  export type HistoricoAcademicoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoAcademico
     */
    select?: HistoricoAcademicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoAcademico
     */
    omit?: HistoricoAcademicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoricoAcademicoInclude<ExtArgs> | null
    /**
     * The data needed to update a HistoricoAcademico.
     */
    data: XOR<HistoricoAcademicoUpdateInput, HistoricoAcademicoUncheckedUpdateInput>
    /**
     * Choose, which HistoricoAcademico to update.
     */
    where: HistoricoAcademicoWhereUniqueInput
  }

  /**
   * HistoricoAcademico updateMany
   */
  export type HistoricoAcademicoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HistoricoAcademicos.
     */
    data: XOR<HistoricoAcademicoUpdateManyMutationInput, HistoricoAcademicoUncheckedUpdateManyInput>
    /**
     * Filter which HistoricoAcademicos to update
     */
    where?: HistoricoAcademicoWhereInput
    /**
     * Limit how many HistoricoAcademicos to update.
     */
    limit?: number
  }

  /**
   * HistoricoAcademico upsert
   */
  export type HistoricoAcademicoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoAcademico
     */
    select?: HistoricoAcademicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoAcademico
     */
    omit?: HistoricoAcademicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoricoAcademicoInclude<ExtArgs> | null
    /**
     * The filter to search for the HistoricoAcademico to update in case it exists.
     */
    where: HistoricoAcademicoWhereUniqueInput
    /**
     * In case the HistoricoAcademico found by the `where` argument doesn't exist, create a new HistoricoAcademico with this data.
     */
    create: XOR<HistoricoAcademicoCreateInput, HistoricoAcademicoUncheckedCreateInput>
    /**
     * In case the HistoricoAcademico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistoricoAcademicoUpdateInput, HistoricoAcademicoUncheckedUpdateInput>
  }

  /**
   * HistoricoAcademico delete
   */
  export type HistoricoAcademicoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoAcademico
     */
    select?: HistoricoAcademicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoAcademico
     */
    omit?: HistoricoAcademicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoricoAcademicoInclude<ExtArgs> | null
    /**
     * Filter which HistoricoAcademico to delete.
     */
    where: HistoricoAcademicoWhereUniqueInput
  }

  /**
   * HistoricoAcademico deleteMany
   */
  export type HistoricoAcademicoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistoricoAcademicos to delete
     */
    where?: HistoricoAcademicoWhereInput
    /**
     * Limit how many HistoricoAcademicos to delete.
     */
    limit?: number
  }

  /**
   * HistoricoAcademico without action
   */
  export type HistoricoAcademicoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoricoAcademico
     */
    select?: HistoricoAcademicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoricoAcademico
     */
    omit?: HistoricoAcademicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoricoAcademicoInclude<ExtArgs> | null
  }


  /**
   * Model Auditoria
   */

  export type AggregateAuditoria = {
    _count: AuditoriaCountAggregateOutputType | null
    _avg: AuditoriaAvgAggregateOutputType | null
    _sum: AuditoriaSumAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  export type AuditoriaAvgAggregateOutputType = {
    id: number | null
    id_usuario: number | null
  }

  export type AuditoriaSumAggregateOutputType = {
    id: number | null
    id_usuario: number | null
  }

  export type AuditoriaMinAggregateOutputType = {
    id: number | null
    id_usuario: number | null
    accion: string | null
    fecha_hora: Date | null
    descripcion: string | null
  }

  export type AuditoriaMaxAggregateOutputType = {
    id: number | null
    id_usuario: number | null
    accion: string | null
    fecha_hora: Date | null
    descripcion: string | null
  }

  export type AuditoriaCountAggregateOutputType = {
    id: number
    id_usuario: number
    accion: number
    fecha_hora: number
    descripcion: number
    _all: number
  }


  export type AuditoriaAvgAggregateInputType = {
    id?: true
    id_usuario?: true
  }

  export type AuditoriaSumAggregateInputType = {
    id?: true
    id_usuario?: true
  }

  export type AuditoriaMinAggregateInputType = {
    id?: true
    id_usuario?: true
    accion?: true
    fecha_hora?: true
    descripcion?: true
  }

  export type AuditoriaMaxAggregateInputType = {
    id?: true
    id_usuario?: true
    accion?: true
    fecha_hora?: true
    descripcion?: true
  }

  export type AuditoriaCountAggregateInputType = {
    id?: true
    id_usuario?: true
    accion?: true
    fecha_hora?: true
    descripcion?: true
    _all?: true
  }

  export type AuditoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auditoria to aggregate.
     */
    where?: AuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditorias to fetch.
     */
    orderBy?: AuditoriaOrderByWithRelationInput | AuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Auditorias
    **/
    _count?: true | AuditoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditoriaMaxAggregateInputType
  }

  export type GetAuditoriaAggregateType<T extends AuditoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditoria[P]>
      : GetScalarType<T[P], AggregateAuditoria[P]>
  }




  export type AuditoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditoriaWhereInput
    orderBy?: AuditoriaOrderByWithAggregationInput | AuditoriaOrderByWithAggregationInput[]
    by: AuditoriaScalarFieldEnum[] | AuditoriaScalarFieldEnum
    having?: AuditoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditoriaCountAggregateInputType | true
    _avg?: AuditoriaAvgAggregateInputType
    _sum?: AuditoriaSumAggregateInputType
    _min?: AuditoriaMinAggregateInputType
    _max?: AuditoriaMaxAggregateInputType
  }

  export type AuditoriaGroupByOutputType = {
    id: number
    id_usuario: number
    accion: string
    fecha_hora: Date
    descripcion: string
    _count: AuditoriaCountAggregateOutputType | null
    _avg: AuditoriaAvgAggregateOutputType | null
    _sum: AuditoriaSumAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  type GetAuditoriaGroupByPayload<T extends AuditoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
            : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
        }
      >
    >


  export type AuditoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_usuario?: boolean
    accion?: boolean
    fecha_hora?: boolean
    descripcion?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditoria"]>



  export type AuditoriaSelectScalar = {
    id?: boolean
    id_usuario?: boolean
    accion?: boolean
    fecha_hora?: boolean
    descripcion?: boolean
  }

  export type AuditoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_usuario" | "accion" | "fecha_hora" | "descripcion", ExtArgs["result"]["auditoria"]>
  export type AuditoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $AuditoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Auditoria"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_usuario: number
      accion: string
      fecha_hora: Date
      descripcion: string
    }, ExtArgs["result"]["auditoria"]>
    composites: {}
  }

  type AuditoriaGetPayload<S extends boolean | null | undefined | AuditoriaDefaultArgs> = $Result.GetResult<Prisma.$AuditoriaPayload, S>

  type AuditoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditoriaCountAggregateInputType | true
    }

  export interface AuditoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Auditoria'], meta: { name: 'Auditoria' } }
    /**
     * Find zero or one Auditoria that matches the filter.
     * @param {AuditoriaFindUniqueArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditoriaFindUniqueArgs>(args: SelectSubset<T, AuditoriaFindUniqueArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Auditoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditoriaFindUniqueOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Auditoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaFindFirstArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditoriaFindFirstArgs>(args?: SelectSubset<T, AuditoriaFindFirstArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Auditoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaFindFirstOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Auditorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditorias
     * const auditorias = await prisma.auditoria.findMany()
     * 
     * // Get first 10 Auditorias
     * const auditorias = await prisma.auditoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditoriaFindManyArgs>(args?: SelectSubset<T, AuditoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Auditoria.
     * @param {AuditoriaCreateArgs} args - Arguments to create a Auditoria.
     * @example
     * // Create one Auditoria
     * const Auditoria = await prisma.auditoria.create({
     *   data: {
     *     // ... data to create a Auditoria
     *   }
     * })
     * 
     */
    create<T extends AuditoriaCreateArgs>(args: SelectSubset<T, AuditoriaCreateArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Auditorias.
     * @param {AuditoriaCreateManyArgs} args - Arguments to create many Auditorias.
     * @example
     * // Create many Auditorias
     * const auditoria = await prisma.auditoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditoriaCreateManyArgs>(args?: SelectSubset<T, AuditoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auditoria.
     * @param {AuditoriaDeleteArgs} args - Arguments to delete one Auditoria.
     * @example
     * // Delete one Auditoria
     * const Auditoria = await prisma.auditoria.delete({
     *   where: {
     *     // ... filter to delete one Auditoria
     *   }
     * })
     * 
     */
    delete<T extends AuditoriaDeleteArgs>(args: SelectSubset<T, AuditoriaDeleteArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Auditoria.
     * @param {AuditoriaUpdateArgs} args - Arguments to update one Auditoria.
     * @example
     * // Update one Auditoria
     * const auditoria = await prisma.auditoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditoriaUpdateArgs>(args: SelectSubset<T, AuditoriaUpdateArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Auditorias.
     * @param {AuditoriaDeleteManyArgs} args - Arguments to filter Auditorias to delete.
     * @example
     * // Delete a few Auditorias
     * const { count } = await prisma.auditoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditoriaDeleteManyArgs>(args?: SelectSubset<T, AuditoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditorias
     * const auditoria = await prisma.auditoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditoriaUpdateManyArgs>(args: SelectSubset<T, AuditoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auditoria.
     * @param {AuditoriaUpsertArgs} args - Arguments to update or create a Auditoria.
     * @example
     * // Update or create a Auditoria
     * const auditoria = await prisma.auditoria.upsert({
     *   create: {
     *     // ... data to create a Auditoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditoria we want to update
     *   }
     * })
     */
    upsert<T extends AuditoriaUpsertArgs>(args: SelectSubset<T, AuditoriaUpsertArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaCountArgs} args - Arguments to filter Auditorias to count.
     * @example
     * // Count the number of Auditorias
     * const count = await prisma.auditoria.count({
     *   where: {
     *     // ... the filter for the Auditorias we want to count
     *   }
     * })
    **/
    count<T extends AuditoriaCountArgs>(
      args?: Subset<T, AuditoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditoriaAggregateArgs>(args: Subset<T, AuditoriaAggregateArgs>): Prisma.PrismaPromise<GetAuditoriaAggregateType<T>>

    /**
     * Group by Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditoriaGroupByArgs['orderBy'] }
        : { orderBy?: AuditoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Auditoria model
   */
  readonly fields: AuditoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Auditoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Auditoria model
   */ 
  interface AuditoriaFieldRefs {
    readonly id: FieldRef<"Auditoria", 'Int'>
    readonly id_usuario: FieldRef<"Auditoria", 'Int'>
    readonly accion: FieldRef<"Auditoria", 'String'>
    readonly fecha_hora: FieldRef<"Auditoria", 'DateTime'>
    readonly descripcion: FieldRef<"Auditoria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Auditoria findUnique
   */
  export type AuditoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which Auditoria to fetch.
     */
    where: AuditoriaWhereUniqueInput
  }

  /**
   * Auditoria findUniqueOrThrow
   */
  export type AuditoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which Auditoria to fetch.
     */
    where: AuditoriaWhereUniqueInput
  }

  /**
   * Auditoria findFirst
   */
  export type AuditoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which Auditoria to fetch.
     */
    where?: AuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditorias to fetch.
     */
    orderBy?: AuditoriaOrderByWithRelationInput | AuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auditorias.
     */
    cursor?: AuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auditorias.
     */
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * Auditoria findFirstOrThrow
   */
  export type AuditoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which Auditoria to fetch.
     */
    where?: AuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditorias to fetch.
     */
    orderBy?: AuditoriaOrderByWithRelationInput | AuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auditorias.
     */
    cursor?: AuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auditorias.
     */
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * Auditoria findMany
   */
  export type AuditoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which Auditorias to fetch.
     */
    where?: AuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditorias to fetch.
     */
    orderBy?: AuditoriaOrderByWithRelationInput | AuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Auditorias.
     */
    cursor?: AuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditorias.
     */
    skip?: number
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * Auditoria create
   */
  export type AuditoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Auditoria.
     */
    data: XOR<AuditoriaCreateInput, AuditoriaUncheckedCreateInput>
  }

  /**
   * Auditoria createMany
   */
  export type AuditoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Auditorias.
     */
    data: AuditoriaCreateManyInput | AuditoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Auditoria update
   */
  export type AuditoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Auditoria.
     */
    data: XOR<AuditoriaUpdateInput, AuditoriaUncheckedUpdateInput>
    /**
     * Choose, which Auditoria to update.
     */
    where: AuditoriaWhereUniqueInput
  }

  /**
   * Auditoria updateMany
   */
  export type AuditoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Auditorias.
     */
    data: XOR<AuditoriaUpdateManyMutationInput, AuditoriaUncheckedUpdateManyInput>
    /**
     * Filter which Auditorias to update
     */
    where?: AuditoriaWhereInput
    /**
     * Limit how many Auditorias to update.
     */
    limit?: number
  }

  /**
   * Auditoria upsert
   */
  export type AuditoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Auditoria to update in case it exists.
     */
    where: AuditoriaWhereUniqueInput
    /**
     * In case the Auditoria found by the `where` argument doesn't exist, create a new Auditoria with this data.
     */
    create: XOR<AuditoriaCreateInput, AuditoriaUncheckedCreateInput>
    /**
     * In case the Auditoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditoriaUpdateInput, AuditoriaUncheckedUpdateInput>
  }

  /**
   * Auditoria delete
   */
  export type AuditoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriaInclude<ExtArgs> | null
    /**
     * Filter which Auditoria to delete.
     */
    where: AuditoriaWhereUniqueInput
  }

  /**
   * Auditoria deleteMany
   */
  export type AuditoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auditorias to delete
     */
    where?: AuditoriaWhereInput
    /**
     * Limit how many Auditorias to delete.
     */
    limit?: number
  }

  /**
   * Auditoria without action
   */
  export type AuditoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditoriaInclude<ExtArgs> | null
  }


  /**
   * Model EncabezadoFactura
   */

  export type AggregateEncabezadoFactura = {
    _count: EncabezadoFacturaCountAggregateOutputType | null
    _avg: EncabezadoFacturaAvgAggregateOutputType | null
    _sum: EncabezadoFacturaSumAggregateOutputType | null
    _min: EncabezadoFacturaMinAggregateOutputType | null
    _max: EncabezadoFacturaMaxAggregateOutputType | null
  }

  export type EncabezadoFacturaAvgAggregateOutputType = {
    id: number | null
    id_cuatrimestre: number | null
    id_carrera: number | null
    id_usuario: number | null
  }

  export type EncabezadoFacturaSumAggregateOutputType = {
    id: number | null
    id_cuatrimestre: number | null
    id_carrera: number | null
    id_usuario: number | null
  }

  export type EncabezadoFacturaMinAggregateOutputType = {
    id: number | null
    id_cuatrimestre: number | null
    id_carrera: number | null
    id_usuario: number | null
    fecha_hora: Date | null
  }

  export type EncabezadoFacturaMaxAggregateOutputType = {
    id: number | null
    id_cuatrimestre: number | null
    id_carrera: number | null
    id_usuario: number | null
    fecha_hora: Date | null
  }

  export type EncabezadoFacturaCountAggregateOutputType = {
    id: number
    id_cuatrimestre: number
    id_carrera: number
    id_usuario: number
    fecha_hora: number
    _all: number
  }


  export type EncabezadoFacturaAvgAggregateInputType = {
    id?: true
    id_cuatrimestre?: true
    id_carrera?: true
    id_usuario?: true
  }

  export type EncabezadoFacturaSumAggregateInputType = {
    id?: true
    id_cuatrimestre?: true
    id_carrera?: true
    id_usuario?: true
  }

  export type EncabezadoFacturaMinAggregateInputType = {
    id?: true
    id_cuatrimestre?: true
    id_carrera?: true
    id_usuario?: true
    fecha_hora?: true
  }

  export type EncabezadoFacturaMaxAggregateInputType = {
    id?: true
    id_cuatrimestre?: true
    id_carrera?: true
    id_usuario?: true
    fecha_hora?: true
  }

  export type EncabezadoFacturaCountAggregateInputType = {
    id?: true
    id_cuatrimestre?: true
    id_carrera?: true
    id_usuario?: true
    fecha_hora?: true
    _all?: true
  }

  export type EncabezadoFacturaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncabezadoFactura to aggregate.
     */
    where?: EncabezadoFacturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncabezadoFacturas to fetch.
     */
    orderBy?: EncabezadoFacturaOrderByWithRelationInput | EncabezadoFacturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncabezadoFacturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncabezadoFacturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncabezadoFacturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncabezadoFacturas
    **/
    _count?: true | EncabezadoFacturaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncabezadoFacturaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncabezadoFacturaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncabezadoFacturaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncabezadoFacturaMaxAggregateInputType
  }

  export type GetEncabezadoFacturaAggregateType<T extends EncabezadoFacturaAggregateArgs> = {
        [P in keyof T & keyof AggregateEncabezadoFactura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncabezadoFactura[P]>
      : GetScalarType<T[P], AggregateEncabezadoFactura[P]>
  }




  export type EncabezadoFacturaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncabezadoFacturaWhereInput
    orderBy?: EncabezadoFacturaOrderByWithAggregationInput | EncabezadoFacturaOrderByWithAggregationInput[]
    by: EncabezadoFacturaScalarFieldEnum[] | EncabezadoFacturaScalarFieldEnum
    having?: EncabezadoFacturaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncabezadoFacturaCountAggregateInputType | true
    _avg?: EncabezadoFacturaAvgAggregateInputType
    _sum?: EncabezadoFacturaSumAggregateInputType
    _min?: EncabezadoFacturaMinAggregateInputType
    _max?: EncabezadoFacturaMaxAggregateInputType
  }

  export type EncabezadoFacturaGroupByOutputType = {
    id: number
    id_cuatrimestre: number
    id_carrera: number
    id_usuario: number
    fecha_hora: Date
    _count: EncabezadoFacturaCountAggregateOutputType | null
    _avg: EncabezadoFacturaAvgAggregateOutputType | null
    _sum: EncabezadoFacturaSumAggregateOutputType | null
    _min: EncabezadoFacturaMinAggregateOutputType | null
    _max: EncabezadoFacturaMaxAggregateOutputType | null
  }

  type GetEncabezadoFacturaGroupByPayload<T extends EncabezadoFacturaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncabezadoFacturaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncabezadoFacturaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncabezadoFacturaGroupByOutputType[P]>
            : GetScalarType<T[P], EncabezadoFacturaGroupByOutputType[P]>
        }
      >
    >


  export type EncabezadoFacturaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_cuatrimestre?: boolean
    id_carrera?: boolean
    id_usuario?: boolean
    fecha_hora?: boolean
    Carrera?: boolean | CarreraDefaultArgs<ExtArgs>
    Cuatrimestre?: boolean | CuatrimestreDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    DetalleFactura?: boolean | EncabezadoFactura$DetalleFacturaArgs<ExtArgs>
    _count?: boolean | EncabezadoFacturaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encabezadoFactura"]>



  export type EncabezadoFacturaSelectScalar = {
    id?: boolean
    id_cuatrimestre?: boolean
    id_carrera?: boolean
    id_usuario?: boolean
    fecha_hora?: boolean
  }

  export type EncabezadoFacturaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_cuatrimestre" | "id_carrera" | "id_usuario" | "fecha_hora", ExtArgs["result"]["encabezadoFactura"]>
  export type EncabezadoFacturaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Carrera?: boolean | CarreraDefaultArgs<ExtArgs>
    Cuatrimestre?: boolean | CuatrimestreDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    DetalleFactura?: boolean | EncabezadoFactura$DetalleFacturaArgs<ExtArgs>
    _count?: boolean | EncabezadoFacturaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EncabezadoFacturaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncabezadoFactura"
    objects: {
      Carrera: Prisma.$CarreraPayload<ExtArgs>
      Cuatrimestre: Prisma.$CuatrimestrePayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
      DetalleFactura: Prisma.$DetalleFacturaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_cuatrimestre: number
      id_carrera: number
      id_usuario: number
      fecha_hora: Date
    }, ExtArgs["result"]["encabezadoFactura"]>
    composites: {}
  }

  type EncabezadoFacturaGetPayload<S extends boolean | null | undefined | EncabezadoFacturaDefaultArgs> = $Result.GetResult<Prisma.$EncabezadoFacturaPayload, S>

  type EncabezadoFacturaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncabezadoFacturaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncabezadoFacturaCountAggregateInputType | true
    }

  export interface EncabezadoFacturaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncabezadoFactura'], meta: { name: 'EncabezadoFactura' } }
    /**
     * Find zero or one EncabezadoFactura that matches the filter.
     * @param {EncabezadoFacturaFindUniqueArgs} args - Arguments to find a EncabezadoFactura
     * @example
     * // Get one EncabezadoFactura
     * const encabezadoFactura = await prisma.encabezadoFactura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncabezadoFacturaFindUniqueArgs>(args: SelectSubset<T, EncabezadoFacturaFindUniqueArgs<ExtArgs>>): Prisma__EncabezadoFacturaClient<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EncabezadoFactura that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncabezadoFacturaFindUniqueOrThrowArgs} args - Arguments to find a EncabezadoFactura
     * @example
     * // Get one EncabezadoFactura
     * const encabezadoFactura = await prisma.encabezadoFactura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncabezadoFacturaFindUniqueOrThrowArgs>(args: SelectSubset<T, EncabezadoFacturaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncabezadoFacturaClient<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EncabezadoFactura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoFacturaFindFirstArgs} args - Arguments to find a EncabezadoFactura
     * @example
     * // Get one EncabezadoFactura
     * const encabezadoFactura = await prisma.encabezadoFactura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncabezadoFacturaFindFirstArgs>(args?: SelectSubset<T, EncabezadoFacturaFindFirstArgs<ExtArgs>>): Prisma__EncabezadoFacturaClient<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EncabezadoFactura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoFacturaFindFirstOrThrowArgs} args - Arguments to find a EncabezadoFactura
     * @example
     * // Get one EncabezadoFactura
     * const encabezadoFactura = await prisma.encabezadoFactura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncabezadoFacturaFindFirstOrThrowArgs>(args?: SelectSubset<T, EncabezadoFacturaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncabezadoFacturaClient<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EncabezadoFacturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoFacturaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncabezadoFacturas
     * const encabezadoFacturas = await prisma.encabezadoFactura.findMany()
     * 
     * // Get first 10 EncabezadoFacturas
     * const encabezadoFacturas = await prisma.encabezadoFactura.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encabezadoFacturaWithIdOnly = await prisma.encabezadoFactura.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncabezadoFacturaFindManyArgs>(args?: SelectSubset<T, EncabezadoFacturaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EncabezadoFactura.
     * @param {EncabezadoFacturaCreateArgs} args - Arguments to create a EncabezadoFactura.
     * @example
     * // Create one EncabezadoFactura
     * const EncabezadoFactura = await prisma.encabezadoFactura.create({
     *   data: {
     *     // ... data to create a EncabezadoFactura
     *   }
     * })
     * 
     */
    create<T extends EncabezadoFacturaCreateArgs>(args: SelectSubset<T, EncabezadoFacturaCreateArgs<ExtArgs>>): Prisma__EncabezadoFacturaClient<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EncabezadoFacturas.
     * @param {EncabezadoFacturaCreateManyArgs} args - Arguments to create many EncabezadoFacturas.
     * @example
     * // Create many EncabezadoFacturas
     * const encabezadoFactura = await prisma.encabezadoFactura.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncabezadoFacturaCreateManyArgs>(args?: SelectSubset<T, EncabezadoFacturaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EncabezadoFactura.
     * @param {EncabezadoFacturaDeleteArgs} args - Arguments to delete one EncabezadoFactura.
     * @example
     * // Delete one EncabezadoFactura
     * const EncabezadoFactura = await prisma.encabezadoFactura.delete({
     *   where: {
     *     // ... filter to delete one EncabezadoFactura
     *   }
     * })
     * 
     */
    delete<T extends EncabezadoFacturaDeleteArgs>(args: SelectSubset<T, EncabezadoFacturaDeleteArgs<ExtArgs>>): Prisma__EncabezadoFacturaClient<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EncabezadoFactura.
     * @param {EncabezadoFacturaUpdateArgs} args - Arguments to update one EncabezadoFactura.
     * @example
     * // Update one EncabezadoFactura
     * const encabezadoFactura = await prisma.encabezadoFactura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncabezadoFacturaUpdateArgs>(args: SelectSubset<T, EncabezadoFacturaUpdateArgs<ExtArgs>>): Prisma__EncabezadoFacturaClient<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EncabezadoFacturas.
     * @param {EncabezadoFacturaDeleteManyArgs} args - Arguments to filter EncabezadoFacturas to delete.
     * @example
     * // Delete a few EncabezadoFacturas
     * const { count } = await prisma.encabezadoFactura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncabezadoFacturaDeleteManyArgs>(args?: SelectSubset<T, EncabezadoFacturaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncabezadoFacturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoFacturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncabezadoFacturas
     * const encabezadoFactura = await prisma.encabezadoFactura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncabezadoFacturaUpdateManyArgs>(args: SelectSubset<T, EncabezadoFacturaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncabezadoFactura.
     * @param {EncabezadoFacturaUpsertArgs} args - Arguments to update or create a EncabezadoFactura.
     * @example
     * // Update or create a EncabezadoFactura
     * const encabezadoFactura = await prisma.encabezadoFactura.upsert({
     *   create: {
     *     // ... data to create a EncabezadoFactura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncabezadoFactura we want to update
     *   }
     * })
     */
    upsert<T extends EncabezadoFacturaUpsertArgs>(args: SelectSubset<T, EncabezadoFacturaUpsertArgs<ExtArgs>>): Prisma__EncabezadoFacturaClient<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EncabezadoFacturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoFacturaCountArgs} args - Arguments to filter EncabezadoFacturas to count.
     * @example
     * // Count the number of EncabezadoFacturas
     * const count = await prisma.encabezadoFactura.count({
     *   where: {
     *     // ... the filter for the EncabezadoFacturas we want to count
     *   }
     * })
    **/
    count<T extends EncabezadoFacturaCountArgs>(
      args?: Subset<T, EncabezadoFacturaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncabezadoFacturaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncabezadoFactura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoFacturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncabezadoFacturaAggregateArgs>(args: Subset<T, EncabezadoFacturaAggregateArgs>): Prisma.PrismaPromise<GetEncabezadoFacturaAggregateType<T>>

    /**
     * Group by EncabezadoFactura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncabezadoFacturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncabezadoFacturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncabezadoFacturaGroupByArgs['orderBy'] }
        : { orderBy?: EncabezadoFacturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncabezadoFacturaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncabezadoFacturaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncabezadoFactura model
   */
  readonly fields: EncabezadoFacturaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncabezadoFactura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncabezadoFacturaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Carrera<T extends CarreraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CarreraDefaultArgs<ExtArgs>>): Prisma__CarreraClient<$Result.GetResult<Prisma.$CarreraPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Cuatrimestre<T extends CuatrimestreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CuatrimestreDefaultArgs<ExtArgs>>): Prisma__CuatrimestreClient<$Result.GetResult<Prisma.$CuatrimestrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    DetalleFactura<T extends EncabezadoFactura$DetalleFacturaArgs<ExtArgs> = {}>(args?: Subset<T, EncabezadoFactura$DetalleFacturaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleFacturaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncabezadoFactura model
   */ 
  interface EncabezadoFacturaFieldRefs {
    readonly id: FieldRef<"EncabezadoFactura", 'Int'>
    readonly id_cuatrimestre: FieldRef<"EncabezadoFactura", 'Int'>
    readonly id_carrera: FieldRef<"EncabezadoFactura", 'Int'>
    readonly id_usuario: FieldRef<"EncabezadoFactura", 'Int'>
    readonly fecha_hora: FieldRef<"EncabezadoFactura", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EncabezadoFactura findUnique
   */
  export type EncabezadoFacturaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoFactura to fetch.
     */
    where: EncabezadoFacturaWhereUniqueInput
  }

  /**
   * EncabezadoFactura findUniqueOrThrow
   */
  export type EncabezadoFacturaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoFactura to fetch.
     */
    where: EncabezadoFacturaWhereUniqueInput
  }

  /**
   * EncabezadoFactura findFirst
   */
  export type EncabezadoFacturaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoFactura to fetch.
     */
    where?: EncabezadoFacturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncabezadoFacturas to fetch.
     */
    orderBy?: EncabezadoFacturaOrderByWithRelationInput | EncabezadoFacturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncabezadoFacturas.
     */
    cursor?: EncabezadoFacturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncabezadoFacturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncabezadoFacturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncabezadoFacturas.
     */
    distinct?: EncabezadoFacturaScalarFieldEnum | EncabezadoFacturaScalarFieldEnum[]
  }

  /**
   * EncabezadoFactura findFirstOrThrow
   */
  export type EncabezadoFacturaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoFactura to fetch.
     */
    where?: EncabezadoFacturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncabezadoFacturas to fetch.
     */
    orderBy?: EncabezadoFacturaOrderByWithRelationInput | EncabezadoFacturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncabezadoFacturas.
     */
    cursor?: EncabezadoFacturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncabezadoFacturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncabezadoFacturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncabezadoFacturas.
     */
    distinct?: EncabezadoFacturaScalarFieldEnum | EncabezadoFacturaScalarFieldEnum[]
  }

  /**
   * EncabezadoFactura findMany
   */
  export type EncabezadoFacturaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
    /**
     * Filter, which EncabezadoFacturas to fetch.
     */
    where?: EncabezadoFacturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncabezadoFacturas to fetch.
     */
    orderBy?: EncabezadoFacturaOrderByWithRelationInput | EncabezadoFacturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncabezadoFacturas.
     */
    cursor?: EncabezadoFacturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncabezadoFacturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncabezadoFacturas.
     */
    skip?: number
    distinct?: EncabezadoFacturaScalarFieldEnum | EncabezadoFacturaScalarFieldEnum[]
  }

  /**
   * EncabezadoFactura create
   */
  export type EncabezadoFacturaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
    /**
     * The data needed to create a EncabezadoFactura.
     */
    data: XOR<EncabezadoFacturaCreateInput, EncabezadoFacturaUncheckedCreateInput>
  }

  /**
   * EncabezadoFactura createMany
   */
  export type EncabezadoFacturaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncabezadoFacturas.
     */
    data: EncabezadoFacturaCreateManyInput | EncabezadoFacturaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncabezadoFactura update
   */
  export type EncabezadoFacturaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
    /**
     * The data needed to update a EncabezadoFactura.
     */
    data: XOR<EncabezadoFacturaUpdateInput, EncabezadoFacturaUncheckedUpdateInput>
    /**
     * Choose, which EncabezadoFactura to update.
     */
    where: EncabezadoFacturaWhereUniqueInput
  }

  /**
   * EncabezadoFactura updateMany
   */
  export type EncabezadoFacturaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncabezadoFacturas.
     */
    data: XOR<EncabezadoFacturaUpdateManyMutationInput, EncabezadoFacturaUncheckedUpdateManyInput>
    /**
     * Filter which EncabezadoFacturas to update
     */
    where?: EncabezadoFacturaWhereInput
    /**
     * Limit how many EncabezadoFacturas to update.
     */
    limit?: number
  }

  /**
   * EncabezadoFactura upsert
   */
  export type EncabezadoFacturaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
    /**
     * The filter to search for the EncabezadoFactura to update in case it exists.
     */
    where: EncabezadoFacturaWhereUniqueInput
    /**
     * In case the EncabezadoFactura found by the `where` argument doesn't exist, create a new EncabezadoFactura with this data.
     */
    create: XOR<EncabezadoFacturaCreateInput, EncabezadoFacturaUncheckedCreateInput>
    /**
     * In case the EncabezadoFactura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncabezadoFacturaUpdateInput, EncabezadoFacturaUncheckedUpdateInput>
  }

  /**
   * EncabezadoFactura delete
   */
  export type EncabezadoFacturaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
    /**
     * Filter which EncabezadoFactura to delete.
     */
    where: EncabezadoFacturaWhereUniqueInput
  }

  /**
   * EncabezadoFactura deleteMany
   */
  export type EncabezadoFacturaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncabezadoFacturas to delete
     */
    where?: EncabezadoFacturaWhereInput
    /**
     * Limit how many EncabezadoFacturas to delete.
     */
    limit?: number
  }

  /**
   * EncabezadoFactura.DetalleFactura
   */
  export type EncabezadoFactura$DetalleFacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleFactura
     */
    select?: DetalleFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleFactura
     */
    omit?: DetalleFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleFacturaInclude<ExtArgs> | null
    where?: DetalleFacturaWhereInput
    orderBy?: DetalleFacturaOrderByWithRelationInput | DetalleFacturaOrderByWithRelationInput[]
    cursor?: DetalleFacturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetalleFacturaScalarFieldEnum | DetalleFacturaScalarFieldEnum[]
  }

  /**
   * EncabezadoFactura without action
   */
  export type EncabezadoFacturaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncabezadoFactura
     */
    select?: EncabezadoFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncabezadoFactura
     */
    omit?: EncabezadoFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncabezadoFacturaInclude<ExtArgs> | null
  }


  /**
   * Model DetalleFactura
   */

  export type AggregateDetalleFactura = {
    _count: DetalleFacturaCountAggregateOutputType | null
    _avg: DetalleFacturaAvgAggregateOutputType | null
    _sum: DetalleFacturaSumAggregateOutputType | null
    _min: DetalleFacturaMinAggregateOutputType | null
    _max: DetalleFacturaMaxAggregateOutputType | null
  }

  export type DetalleFacturaAvgAggregateOutputType = {
    id: number | null
    id_curso: number | null
    id_encabezadofactura: number | null
    precio_unitario: number | null
  }

  export type DetalleFacturaSumAggregateOutputType = {
    id: number | null
    id_curso: number | null
    id_encabezadofactura: number | null
    precio_unitario: number | null
  }

  export type DetalleFacturaMinAggregateOutputType = {
    id: number | null
    id_curso: number | null
    id_encabezadofactura: number | null
    precio_unitario: number | null
  }

  export type DetalleFacturaMaxAggregateOutputType = {
    id: number | null
    id_curso: number | null
    id_encabezadofactura: number | null
    precio_unitario: number | null
  }

  export type DetalleFacturaCountAggregateOutputType = {
    id: number
    id_curso: number
    id_encabezadofactura: number
    precio_unitario: number
    _all: number
  }


  export type DetalleFacturaAvgAggregateInputType = {
    id?: true
    id_curso?: true
    id_encabezadofactura?: true
    precio_unitario?: true
  }

  export type DetalleFacturaSumAggregateInputType = {
    id?: true
    id_curso?: true
    id_encabezadofactura?: true
    precio_unitario?: true
  }

  export type DetalleFacturaMinAggregateInputType = {
    id?: true
    id_curso?: true
    id_encabezadofactura?: true
    precio_unitario?: true
  }

  export type DetalleFacturaMaxAggregateInputType = {
    id?: true
    id_curso?: true
    id_encabezadofactura?: true
    precio_unitario?: true
  }

  export type DetalleFacturaCountAggregateInputType = {
    id?: true
    id_curso?: true
    id_encabezadofactura?: true
    precio_unitario?: true
    _all?: true
  }

  export type DetalleFacturaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetalleFactura to aggregate.
     */
    where?: DetalleFacturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleFacturas to fetch.
     */
    orderBy?: DetalleFacturaOrderByWithRelationInput | DetalleFacturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetalleFacturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleFacturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleFacturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetalleFacturas
    **/
    _count?: true | DetalleFacturaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetalleFacturaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetalleFacturaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetalleFacturaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetalleFacturaMaxAggregateInputType
  }

  export type GetDetalleFacturaAggregateType<T extends DetalleFacturaAggregateArgs> = {
        [P in keyof T & keyof AggregateDetalleFactura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetalleFactura[P]>
      : GetScalarType<T[P], AggregateDetalleFactura[P]>
  }




  export type DetalleFacturaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetalleFacturaWhereInput
    orderBy?: DetalleFacturaOrderByWithAggregationInput | DetalleFacturaOrderByWithAggregationInput[]
    by: DetalleFacturaScalarFieldEnum[] | DetalleFacturaScalarFieldEnum
    having?: DetalleFacturaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetalleFacturaCountAggregateInputType | true
    _avg?: DetalleFacturaAvgAggregateInputType
    _sum?: DetalleFacturaSumAggregateInputType
    _min?: DetalleFacturaMinAggregateInputType
    _max?: DetalleFacturaMaxAggregateInputType
  }

  export type DetalleFacturaGroupByOutputType = {
    id: number
    id_curso: number
    id_encabezadofactura: number
    precio_unitario: number
    _count: DetalleFacturaCountAggregateOutputType | null
    _avg: DetalleFacturaAvgAggregateOutputType | null
    _sum: DetalleFacturaSumAggregateOutputType | null
    _min: DetalleFacturaMinAggregateOutputType | null
    _max: DetalleFacturaMaxAggregateOutputType | null
  }

  type GetDetalleFacturaGroupByPayload<T extends DetalleFacturaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetalleFacturaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetalleFacturaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetalleFacturaGroupByOutputType[P]>
            : GetScalarType<T[P], DetalleFacturaGroupByOutputType[P]>
        }
      >
    >


  export type DetalleFacturaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_curso?: boolean
    id_encabezadofactura?: boolean
    precio_unitario?: boolean
    Curso?: boolean | CursoDefaultArgs<ExtArgs>
    EncabezadoFactura?: boolean | EncabezadoFacturaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detalleFactura"]>



  export type DetalleFacturaSelectScalar = {
    id?: boolean
    id_curso?: boolean
    id_encabezadofactura?: boolean
    precio_unitario?: boolean
  }

  export type DetalleFacturaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_curso" | "id_encabezadofactura" | "precio_unitario", ExtArgs["result"]["detalleFactura"]>
  export type DetalleFacturaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Curso?: boolean | CursoDefaultArgs<ExtArgs>
    EncabezadoFactura?: boolean | EncabezadoFacturaDefaultArgs<ExtArgs>
  }

  export type $DetalleFacturaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetalleFactura"
    objects: {
      Curso: Prisma.$CursoPayload<ExtArgs>
      EncabezadoFactura: Prisma.$EncabezadoFacturaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_curso: number
      id_encabezadofactura: number
      precio_unitario: number
    }, ExtArgs["result"]["detalleFactura"]>
    composites: {}
  }

  type DetalleFacturaGetPayload<S extends boolean | null | undefined | DetalleFacturaDefaultArgs> = $Result.GetResult<Prisma.$DetalleFacturaPayload, S>

  type DetalleFacturaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DetalleFacturaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DetalleFacturaCountAggregateInputType | true
    }

  export interface DetalleFacturaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetalleFactura'], meta: { name: 'DetalleFactura' } }
    /**
     * Find zero or one DetalleFactura that matches the filter.
     * @param {DetalleFacturaFindUniqueArgs} args - Arguments to find a DetalleFactura
     * @example
     * // Get one DetalleFactura
     * const detalleFactura = await prisma.detalleFactura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DetalleFacturaFindUniqueArgs>(args: SelectSubset<T, DetalleFacturaFindUniqueArgs<ExtArgs>>): Prisma__DetalleFacturaClient<$Result.GetResult<Prisma.$DetalleFacturaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DetalleFactura that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DetalleFacturaFindUniqueOrThrowArgs} args - Arguments to find a DetalleFactura
     * @example
     * // Get one DetalleFactura
     * const detalleFactura = await prisma.detalleFactura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DetalleFacturaFindUniqueOrThrowArgs>(args: SelectSubset<T, DetalleFacturaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DetalleFacturaClient<$Result.GetResult<Prisma.$DetalleFacturaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DetalleFactura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleFacturaFindFirstArgs} args - Arguments to find a DetalleFactura
     * @example
     * // Get one DetalleFactura
     * const detalleFactura = await prisma.detalleFactura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DetalleFacturaFindFirstArgs>(args?: SelectSubset<T, DetalleFacturaFindFirstArgs<ExtArgs>>): Prisma__DetalleFacturaClient<$Result.GetResult<Prisma.$DetalleFacturaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DetalleFactura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleFacturaFindFirstOrThrowArgs} args - Arguments to find a DetalleFactura
     * @example
     * // Get one DetalleFactura
     * const detalleFactura = await prisma.detalleFactura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DetalleFacturaFindFirstOrThrowArgs>(args?: SelectSubset<T, DetalleFacturaFindFirstOrThrowArgs<ExtArgs>>): Prisma__DetalleFacturaClient<$Result.GetResult<Prisma.$DetalleFacturaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DetalleFacturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleFacturaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetalleFacturas
     * const detalleFacturas = await prisma.detalleFactura.findMany()
     * 
     * // Get first 10 DetalleFacturas
     * const detalleFacturas = await prisma.detalleFactura.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detalleFacturaWithIdOnly = await prisma.detalleFactura.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DetalleFacturaFindManyArgs>(args?: SelectSubset<T, DetalleFacturaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetalleFacturaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DetalleFactura.
     * @param {DetalleFacturaCreateArgs} args - Arguments to create a DetalleFactura.
     * @example
     * // Create one DetalleFactura
     * const DetalleFactura = await prisma.detalleFactura.create({
     *   data: {
     *     // ... data to create a DetalleFactura
     *   }
     * })
     * 
     */
    create<T extends DetalleFacturaCreateArgs>(args: SelectSubset<T, DetalleFacturaCreateArgs<ExtArgs>>): Prisma__DetalleFacturaClient<$Result.GetResult<Prisma.$DetalleFacturaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DetalleFacturas.
     * @param {DetalleFacturaCreateManyArgs} args - Arguments to create many DetalleFacturas.
     * @example
     * // Create many DetalleFacturas
     * const detalleFactura = await prisma.detalleFactura.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DetalleFacturaCreateManyArgs>(args?: SelectSubset<T, DetalleFacturaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DetalleFactura.
     * @param {DetalleFacturaDeleteArgs} args - Arguments to delete one DetalleFactura.
     * @example
     * // Delete one DetalleFactura
     * const DetalleFactura = await prisma.detalleFactura.delete({
     *   where: {
     *     // ... filter to delete one DetalleFactura
     *   }
     * })
     * 
     */
    delete<T extends DetalleFacturaDeleteArgs>(args: SelectSubset<T, DetalleFacturaDeleteArgs<ExtArgs>>): Prisma__DetalleFacturaClient<$Result.GetResult<Prisma.$DetalleFacturaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DetalleFactura.
     * @param {DetalleFacturaUpdateArgs} args - Arguments to update one DetalleFactura.
     * @example
     * // Update one DetalleFactura
     * const detalleFactura = await prisma.detalleFactura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DetalleFacturaUpdateArgs>(args: SelectSubset<T, DetalleFacturaUpdateArgs<ExtArgs>>): Prisma__DetalleFacturaClient<$Result.GetResult<Prisma.$DetalleFacturaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DetalleFacturas.
     * @param {DetalleFacturaDeleteManyArgs} args - Arguments to filter DetalleFacturas to delete.
     * @example
     * // Delete a few DetalleFacturas
     * const { count } = await prisma.detalleFactura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DetalleFacturaDeleteManyArgs>(args?: SelectSubset<T, DetalleFacturaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetalleFacturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleFacturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetalleFacturas
     * const detalleFactura = await prisma.detalleFactura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DetalleFacturaUpdateManyArgs>(args: SelectSubset<T, DetalleFacturaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DetalleFactura.
     * @param {DetalleFacturaUpsertArgs} args - Arguments to update or create a DetalleFactura.
     * @example
     * // Update or create a DetalleFactura
     * const detalleFactura = await prisma.detalleFactura.upsert({
     *   create: {
     *     // ... data to create a DetalleFactura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetalleFactura we want to update
     *   }
     * })
     */
    upsert<T extends DetalleFacturaUpsertArgs>(args: SelectSubset<T, DetalleFacturaUpsertArgs<ExtArgs>>): Prisma__DetalleFacturaClient<$Result.GetResult<Prisma.$DetalleFacturaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DetalleFacturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleFacturaCountArgs} args - Arguments to filter DetalleFacturas to count.
     * @example
     * // Count the number of DetalleFacturas
     * const count = await prisma.detalleFactura.count({
     *   where: {
     *     // ... the filter for the DetalleFacturas we want to count
     *   }
     * })
    **/
    count<T extends DetalleFacturaCountArgs>(
      args?: Subset<T, DetalleFacturaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetalleFacturaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetalleFactura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleFacturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetalleFacturaAggregateArgs>(args: Subset<T, DetalleFacturaAggregateArgs>): Prisma.PrismaPromise<GetDetalleFacturaAggregateType<T>>

    /**
     * Group by DetalleFactura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetalleFacturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetalleFacturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetalleFacturaGroupByArgs['orderBy'] }
        : { orderBy?: DetalleFacturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetalleFacturaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetalleFacturaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetalleFactura model
   */
  readonly fields: DetalleFacturaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetalleFactura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetalleFacturaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Curso<T extends CursoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CursoDefaultArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    EncabezadoFactura<T extends EncabezadoFacturaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncabezadoFacturaDefaultArgs<ExtArgs>>): Prisma__EncabezadoFacturaClient<$Result.GetResult<Prisma.$EncabezadoFacturaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DetalleFactura model
   */ 
  interface DetalleFacturaFieldRefs {
    readonly id: FieldRef<"DetalleFactura", 'Int'>
    readonly id_curso: FieldRef<"DetalleFactura", 'Int'>
    readonly id_encabezadofactura: FieldRef<"DetalleFactura", 'Int'>
    readonly precio_unitario: FieldRef<"DetalleFactura", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * DetalleFactura findUnique
   */
  export type DetalleFacturaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleFactura
     */
    select?: DetalleFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleFactura
     */
    omit?: DetalleFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleFacturaInclude<ExtArgs> | null
    /**
     * Filter, which DetalleFactura to fetch.
     */
    where: DetalleFacturaWhereUniqueInput
  }

  /**
   * DetalleFactura findUniqueOrThrow
   */
  export type DetalleFacturaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleFactura
     */
    select?: DetalleFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleFactura
     */
    omit?: DetalleFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleFacturaInclude<ExtArgs> | null
    /**
     * Filter, which DetalleFactura to fetch.
     */
    where: DetalleFacturaWhereUniqueInput
  }

  /**
   * DetalleFactura findFirst
   */
  export type DetalleFacturaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleFactura
     */
    select?: DetalleFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleFactura
     */
    omit?: DetalleFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleFacturaInclude<ExtArgs> | null
    /**
     * Filter, which DetalleFactura to fetch.
     */
    where?: DetalleFacturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleFacturas to fetch.
     */
    orderBy?: DetalleFacturaOrderByWithRelationInput | DetalleFacturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetalleFacturas.
     */
    cursor?: DetalleFacturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleFacturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleFacturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetalleFacturas.
     */
    distinct?: DetalleFacturaScalarFieldEnum | DetalleFacturaScalarFieldEnum[]
  }

  /**
   * DetalleFactura findFirstOrThrow
   */
  export type DetalleFacturaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleFactura
     */
    select?: DetalleFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleFactura
     */
    omit?: DetalleFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleFacturaInclude<ExtArgs> | null
    /**
     * Filter, which DetalleFactura to fetch.
     */
    where?: DetalleFacturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleFacturas to fetch.
     */
    orderBy?: DetalleFacturaOrderByWithRelationInput | DetalleFacturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetalleFacturas.
     */
    cursor?: DetalleFacturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleFacturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleFacturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetalleFacturas.
     */
    distinct?: DetalleFacturaScalarFieldEnum | DetalleFacturaScalarFieldEnum[]
  }

  /**
   * DetalleFactura findMany
   */
  export type DetalleFacturaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleFactura
     */
    select?: DetalleFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleFactura
     */
    omit?: DetalleFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleFacturaInclude<ExtArgs> | null
    /**
     * Filter, which DetalleFacturas to fetch.
     */
    where?: DetalleFacturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetalleFacturas to fetch.
     */
    orderBy?: DetalleFacturaOrderByWithRelationInput | DetalleFacturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetalleFacturas.
     */
    cursor?: DetalleFacturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetalleFacturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetalleFacturas.
     */
    skip?: number
    distinct?: DetalleFacturaScalarFieldEnum | DetalleFacturaScalarFieldEnum[]
  }

  /**
   * DetalleFactura create
   */
  export type DetalleFacturaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleFactura
     */
    select?: DetalleFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleFactura
     */
    omit?: DetalleFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleFacturaInclude<ExtArgs> | null
    /**
     * The data needed to create a DetalleFactura.
     */
    data: XOR<DetalleFacturaCreateInput, DetalleFacturaUncheckedCreateInput>
  }

  /**
   * DetalleFactura createMany
   */
  export type DetalleFacturaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetalleFacturas.
     */
    data: DetalleFacturaCreateManyInput | DetalleFacturaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DetalleFactura update
   */
  export type DetalleFacturaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleFactura
     */
    select?: DetalleFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleFactura
     */
    omit?: DetalleFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleFacturaInclude<ExtArgs> | null
    /**
     * The data needed to update a DetalleFactura.
     */
    data: XOR<DetalleFacturaUpdateInput, DetalleFacturaUncheckedUpdateInput>
    /**
     * Choose, which DetalleFactura to update.
     */
    where: DetalleFacturaWhereUniqueInput
  }

  /**
   * DetalleFactura updateMany
   */
  export type DetalleFacturaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetalleFacturas.
     */
    data: XOR<DetalleFacturaUpdateManyMutationInput, DetalleFacturaUncheckedUpdateManyInput>
    /**
     * Filter which DetalleFacturas to update
     */
    where?: DetalleFacturaWhereInput
    /**
     * Limit how many DetalleFacturas to update.
     */
    limit?: number
  }

  /**
   * DetalleFactura upsert
   */
  export type DetalleFacturaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleFactura
     */
    select?: DetalleFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleFactura
     */
    omit?: DetalleFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleFacturaInclude<ExtArgs> | null
    /**
     * The filter to search for the DetalleFactura to update in case it exists.
     */
    where: DetalleFacturaWhereUniqueInput
    /**
     * In case the DetalleFactura found by the `where` argument doesn't exist, create a new DetalleFactura with this data.
     */
    create: XOR<DetalleFacturaCreateInput, DetalleFacturaUncheckedCreateInput>
    /**
     * In case the DetalleFactura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetalleFacturaUpdateInput, DetalleFacturaUncheckedUpdateInput>
  }

  /**
   * DetalleFactura delete
   */
  export type DetalleFacturaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleFactura
     */
    select?: DetalleFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleFactura
     */
    omit?: DetalleFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleFacturaInclude<ExtArgs> | null
    /**
     * Filter which DetalleFactura to delete.
     */
    where: DetalleFacturaWhereUniqueInput
  }

  /**
   * DetalleFactura deleteMany
   */
  export type DetalleFacturaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetalleFacturas to delete
     */
    where?: DetalleFacturaWhereInput
    /**
     * Limit how many DetalleFacturas to delete.
     */
    limit?: number
  }

  /**
   * DetalleFactura without action
   */
  export type DetalleFacturaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetalleFactura
     */
    select?: DetalleFacturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetalleFactura
     */
    omit?: DetalleFacturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetalleFacturaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CargoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type CargoScalarFieldEnum = (typeof CargoScalarFieldEnum)[keyof typeof CargoScalarFieldEnum]


  export const CarreraScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    especialidad: 'especialidad'
  };

  export type CarreraScalarFieldEnum = (typeof CarreraScalarFieldEnum)[keyof typeof CarreraScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    cedula: 'cedula',
    nombre: 'nombre',
    apellidos: 'apellidos',
    fecha_nacimiento: 'fecha_nacimiento',
    correo: 'correo',
    contrasena: 'contrasena',
    id_cargo: 'id_cargo',
    id_carrera: 'id_carrera'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const PlanEstudiosScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    anno: 'anno',
    id_carrera: 'id_carrera'
  };

  export type PlanEstudiosScalarFieldEnum = (typeof PlanEstudiosScalarFieldEnum)[keyof typeof PlanEstudiosScalarFieldEnum]


  export const CuatrimestreScalarFieldEnum: {
    id: 'id',
    numero_cuatrimestre: 'numero_cuatrimestre',
    anno: 'anno'
  };

  export type CuatrimestreScalarFieldEnum = (typeof CuatrimestreScalarFieldEnum)[keyof typeof CuatrimestreScalarFieldEnum]


  export const MateriaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    codigo: 'codigo',
    id_plan_estudios: 'id_plan_estudios'
  };

  export type MateriaScalarFieldEnum = (typeof MateriaScalarFieldEnum)[keyof typeof MateriaScalarFieldEnum]


  export const CursoScalarFieldEnum: {
    id: 'id',
    id_materia: 'id_materia',
    id_docente: 'id_docente',
    horario: 'horario',
    aula: 'aula',
    id_cuatrimestre: 'id_cuatrimestre'
  };

  export type CursoScalarFieldEnum = (typeof CursoScalarFieldEnum)[keyof typeof CursoScalarFieldEnum]


  export const MatriculaScalarFieldEnum: {
    id: 'id',
    id_usuario: 'id_usuario',
    id_curso: 'id_curso',
    fecha: 'fecha',
    estado: 'estado'
  };

  export type MatriculaScalarFieldEnum = (typeof MatriculaScalarFieldEnum)[keyof typeof MatriculaScalarFieldEnum]


  export const OfertaAcademicaScalarFieldEnum: {
    id: 'id',
    id_curso: 'id_curso',
    id_carrera: 'id_carrera',
    id_cuatrimestre: 'id_cuatrimestre',
    anno: 'anno'
  };

  export type OfertaAcademicaScalarFieldEnum = (typeof OfertaAcademicaScalarFieldEnum)[keyof typeof OfertaAcademicaScalarFieldEnum]


  export const HistoricoAcademicoScalarFieldEnum: {
    id: 'id',
    id_usuario: 'id_usuario',
    id_curso: 'id_curso',
    nota: 'nota'
  };

  export type HistoricoAcademicoScalarFieldEnum = (typeof HistoricoAcademicoScalarFieldEnum)[keyof typeof HistoricoAcademicoScalarFieldEnum]


  export const AuditoriaScalarFieldEnum: {
    id: 'id',
    id_usuario: 'id_usuario',
    accion: 'accion',
    fecha_hora: 'fecha_hora',
    descripcion: 'descripcion'
  };

  export type AuditoriaScalarFieldEnum = (typeof AuditoriaScalarFieldEnum)[keyof typeof AuditoriaScalarFieldEnum]


  export const EncabezadoFacturaScalarFieldEnum: {
    id: 'id',
    id_cuatrimestre: 'id_cuatrimestre',
    id_carrera: 'id_carrera',
    id_usuario: 'id_usuario',
    fecha_hora: 'fecha_hora'
  };

  export type EncabezadoFacturaScalarFieldEnum = (typeof EncabezadoFacturaScalarFieldEnum)[keyof typeof EncabezadoFacturaScalarFieldEnum]


  export const DetalleFacturaScalarFieldEnum: {
    id: 'id',
    id_curso: 'id_curso',
    id_encabezadofactura: 'id_encabezadofactura',
    precio_unitario: 'precio_unitario'
  };

  export type DetalleFacturaScalarFieldEnum = (typeof DetalleFacturaScalarFieldEnum)[keyof typeof DetalleFacturaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const CargoOrderByRelevanceFieldEnum: {
    nombre: 'nombre'
  };

  export type CargoOrderByRelevanceFieldEnum = (typeof CargoOrderByRelevanceFieldEnum)[keyof typeof CargoOrderByRelevanceFieldEnum]


  export const CarreraOrderByRelevanceFieldEnum: {
    nombre: 'nombre',
    especialidad: 'especialidad'
  };

  export type CarreraOrderByRelevanceFieldEnum = (typeof CarreraOrderByRelevanceFieldEnum)[keyof typeof CarreraOrderByRelevanceFieldEnum]


  export const UsuarioOrderByRelevanceFieldEnum: {
    cedula: 'cedula',
    nombre: 'nombre',
    apellidos: 'apellidos',
    fecha_nacimiento: 'fecha_nacimiento',
    correo: 'correo',
    contrasena: 'contrasena'
  };

  export type UsuarioOrderByRelevanceFieldEnum = (typeof UsuarioOrderByRelevanceFieldEnum)[keyof typeof UsuarioOrderByRelevanceFieldEnum]


  export const PlanEstudiosOrderByRelevanceFieldEnum: {
    nombre: 'nombre'
  };

  export type PlanEstudiosOrderByRelevanceFieldEnum = (typeof PlanEstudiosOrderByRelevanceFieldEnum)[keyof typeof PlanEstudiosOrderByRelevanceFieldEnum]


  export const MateriaOrderByRelevanceFieldEnum: {
    nombre: 'nombre',
    codigo: 'codigo'
  };

  export type MateriaOrderByRelevanceFieldEnum = (typeof MateriaOrderByRelevanceFieldEnum)[keyof typeof MateriaOrderByRelevanceFieldEnum]


  export const CursoOrderByRelevanceFieldEnum: {
    horario: 'horario',
    aula: 'aula'
  };

  export type CursoOrderByRelevanceFieldEnum = (typeof CursoOrderByRelevanceFieldEnum)[keyof typeof CursoOrderByRelevanceFieldEnum]


  export const MatriculaOrderByRelevanceFieldEnum: {
    estado: 'estado'
  };

  export type MatriculaOrderByRelevanceFieldEnum = (typeof MatriculaOrderByRelevanceFieldEnum)[keyof typeof MatriculaOrderByRelevanceFieldEnum]


  export const OfertaAcademicaOrderByRelevanceFieldEnum: {
    anno: 'anno'
  };

  export type OfertaAcademicaOrderByRelevanceFieldEnum = (typeof OfertaAcademicaOrderByRelevanceFieldEnum)[keyof typeof OfertaAcademicaOrderByRelevanceFieldEnum]


  export const AuditoriaOrderByRelevanceFieldEnum: {
    accion: 'accion',
    descripcion: 'descripcion'
  };

  export type AuditoriaOrderByRelevanceFieldEnum = (typeof AuditoriaOrderByRelevanceFieldEnum)[keyof typeof AuditoriaOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type CargoWhereInput = {
    AND?: CargoWhereInput | CargoWhereInput[]
    OR?: CargoWhereInput[]
    NOT?: CargoWhereInput | CargoWhereInput[]
    id?: IntFilter<"Cargo"> | number
    nombre?: StringFilter<"Cargo"> | string
    Usuario?: UsuarioListRelationFilter
  }

  export type CargoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    Usuario?: UsuarioOrderByRelationAggregateInput
    _relevance?: CargoOrderByRelevanceInput
  }

  export type CargoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: CargoWhereInput | CargoWhereInput[]
    OR?: CargoWhereInput[]
    NOT?: CargoWhereInput | CargoWhereInput[]
    Usuario?: UsuarioListRelationFilter
  }, "id" | "nombre">

  export type CargoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: CargoCountOrderByAggregateInput
    _avg?: CargoAvgOrderByAggregateInput
    _max?: CargoMaxOrderByAggregateInput
    _min?: CargoMinOrderByAggregateInput
    _sum?: CargoSumOrderByAggregateInput
  }

  export type CargoScalarWhereWithAggregatesInput = {
    AND?: CargoScalarWhereWithAggregatesInput | CargoScalarWhereWithAggregatesInput[]
    OR?: CargoScalarWhereWithAggregatesInput[]
    NOT?: CargoScalarWhereWithAggregatesInput | CargoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cargo"> | number
    nombre?: StringWithAggregatesFilter<"Cargo"> | string
  }

  export type CarreraWhereInput = {
    AND?: CarreraWhereInput | CarreraWhereInput[]
    OR?: CarreraWhereInput[]
    NOT?: CarreraWhereInput | CarreraWhereInput[]
    id?: IntFilter<"Carrera"> | number
    nombre?: StringFilter<"Carrera"> | string
    especialidad?: StringFilter<"Carrera"> | string
    OfertaAcademica?: OfertaAcademicaListRelationFilter
    PlanEstudios?: PlanEstudiosListRelationFilter
    Usuario?: UsuarioListRelationFilter
    EncabezadoFactura?: EncabezadoFacturaListRelationFilter
  }

  export type CarreraOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    especialidad?: SortOrder
    OfertaAcademica?: OfertaAcademicaOrderByRelationAggregateInput
    PlanEstudios?: PlanEstudiosOrderByRelationAggregateInput
    Usuario?: UsuarioOrderByRelationAggregateInput
    EncabezadoFactura?: EncabezadoFacturaOrderByRelationAggregateInput
    _relevance?: CarreraOrderByRelevanceInput
  }

  export type CarreraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CarreraWhereInput | CarreraWhereInput[]
    OR?: CarreraWhereInput[]
    NOT?: CarreraWhereInput | CarreraWhereInput[]
    nombre?: StringFilter<"Carrera"> | string
    especialidad?: StringFilter<"Carrera"> | string
    OfertaAcademica?: OfertaAcademicaListRelationFilter
    PlanEstudios?: PlanEstudiosListRelationFilter
    Usuario?: UsuarioListRelationFilter
    EncabezadoFactura?: EncabezadoFacturaListRelationFilter
  }, "id">

  export type CarreraOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    especialidad?: SortOrder
    _count?: CarreraCountOrderByAggregateInput
    _avg?: CarreraAvgOrderByAggregateInput
    _max?: CarreraMaxOrderByAggregateInput
    _min?: CarreraMinOrderByAggregateInput
    _sum?: CarreraSumOrderByAggregateInput
  }

  export type CarreraScalarWhereWithAggregatesInput = {
    AND?: CarreraScalarWhereWithAggregatesInput | CarreraScalarWhereWithAggregatesInput[]
    OR?: CarreraScalarWhereWithAggregatesInput[]
    NOT?: CarreraScalarWhereWithAggregatesInput | CarreraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Carrera"> | number
    nombre?: StringWithAggregatesFilter<"Carrera"> | string
    especialidad?: StringWithAggregatesFilter<"Carrera"> | string
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    cedula?: StringFilter<"Usuario"> | string
    nombre?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    fecha_nacimiento?: StringFilter<"Usuario"> | string
    correo?: StringFilter<"Usuario"> | string
    contrasena?: StringFilter<"Usuario"> | string
    id_cargo?: IntFilter<"Usuario"> | number
    id_carrera?: IntFilter<"Usuario"> | number
    Cargo?: XOR<CargoScalarRelationFilter, CargoWhereInput>
    Carrera?: XOR<CarreraScalarRelationFilter, CarreraWhereInput>
    Curso?: CursoListRelationFilter
    HistoricoAcademico?: HistoricoAcademicoListRelationFilter
    Auditoria?: AuditoriaListRelationFilter
    EncabezadoFactura?: EncabezadoFacturaListRelationFilter
    Matricula?: MatriculaListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    fecha_nacimiento?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    id_cargo?: SortOrder
    id_carrera?: SortOrder
    Cargo?: CargoOrderByWithRelationInput
    Carrera?: CarreraOrderByWithRelationInput
    Curso?: CursoOrderByRelationAggregateInput
    HistoricoAcademico?: HistoricoAcademicoOrderByRelationAggregateInput
    Auditoria?: AuditoriaOrderByRelationAggregateInput
    EncabezadoFactura?: EncabezadoFacturaOrderByRelationAggregateInput
    Matricula?: MatriculaOrderByRelationAggregateInput
    _relevance?: UsuarioOrderByRelevanceInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cedula?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    fecha_nacimiento?: StringFilter<"Usuario"> | string
    correo?: StringFilter<"Usuario"> | string
    contrasena?: StringFilter<"Usuario"> | string
    id_cargo?: IntFilter<"Usuario"> | number
    id_carrera?: IntFilter<"Usuario"> | number
    Cargo?: XOR<CargoScalarRelationFilter, CargoWhereInput>
    Carrera?: XOR<CarreraScalarRelationFilter, CarreraWhereInput>
    Curso?: CursoListRelationFilter
    HistoricoAcademico?: HistoricoAcademicoListRelationFilter
    Auditoria?: AuditoriaListRelationFilter
    EncabezadoFactura?: EncabezadoFacturaListRelationFilter
    Matricula?: MatriculaListRelationFilter
  }, "id" | "cedula">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    fecha_nacimiento?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    id_cargo?: SortOrder
    id_carrera?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    cedula?: StringWithAggregatesFilter<"Usuario"> | string
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    apellidos?: StringWithAggregatesFilter<"Usuario"> | string
    fecha_nacimiento?: StringWithAggregatesFilter<"Usuario"> | string
    correo?: StringWithAggregatesFilter<"Usuario"> | string
    contrasena?: StringWithAggregatesFilter<"Usuario"> | string
    id_cargo?: IntWithAggregatesFilter<"Usuario"> | number
    id_carrera?: IntWithAggregatesFilter<"Usuario"> | number
  }

  export type PlanEstudiosWhereInput = {
    AND?: PlanEstudiosWhereInput | PlanEstudiosWhereInput[]
    OR?: PlanEstudiosWhereInput[]
    NOT?: PlanEstudiosWhereInput | PlanEstudiosWhereInput[]
    id?: IntFilter<"PlanEstudios"> | number
    nombre?: StringFilter<"PlanEstudios"> | string
    anno?: IntFilter<"PlanEstudios"> | number
    id_carrera?: IntFilter<"PlanEstudios"> | number
    Carrera?: XOR<CarreraScalarRelationFilter, CarreraWhereInput>
    Materia?: MateriaListRelationFilter
  }

  export type PlanEstudiosOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    anno?: SortOrder
    id_carrera?: SortOrder
    Carrera?: CarreraOrderByWithRelationInput
    Materia?: MateriaOrderByRelationAggregateInput
    _relevance?: PlanEstudiosOrderByRelevanceInput
  }

  export type PlanEstudiosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlanEstudiosWhereInput | PlanEstudiosWhereInput[]
    OR?: PlanEstudiosWhereInput[]
    NOT?: PlanEstudiosWhereInput | PlanEstudiosWhereInput[]
    nombre?: StringFilter<"PlanEstudios"> | string
    anno?: IntFilter<"PlanEstudios"> | number
    id_carrera?: IntFilter<"PlanEstudios"> | number
    Carrera?: XOR<CarreraScalarRelationFilter, CarreraWhereInput>
    Materia?: MateriaListRelationFilter
  }, "id">

  export type PlanEstudiosOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    anno?: SortOrder
    id_carrera?: SortOrder
    _count?: PlanEstudiosCountOrderByAggregateInput
    _avg?: PlanEstudiosAvgOrderByAggregateInput
    _max?: PlanEstudiosMaxOrderByAggregateInput
    _min?: PlanEstudiosMinOrderByAggregateInput
    _sum?: PlanEstudiosSumOrderByAggregateInput
  }

  export type PlanEstudiosScalarWhereWithAggregatesInput = {
    AND?: PlanEstudiosScalarWhereWithAggregatesInput | PlanEstudiosScalarWhereWithAggregatesInput[]
    OR?: PlanEstudiosScalarWhereWithAggregatesInput[]
    NOT?: PlanEstudiosScalarWhereWithAggregatesInput | PlanEstudiosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlanEstudios"> | number
    nombre?: StringWithAggregatesFilter<"PlanEstudios"> | string
    anno?: IntWithAggregatesFilter<"PlanEstudios"> | number
    id_carrera?: IntWithAggregatesFilter<"PlanEstudios"> | number
  }

  export type CuatrimestreWhereInput = {
    AND?: CuatrimestreWhereInput | CuatrimestreWhereInput[]
    OR?: CuatrimestreWhereInput[]
    NOT?: CuatrimestreWhereInput | CuatrimestreWhereInput[]
    id?: IntFilter<"Cuatrimestre"> | number
    numero_cuatrimestre?: IntFilter<"Cuatrimestre"> | number
    anno?: IntFilter<"Cuatrimestre"> | number
    OfertaAcademica?: OfertaAcademicaListRelationFilter
    Curso?: CursoListRelationFilter
    EncabezadoFactura?: EncabezadoFacturaListRelationFilter
  }

  export type CuatrimestreOrderByWithRelationInput = {
    id?: SortOrder
    numero_cuatrimestre?: SortOrder
    anno?: SortOrder
    OfertaAcademica?: OfertaAcademicaOrderByRelationAggregateInput
    Curso?: CursoOrderByRelationAggregateInput
    EncabezadoFactura?: EncabezadoFacturaOrderByRelationAggregateInput
  }

  export type CuatrimestreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CuatrimestreWhereInput | CuatrimestreWhereInput[]
    OR?: CuatrimestreWhereInput[]
    NOT?: CuatrimestreWhereInput | CuatrimestreWhereInput[]
    numero_cuatrimestre?: IntFilter<"Cuatrimestre"> | number
    anno?: IntFilter<"Cuatrimestre"> | number
    OfertaAcademica?: OfertaAcademicaListRelationFilter
    Curso?: CursoListRelationFilter
    EncabezadoFactura?: EncabezadoFacturaListRelationFilter
  }, "id">

  export type CuatrimestreOrderByWithAggregationInput = {
    id?: SortOrder
    numero_cuatrimestre?: SortOrder
    anno?: SortOrder
    _count?: CuatrimestreCountOrderByAggregateInput
    _avg?: CuatrimestreAvgOrderByAggregateInput
    _max?: CuatrimestreMaxOrderByAggregateInput
    _min?: CuatrimestreMinOrderByAggregateInput
    _sum?: CuatrimestreSumOrderByAggregateInput
  }

  export type CuatrimestreScalarWhereWithAggregatesInput = {
    AND?: CuatrimestreScalarWhereWithAggregatesInput | CuatrimestreScalarWhereWithAggregatesInput[]
    OR?: CuatrimestreScalarWhereWithAggregatesInput[]
    NOT?: CuatrimestreScalarWhereWithAggregatesInput | CuatrimestreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cuatrimestre"> | number
    numero_cuatrimestre?: IntWithAggregatesFilter<"Cuatrimestre"> | number
    anno?: IntWithAggregatesFilter<"Cuatrimestre"> | number
  }

  export type MateriaWhereInput = {
    AND?: MateriaWhereInput | MateriaWhereInput[]
    OR?: MateriaWhereInput[]
    NOT?: MateriaWhereInput | MateriaWhereInput[]
    id?: IntFilter<"Materia"> | number
    nombre?: StringFilter<"Materia"> | string
    codigo?: StringFilter<"Materia"> | string
    id_plan_estudios?: IntFilter<"Materia"> | number
    PlanEstudios?: XOR<PlanEstudiosScalarRelationFilter, PlanEstudiosWhereInput>
    Curso?: CursoListRelationFilter
  }

  export type MateriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    id_plan_estudios?: SortOrder
    PlanEstudios?: PlanEstudiosOrderByWithRelationInput
    Curso?: CursoOrderByRelationAggregateInput
    _relevance?: MateriaOrderByRelevanceInput
  }

  export type MateriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigo?: string
    AND?: MateriaWhereInput | MateriaWhereInput[]
    OR?: MateriaWhereInput[]
    NOT?: MateriaWhereInput | MateriaWhereInput[]
    nombre?: StringFilter<"Materia"> | string
    id_plan_estudios?: IntFilter<"Materia"> | number
    PlanEstudios?: XOR<PlanEstudiosScalarRelationFilter, PlanEstudiosWhereInput>
    Curso?: CursoListRelationFilter
  }, "id" | "codigo">

  export type MateriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    id_plan_estudios?: SortOrder
    _count?: MateriaCountOrderByAggregateInput
    _avg?: MateriaAvgOrderByAggregateInput
    _max?: MateriaMaxOrderByAggregateInput
    _min?: MateriaMinOrderByAggregateInput
    _sum?: MateriaSumOrderByAggregateInput
  }

  export type MateriaScalarWhereWithAggregatesInput = {
    AND?: MateriaScalarWhereWithAggregatesInput | MateriaScalarWhereWithAggregatesInput[]
    OR?: MateriaScalarWhereWithAggregatesInput[]
    NOT?: MateriaScalarWhereWithAggregatesInput | MateriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Materia"> | number
    nombre?: StringWithAggregatesFilter<"Materia"> | string
    codigo?: StringWithAggregatesFilter<"Materia"> | string
    id_plan_estudios?: IntWithAggregatesFilter<"Materia"> | number
  }

  export type CursoWhereInput = {
    AND?: CursoWhereInput | CursoWhereInput[]
    OR?: CursoWhereInput[]
    NOT?: CursoWhereInput | CursoWhereInput[]
    id?: IntFilter<"Curso"> | number
    id_materia?: IntFilter<"Curso"> | number
    id_docente?: IntFilter<"Curso"> | number
    horario?: StringFilter<"Curso"> | string
    aula?: StringFilter<"Curso"> | string
    id_cuatrimestre?: IntFilter<"Curso"> | number
    Materia?: XOR<MateriaScalarRelationFilter, MateriaWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Cuatrimestre?: XOR<CuatrimestreScalarRelationFilter, CuatrimestreWhereInput>
    DetalleFactura?: DetalleFacturaListRelationFilter
    OfertaAcademica?: OfertaAcademicaListRelationFilter
    HistoricoAcademico?: HistoricoAcademicoListRelationFilter
    CuMatricula?: MatriculaListRelationFilter
  }

  export type CursoOrderByWithRelationInput = {
    id?: SortOrder
    id_materia?: SortOrder
    id_docente?: SortOrder
    horario?: SortOrder
    aula?: SortOrder
    id_cuatrimestre?: SortOrder
    Materia?: MateriaOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
    Cuatrimestre?: CuatrimestreOrderByWithRelationInput
    DetalleFactura?: DetalleFacturaOrderByRelationAggregateInput
    OfertaAcademica?: OfertaAcademicaOrderByRelationAggregateInput
    HistoricoAcademico?: HistoricoAcademicoOrderByRelationAggregateInput
    CuMatricula?: MatriculaOrderByRelationAggregateInput
    _relevance?: CursoOrderByRelevanceInput
  }

  export type CursoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CursoWhereInput | CursoWhereInput[]
    OR?: CursoWhereInput[]
    NOT?: CursoWhereInput | CursoWhereInput[]
    id_materia?: IntFilter<"Curso"> | number
    id_docente?: IntFilter<"Curso"> | number
    horario?: StringFilter<"Curso"> | string
    aula?: StringFilter<"Curso"> | string
    id_cuatrimestre?: IntFilter<"Curso"> | number
    Materia?: XOR<MateriaScalarRelationFilter, MateriaWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Cuatrimestre?: XOR<CuatrimestreScalarRelationFilter, CuatrimestreWhereInput>
    DetalleFactura?: DetalleFacturaListRelationFilter
    OfertaAcademica?: OfertaAcademicaListRelationFilter
    HistoricoAcademico?: HistoricoAcademicoListRelationFilter
    CuMatricula?: MatriculaListRelationFilter
  }, "id">

  export type CursoOrderByWithAggregationInput = {
    id?: SortOrder
    id_materia?: SortOrder
    id_docente?: SortOrder
    horario?: SortOrder
    aula?: SortOrder
    id_cuatrimestre?: SortOrder
    _count?: CursoCountOrderByAggregateInput
    _avg?: CursoAvgOrderByAggregateInput
    _max?: CursoMaxOrderByAggregateInput
    _min?: CursoMinOrderByAggregateInput
    _sum?: CursoSumOrderByAggregateInput
  }

  export type CursoScalarWhereWithAggregatesInput = {
    AND?: CursoScalarWhereWithAggregatesInput | CursoScalarWhereWithAggregatesInput[]
    OR?: CursoScalarWhereWithAggregatesInput[]
    NOT?: CursoScalarWhereWithAggregatesInput | CursoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Curso"> | number
    id_materia?: IntWithAggregatesFilter<"Curso"> | number
    id_docente?: IntWithAggregatesFilter<"Curso"> | number
    horario?: StringWithAggregatesFilter<"Curso"> | string
    aula?: StringWithAggregatesFilter<"Curso"> | string
    id_cuatrimestre?: IntWithAggregatesFilter<"Curso"> | number
  }

  export type MatriculaWhereInput = {
    AND?: MatriculaWhereInput | MatriculaWhereInput[]
    OR?: MatriculaWhereInput[]
    NOT?: MatriculaWhereInput | MatriculaWhereInput[]
    id?: IntFilter<"Matricula"> | number
    id_usuario?: IntFilter<"Matricula"> | number
    id_curso?: IntFilter<"Matricula"> | number
    fecha?: DateTimeFilter<"Matricula"> | Date | string
    estado?: StringFilter<"Matricula"> | string
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Curso?: XOR<CursoScalarRelationFilter, CursoWhereInput>
  }

  export type MatriculaOrderByWithRelationInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
    Curso?: CursoOrderByWithRelationInput
    _relevance?: MatriculaOrderByRelevanceInput
  }

  export type MatriculaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MatriculaWhereInput | MatriculaWhereInput[]
    OR?: MatriculaWhereInput[]
    NOT?: MatriculaWhereInput | MatriculaWhereInput[]
    id_usuario?: IntFilter<"Matricula"> | number
    id_curso?: IntFilter<"Matricula"> | number
    fecha?: DateTimeFilter<"Matricula"> | Date | string
    estado?: StringFilter<"Matricula"> | string
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Curso?: XOR<CursoScalarRelationFilter, CursoWhereInput>
  }, "id">

  export type MatriculaOrderByWithAggregationInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    _count?: MatriculaCountOrderByAggregateInput
    _avg?: MatriculaAvgOrderByAggregateInput
    _max?: MatriculaMaxOrderByAggregateInput
    _min?: MatriculaMinOrderByAggregateInput
    _sum?: MatriculaSumOrderByAggregateInput
  }

  export type MatriculaScalarWhereWithAggregatesInput = {
    AND?: MatriculaScalarWhereWithAggregatesInput | MatriculaScalarWhereWithAggregatesInput[]
    OR?: MatriculaScalarWhereWithAggregatesInput[]
    NOT?: MatriculaScalarWhereWithAggregatesInput | MatriculaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Matricula"> | number
    id_usuario?: IntWithAggregatesFilter<"Matricula"> | number
    id_curso?: IntWithAggregatesFilter<"Matricula"> | number
    fecha?: DateTimeWithAggregatesFilter<"Matricula"> | Date | string
    estado?: StringWithAggregatesFilter<"Matricula"> | string
  }

  export type OfertaAcademicaWhereInput = {
    AND?: OfertaAcademicaWhereInput | OfertaAcademicaWhereInput[]
    OR?: OfertaAcademicaWhereInput[]
    NOT?: OfertaAcademicaWhereInput | OfertaAcademicaWhereInput[]
    id?: IntFilter<"OfertaAcademica"> | number
    id_curso?: IntFilter<"OfertaAcademica"> | number
    id_carrera?: IntFilter<"OfertaAcademica"> | number
    id_cuatrimestre?: IntFilter<"OfertaAcademica"> | number
    anno?: StringFilter<"OfertaAcademica"> | string
    Curso?: XOR<CursoScalarRelationFilter, CursoWhereInput>
    Cuatrimestre?: XOR<CuatrimestreScalarRelationFilter, CuatrimestreWhereInput>
    Carrera?: XOR<CarreraScalarRelationFilter, CarreraWhereInput>
  }

  export type OfertaAcademicaOrderByWithRelationInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_carrera?: SortOrder
    id_cuatrimestre?: SortOrder
    anno?: SortOrder
    Curso?: CursoOrderByWithRelationInput
    Cuatrimestre?: CuatrimestreOrderByWithRelationInput
    Carrera?: CarreraOrderByWithRelationInput
    _relevance?: OfertaAcademicaOrderByRelevanceInput
  }

  export type OfertaAcademicaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OfertaAcademicaWhereInput | OfertaAcademicaWhereInput[]
    OR?: OfertaAcademicaWhereInput[]
    NOT?: OfertaAcademicaWhereInput | OfertaAcademicaWhereInput[]
    id_curso?: IntFilter<"OfertaAcademica"> | number
    id_carrera?: IntFilter<"OfertaAcademica"> | number
    id_cuatrimestre?: IntFilter<"OfertaAcademica"> | number
    anno?: StringFilter<"OfertaAcademica"> | string
    Curso?: XOR<CursoScalarRelationFilter, CursoWhereInput>
    Cuatrimestre?: XOR<CuatrimestreScalarRelationFilter, CuatrimestreWhereInput>
    Carrera?: XOR<CarreraScalarRelationFilter, CarreraWhereInput>
  }, "id">

  export type OfertaAcademicaOrderByWithAggregationInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_carrera?: SortOrder
    id_cuatrimestre?: SortOrder
    anno?: SortOrder
    _count?: OfertaAcademicaCountOrderByAggregateInput
    _avg?: OfertaAcademicaAvgOrderByAggregateInput
    _max?: OfertaAcademicaMaxOrderByAggregateInput
    _min?: OfertaAcademicaMinOrderByAggregateInput
    _sum?: OfertaAcademicaSumOrderByAggregateInput
  }

  export type OfertaAcademicaScalarWhereWithAggregatesInput = {
    AND?: OfertaAcademicaScalarWhereWithAggregatesInput | OfertaAcademicaScalarWhereWithAggregatesInput[]
    OR?: OfertaAcademicaScalarWhereWithAggregatesInput[]
    NOT?: OfertaAcademicaScalarWhereWithAggregatesInput | OfertaAcademicaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OfertaAcademica"> | number
    id_curso?: IntWithAggregatesFilter<"OfertaAcademica"> | number
    id_carrera?: IntWithAggregatesFilter<"OfertaAcademica"> | number
    id_cuatrimestre?: IntWithAggregatesFilter<"OfertaAcademica"> | number
    anno?: StringWithAggregatesFilter<"OfertaAcademica"> | string
  }

  export type HistoricoAcademicoWhereInput = {
    AND?: HistoricoAcademicoWhereInput | HistoricoAcademicoWhereInput[]
    OR?: HistoricoAcademicoWhereInput[]
    NOT?: HistoricoAcademicoWhereInput | HistoricoAcademicoWhereInput[]
    id?: IntFilter<"HistoricoAcademico"> | number
    id_usuario?: IntFilter<"HistoricoAcademico"> | number
    id_curso?: IntFilter<"HistoricoAcademico"> | number
    nota?: FloatFilter<"HistoricoAcademico"> | number
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Curso?: XOR<CursoScalarRelationFilter, CursoWhereInput>
  }

  export type HistoricoAcademicoOrderByWithRelationInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
    nota?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
    Curso?: CursoOrderByWithRelationInput
  }

  export type HistoricoAcademicoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HistoricoAcademicoWhereInput | HistoricoAcademicoWhereInput[]
    OR?: HistoricoAcademicoWhereInput[]
    NOT?: HistoricoAcademicoWhereInput | HistoricoAcademicoWhereInput[]
    id_usuario?: IntFilter<"HistoricoAcademico"> | number
    id_curso?: IntFilter<"HistoricoAcademico"> | number
    nota?: FloatFilter<"HistoricoAcademico"> | number
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Curso?: XOR<CursoScalarRelationFilter, CursoWhereInput>
  }, "id">

  export type HistoricoAcademicoOrderByWithAggregationInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
    nota?: SortOrder
    _count?: HistoricoAcademicoCountOrderByAggregateInput
    _avg?: HistoricoAcademicoAvgOrderByAggregateInput
    _max?: HistoricoAcademicoMaxOrderByAggregateInput
    _min?: HistoricoAcademicoMinOrderByAggregateInput
    _sum?: HistoricoAcademicoSumOrderByAggregateInput
  }

  export type HistoricoAcademicoScalarWhereWithAggregatesInput = {
    AND?: HistoricoAcademicoScalarWhereWithAggregatesInput | HistoricoAcademicoScalarWhereWithAggregatesInput[]
    OR?: HistoricoAcademicoScalarWhereWithAggregatesInput[]
    NOT?: HistoricoAcademicoScalarWhereWithAggregatesInput | HistoricoAcademicoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HistoricoAcademico"> | number
    id_usuario?: IntWithAggregatesFilter<"HistoricoAcademico"> | number
    id_curso?: IntWithAggregatesFilter<"HistoricoAcademico"> | number
    nota?: FloatWithAggregatesFilter<"HistoricoAcademico"> | number
  }

  export type AuditoriaWhereInput = {
    AND?: AuditoriaWhereInput | AuditoriaWhereInput[]
    OR?: AuditoriaWhereInput[]
    NOT?: AuditoriaWhereInput | AuditoriaWhereInput[]
    id?: IntFilter<"Auditoria"> | number
    id_usuario?: IntFilter<"Auditoria"> | number
    accion?: StringFilter<"Auditoria"> | string
    fecha_hora?: DateTimeFilter<"Auditoria"> | Date | string
    descripcion?: StringFilter<"Auditoria"> | string
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type AuditoriaOrderByWithRelationInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    accion?: SortOrder
    fecha_hora?: SortOrder
    descripcion?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
    _relevance?: AuditoriaOrderByRelevanceInput
  }

  export type AuditoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditoriaWhereInput | AuditoriaWhereInput[]
    OR?: AuditoriaWhereInput[]
    NOT?: AuditoriaWhereInput | AuditoriaWhereInput[]
    id_usuario?: IntFilter<"Auditoria"> | number
    accion?: StringFilter<"Auditoria"> | string
    fecha_hora?: DateTimeFilter<"Auditoria"> | Date | string
    descripcion?: StringFilter<"Auditoria"> | string
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type AuditoriaOrderByWithAggregationInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    accion?: SortOrder
    fecha_hora?: SortOrder
    descripcion?: SortOrder
    _count?: AuditoriaCountOrderByAggregateInput
    _avg?: AuditoriaAvgOrderByAggregateInput
    _max?: AuditoriaMaxOrderByAggregateInput
    _min?: AuditoriaMinOrderByAggregateInput
    _sum?: AuditoriaSumOrderByAggregateInput
  }

  export type AuditoriaScalarWhereWithAggregatesInput = {
    AND?: AuditoriaScalarWhereWithAggregatesInput | AuditoriaScalarWhereWithAggregatesInput[]
    OR?: AuditoriaScalarWhereWithAggregatesInput[]
    NOT?: AuditoriaScalarWhereWithAggregatesInput | AuditoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Auditoria"> | number
    id_usuario?: IntWithAggregatesFilter<"Auditoria"> | number
    accion?: StringWithAggregatesFilter<"Auditoria"> | string
    fecha_hora?: DateTimeWithAggregatesFilter<"Auditoria"> | Date | string
    descripcion?: StringWithAggregatesFilter<"Auditoria"> | string
  }

  export type EncabezadoFacturaWhereInput = {
    AND?: EncabezadoFacturaWhereInput | EncabezadoFacturaWhereInput[]
    OR?: EncabezadoFacturaWhereInput[]
    NOT?: EncabezadoFacturaWhereInput | EncabezadoFacturaWhereInput[]
    id?: IntFilter<"EncabezadoFactura"> | number
    id_cuatrimestre?: IntFilter<"EncabezadoFactura"> | number
    id_carrera?: IntFilter<"EncabezadoFactura"> | number
    id_usuario?: IntFilter<"EncabezadoFactura"> | number
    fecha_hora?: DateTimeFilter<"EncabezadoFactura"> | Date | string
    Carrera?: XOR<CarreraScalarRelationFilter, CarreraWhereInput>
    Cuatrimestre?: XOR<CuatrimestreScalarRelationFilter, CuatrimestreWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    DetalleFactura?: DetalleFacturaListRelationFilter
  }

  export type EncabezadoFacturaOrderByWithRelationInput = {
    id?: SortOrder
    id_cuatrimestre?: SortOrder
    id_carrera?: SortOrder
    id_usuario?: SortOrder
    fecha_hora?: SortOrder
    Carrera?: CarreraOrderByWithRelationInput
    Cuatrimestre?: CuatrimestreOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
    DetalleFactura?: DetalleFacturaOrderByRelationAggregateInput
  }

  export type EncabezadoFacturaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncabezadoFacturaWhereInput | EncabezadoFacturaWhereInput[]
    OR?: EncabezadoFacturaWhereInput[]
    NOT?: EncabezadoFacturaWhereInput | EncabezadoFacturaWhereInput[]
    id_cuatrimestre?: IntFilter<"EncabezadoFactura"> | number
    id_carrera?: IntFilter<"EncabezadoFactura"> | number
    id_usuario?: IntFilter<"EncabezadoFactura"> | number
    fecha_hora?: DateTimeFilter<"EncabezadoFactura"> | Date | string
    Carrera?: XOR<CarreraScalarRelationFilter, CarreraWhereInput>
    Cuatrimestre?: XOR<CuatrimestreScalarRelationFilter, CuatrimestreWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    DetalleFactura?: DetalleFacturaListRelationFilter
  }, "id">

  export type EncabezadoFacturaOrderByWithAggregationInput = {
    id?: SortOrder
    id_cuatrimestre?: SortOrder
    id_carrera?: SortOrder
    id_usuario?: SortOrder
    fecha_hora?: SortOrder
    _count?: EncabezadoFacturaCountOrderByAggregateInput
    _avg?: EncabezadoFacturaAvgOrderByAggregateInput
    _max?: EncabezadoFacturaMaxOrderByAggregateInput
    _min?: EncabezadoFacturaMinOrderByAggregateInput
    _sum?: EncabezadoFacturaSumOrderByAggregateInput
  }

  export type EncabezadoFacturaScalarWhereWithAggregatesInput = {
    AND?: EncabezadoFacturaScalarWhereWithAggregatesInput | EncabezadoFacturaScalarWhereWithAggregatesInput[]
    OR?: EncabezadoFacturaScalarWhereWithAggregatesInput[]
    NOT?: EncabezadoFacturaScalarWhereWithAggregatesInput | EncabezadoFacturaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncabezadoFactura"> | number
    id_cuatrimestre?: IntWithAggregatesFilter<"EncabezadoFactura"> | number
    id_carrera?: IntWithAggregatesFilter<"EncabezadoFactura"> | number
    id_usuario?: IntWithAggregatesFilter<"EncabezadoFactura"> | number
    fecha_hora?: DateTimeWithAggregatesFilter<"EncabezadoFactura"> | Date | string
  }

  export type DetalleFacturaWhereInput = {
    AND?: DetalleFacturaWhereInput | DetalleFacturaWhereInput[]
    OR?: DetalleFacturaWhereInput[]
    NOT?: DetalleFacturaWhereInput | DetalleFacturaWhereInput[]
    id?: IntFilter<"DetalleFactura"> | number
    id_curso?: IntFilter<"DetalleFactura"> | number
    id_encabezadofactura?: IntFilter<"DetalleFactura"> | number
    precio_unitario?: FloatFilter<"DetalleFactura"> | number
    Curso?: XOR<CursoScalarRelationFilter, CursoWhereInput>
    EncabezadoFactura?: XOR<EncabezadoFacturaScalarRelationFilter, EncabezadoFacturaWhereInput>
  }

  export type DetalleFacturaOrderByWithRelationInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_encabezadofactura?: SortOrder
    precio_unitario?: SortOrder
    Curso?: CursoOrderByWithRelationInput
    EncabezadoFactura?: EncabezadoFacturaOrderByWithRelationInput
  }

  export type DetalleFacturaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DetalleFacturaWhereInput | DetalleFacturaWhereInput[]
    OR?: DetalleFacturaWhereInput[]
    NOT?: DetalleFacturaWhereInput | DetalleFacturaWhereInput[]
    id_curso?: IntFilter<"DetalleFactura"> | number
    id_encabezadofactura?: IntFilter<"DetalleFactura"> | number
    precio_unitario?: FloatFilter<"DetalleFactura"> | number
    Curso?: XOR<CursoScalarRelationFilter, CursoWhereInput>
    EncabezadoFactura?: XOR<EncabezadoFacturaScalarRelationFilter, EncabezadoFacturaWhereInput>
  }, "id">

  export type DetalleFacturaOrderByWithAggregationInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_encabezadofactura?: SortOrder
    precio_unitario?: SortOrder
    _count?: DetalleFacturaCountOrderByAggregateInput
    _avg?: DetalleFacturaAvgOrderByAggregateInput
    _max?: DetalleFacturaMaxOrderByAggregateInput
    _min?: DetalleFacturaMinOrderByAggregateInput
    _sum?: DetalleFacturaSumOrderByAggregateInput
  }

  export type DetalleFacturaScalarWhereWithAggregatesInput = {
    AND?: DetalleFacturaScalarWhereWithAggregatesInput | DetalleFacturaScalarWhereWithAggregatesInput[]
    OR?: DetalleFacturaScalarWhereWithAggregatesInput[]
    NOT?: DetalleFacturaScalarWhereWithAggregatesInput | DetalleFacturaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DetalleFactura"> | number
    id_curso?: IntWithAggregatesFilter<"DetalleFactura"> | number
    id_encabezadofactura?: IntWithAggregatesFilter<"DetalleFactura"> | number
    precio_unitario?: FloatWithAggregatesFilter<"DetalleFactura"> | number
  }

  export type CargoCreateInput = {
    nombre: string
    Usuario?: UsuarioCreateNestedManyWithoutCargoInput
  }

  export type CargoUncheckedCreateInput = {
    id?: number
    nombre: string
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutCargoInput
  }

  export type CargoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateManyWithoutCargoNestedInput
  }

  export type CargoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUncheckedUpdateManyWithoutCargoNestedInput
  }

  export type CargoCreateManyInput = {
    id?: number
    nombre: string
  }

  export type CargoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CargoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CarreraCreateInput = {
    nombre: string
    especialidad: string
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCarreraInput
    PlanEstudios?: PlanEstudiosCreateNestedManyWithoutCarreraInput
    Usuario?: UsuarioCreateNestedManyWithoutCarreraInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutCarreraInput
  }

  export type CarreraUncheckedCreateInput = {
    id?: number
    nombre: string
    especialidad: string
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCarreraInput
    PlanEstudios?: PlanEstudiosUncheckedCreateNestedManyWithoutCarreraInput
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutCarreraInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutCarreraInput
  }

  export type CarreraUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: StringFieldUpdateOperationsInput | string
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCarreraNestedInput
    PlanEstudios?: PlanEstudiosUpdateManyWithoutCarreraNestedInput
    Usuario?: UsuarioUpdateManyWithoutCarreraNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutCarreraNestedInput
  }

  export type CarreraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: StringFieldUpdateOperationsInput | string
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCarreraNestedInput
    PlanEstudios?: PlanEstudiosUncheckedUpdateManyWithoutCarreraNestedInput
    Usuario?: UsuarioUncheckedUpdateManyWithoutCarreraNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutCarreraNestedInput
  }

  export type CarreraCreateManyInput = {
    id?: number
    nombre: string
    especialidad: string
  }

  export type CarreraUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: StringFieldUpdateOperationsInput | string
  }

  export type CarreraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateInput = {
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    Cargo: CargoCreateNestedOneWithoutUsuarioInput
    Carrera: CarreraCreateNestedOneWithoutUsuarioInput
    Curso?: CursoCreateNestedManyWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    id_cargo: number
    id_carrera: number
    Curso?: CursoUncheckedCreateNestedManyWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    Cargo?: CargoUpdateOneRequiredWithoutUsuarioNestedInput
    Carrera?: CarreraUpdateOneRequiredWithoutUsuarioNestedInput
    Curso?: CursoUpdateManyWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    id_cargo?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    Curso?: CursoUncheckedUpdateManyWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    id_cargo: number
    id_carrera: number
  }

  export type UsuarioUpdateManyMutationInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    id_cargo?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
  }

  export type PlanEstudiosCreateInput = {
    nombre: string
    anno: number
    Carrera: CarreraCreateNestedOneWithoutPlanEstudiosInput
    Materia?: MateriaCreateNestedManyWithoutPlanEstudiosInput
  }

  export type PlanEstudiosUncheckedCreateInput = {
    id?: number
    nombre: string
    anno: number
    id_carrera: number
    Materia?: MateriaUncheckedCreateNestedManyWithoutPlanEstudiosInput
  }

  export type PlanEstudiosUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    anno?: IntFieldUpdateOperationsInput | number
    Carrera?: CarreraUpdateOneRequiredWithoutPlanEstudiosNestedInput
    Materia?: MateriaUpdateManyWithoutPlanEstudiosNestedInput
  }

  export type PlanEstudiosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    anno?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    Materia?: MateriaUncheckedUpdateManyWithoutPlanEstudiosNestedInput
  }

  export type PlanEstudiosCreateManyInput = {
    id?: number
    nombre: string
    anno: number
    id_carrera: number
  }

  export type PlanEstudiosUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    anno?: IntFieldUpdateOperationsInput | number
  }

  export type PlanEstudiosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    anno?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
  }

  export type CuatrimestreCreateInput = {
    numero_cuatrimestre: number
    anno: number
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCuatrimestreInput
    Curso?: CursoCreateNestedManyWithoutCuatrimestreInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutCuatrimestreInput
  }

  export type CuatrimestreUncheckedCreateInput = {
    id?: number
    numero_cuatrimestre: number
    anno: number
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCuatrimestreInput
    Curso?: CursoUncheckedCreateNestedManyWithoutCuatrimestreInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutCuatrimestreInput
  }

  export type CuatrimestreUpdateInput = {
    numero_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: IntFieldUpdateOperationsInput | number
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCuatrimestreNestedInput
    Curso?: CursoUpdateManyWithoutCuatrimestreNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutCuatrimestreNestedInput
  }

  export type CuatrimestreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: IntFieldUpdateOperationsInput | number
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCuatrimestreNestedInput
    Curso?: CursoUncheckedUpdateManyWithoutCuatrimestreNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutCuatrimestreNestedInput
  }

  export type CuatrimestreCreateManyInput = {
    id?: number
    numero_cuatrimestre: number
    anno: number
  }

  export type CuatrimestreUpdateManyMutationInput = {
    numero_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: IntFieldUpdateOperationsInput | number
  }

  export type CuatrimestreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: IntFieldUpdateOperationsInput | number
  }

  export type MateriaCreateInput = {
    nombre: string
    codigo: string
    PlanEstudios: PlanEstudiosCreateNestedOneWithoutMateriaInput
    Curso?: CursoCreateNestedManyWithoutMateriaInput
  }

  export type MateriaUncheckedCreateInput = {
    id?: number
    nombre: string
    codigo: string
    id_plan_estudios: number
    Curso?: CursoUncheckedCreateNestedManyWithoutMateriaInput
  }

  export type MateriaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    PlanEstudios?: PlanEstudiosUpdateOneRequiredWithoutMateriaNestedInput
    Curso?: CursoUpdateManyWithoutMateriaNestedInput
  }

  export type MateriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    id_plan_estudios?: IntFieldUpdateOperationsInput | number
    Curso?: CursoUncheckedUpdateManyWithoutMateriaNestedInput
  }

  export type MateriaCreateManyInput = {
    id?: number
    nombre: string
    codigo: string
    id_plan_estudios: number
  }

  export type MateriaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
  }

  export type MateriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    id_plan_estudios?: IntFieldUpdateOperationsInput | number
  }

  export type CursoCreateInput = {
    horario: string
    aula: string
    Materia: MateriaCreateNestedOneWithoutCursoInput
    Usuario: UsuarioCreateNestedOneWithoutCursoInput
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutCursoInput
    DetalleFactura?: DetalleFacturaCreateNestedManyWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateInput = {
    id?: number
    id_materia: number
    id_docente: number
    horario: string
    aula: string
    id_cuatrimestre: number
    DetalleFactura?: DetalleFacturaUncheckedCreateNestedManyWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoUpdateInput = {
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    Materia?: MateriaUpdateOneRequiredWithoutCursoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutCursoNestedInput
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutCursoNestedInput
    DetalleFactura?: DetalleFacturaUpdateManyWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_materia?: IntFieldUpdateOperationsInput | number
    id_docente?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    DetalleFactura?: DetalleFacturaUncheckedUpdateManyWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type CursoCreateManyInput = {
    id?: number
    id_materia: number
    id_docente: number
    horario: string
    aula: string
    id_cuatrimestre: number
  }

  export type CursoUpdateManyMutationInput = {
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
  }

  export type CursoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_materia?: IntFieldUpdateOperationsInput | number
    id_docente?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
  }

  export type MatriculaCreateInput = {
    fecha?: Date | string
    estado: string
    Usuario: UsuarioCreateNestedOneWithoutMatriculaInput
    Curso: CursoCreateNestedOneWithoutCuMatriculaInput
  }

  export type MatriculaUncheckedCreateInput = {
    id?: number
    id_usuario: number
    id_curso: number
    fecha?: Date | string
    estado: string
  }

  export type MatriculaUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateOneRequiredWithoutMatriculaNestedInput
    Curso?: CursoUpdateOneRequiredWithoutCuMatriculaNestedInput
  }

  export type MatriculaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type MatriculaCreateManyInput = {
    id?: number
    id_usuario: number
    id_curso: number
    fecha?: Date | string
    estado: string
  }

  export type MatriculaUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type MatriculaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type OfertaAcademicaCreateInput = {
    anno: string
    Curso: CursoCreateNestedOneWithoutOfertaAcademicaInput
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutOfertaAcademicaInput
    Carrera: CarreraCreateNestedOneWithoutOfertaAcademicaInput
  }

  export type OfertaAcademicaUncheckedCreateInput = {
    id?: number
    id_curso: number
    id_carrera: number
    id_cuatrimestre: number
    anno: string
  }

  export type OfertaAcademicaUpdateInput = {
    anno?: StringFieldUpdateOperationsInput | string
    Curso?: CursoUpdateOneRequiredWithoutOfertaAcademicaNestedInput
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutOfertaAcademicaNestedInput
    Carrera?: CarreraUpdateOneRequiredWithoutOfertaAcademicaNestedInput
  }

  export type OfertaAcademicaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: StringFieldUpdateOperationsInput | string
  }

  export type OfertaAcademicaCreateManyInput = {
    id?: number
    id_curso: number
    id_carrera: number
    id_cuatrimestre: number
    anno: string
  }

  export type OfertaAcademicaUpdateManyMutationInput = {
    anno?: StringFieldUpdateOperationsInput | string
  }

  export type OfertaAcademicaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: StringFieldUpdateOperationsInput | string
  }

  export type HistoricoAcademicoCreateInput = {
    nota: number
    Usuario: UsuarioCreateNestedOneWithoutHistoricoAcademicoInput
    Curso: CursoCreateNestedOneWithoutHistoricoAcademicoInput
  }

  export type HistoricoAcademicoUncheckedCreateInput = {
    id?: number
    id_usuario: number
    id_curso: number
    nota: number
  }

  export type HistoricoAcademicoUpdateInput = {
    nota?: FloatFieldUpdateOperationsInput | number
    Usuario?: UsuarioUpdateOneRequiredWithoutHistoricoAcademicoNestedInput
    Curso?: CursoUpdateOneRequiredWithoutHistoricoAcademicoNestedInput
  }

  export type HistoricoAcademicoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    nota?: FloatFieldUpdateOperationsInput | number
  }

  export type HistoricoAcademicoCreateManyInput = {
    id?: number
    id_usuario: number
    id_curso: number
    nota: number
  }

  export type HistoricoAcademicoUpdateManyMutationInput = {
    nota?: FloatFieldUpdateOperationsInput | number
  }

  export type HistoricoAcademicoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    nota?: FloatFieldUpdateOperationsInput | number
  }

  export type AuditoriaCreateInput = {
    accion: string
    fecha_hora?: Date | string
    descripcion: string
    Usuario: UsuarioCreateNestedOneWithoutAuditoriaInput
  }

  export type AuditoriaUncheckedCreateInput = {
    id?: number
    id_usuario: number
    accion: string
    fecha_hora?: Date | string
    descripcion: string
  }

  export type AuditoriaUpdateInput = {
    accion?: StringFieldUpdateOperationsInput | string
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateOneRequiredWithoutAuditoriaNestedInput
  }

  export type AuditoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    accion?: StringFieldUpdateOperationsInput | string
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type AuditoriaCreateManyInput = {
    id?: number
    id_usuario: number
    accion: string
    fecha_hora?: Date | string
    descripcion: string
  }

  export type AuditoriaUpdateManyMutationInput = {
    accion?: StringFieldUpdateOperationsInput | string
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type AuditoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    accion?: StringFieldUpdateOperationsInput | string
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type EncabezadoFacturaCreateInput = {
    fecha_hora?: Date | string
    Carrera: CarreraCreateNestedOneWithoutEncabezadoFacturaInput
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutEncabezadoFacturaInput
    Usuario: UsuarioCreateNestedOneWithoutEncabezadoFacturaInput
    DetalleFactura?: DetalleFacturaCreateNestedManyWithoutEncabezadoFacturaInput
  }

  export type EncabezadoFacturaUncheckedCreateInput = {
    id?: number
    id_cuatrimestre: number
    id_carrera: number
    id_usuario: number
    fecha_hora?: Date | string
    DetalleFactura?: DetalleFacturaUncheckedCreateNestedManyWithoutEncabezadoFacturaInput
  }

  export type EncabezadoFacturaUpdateInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    Carrera?: CarreraUpdateOneRequiredWithoutEncabezadoFacturaNestedInput
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutEncabezadoFacturaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutEncabezadoFacturaNestedInput
    DetalleFactura?: DetalleFacturaUpdateManyWithoutEncabezadoFacturaNestedInput
  }

  export type EncabezadoFacturaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    DetalleFactura?: DetalleFacturaUncheckedUpdateManyWithoutEncabezadoFacturaNestedInput
  }

  export type EncabezadoFacturaCreateManyInput = {
    id?: number
    id_cuatrimestre: number
    id_carrera: number
    id_usuario: number
    fecha_hora?: Date | string
  }

  export type EncabezadoFacturaUpdateManyMutationInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncabezadoFacturaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetalleFacturaCreateInput = {
    precio_unitario: number
    Curso: CursoCreateNestedOneWithoutDetalleFacturaInput
    EncabezadoFactura: EncabezadoFacturaCreateNestedOneWithoutDetalleFacturaInput
  }

  export type DetalleFacturaUncheckedCreateInput = {
    id?: number
    id_curso: number
    id_encabezadofactura: number
    precio_unitario: number
  }

  export type DetalleFacturaUpdateInput = {
    precio_unitario?: FloatFieldUpdateOperationsInput | number
    Curso?: CursoUpdateOneRequiredWithoutDetalleFacturaNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateOneRequiredWithoutDetalleFacturaNestedInput
  }

  export type DetalleFacturaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    id_encabezadofactura?: IntFieldUpdateOperationsInput | number
    precio_unitario?: FloatFieldUpdateOperationsInput | number
  }

  export type DetalleFacturaCreateManyInput = {
    id?: number
    id_curso: number
    id_encabezadofactura: number
    precio_unitario: number
  }

  export type DetalleFacturaUpdateManyMutationInput = {
    precio_unitario?: FloatFieldUpdateOperationsInput | number
  }

  export type DetalleFacturaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    id_encabezadofactura?: IntFieldUpdateOperationsInput | number
    precio_unitario?: FloatFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CargoOrderByRelevanceInput = {
    fields: CargoOrderByRelevanceFieldEnum | CargoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CargoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CargoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CargoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CargoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CargoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type OfertaAcademicaListRelationFilter = {
    every?: OfertaAcademicaWhereInput
    some?: OfertaAcademicaWhereInput
    none?: OfertaAcademicaWhereInput
  }

  export type PlanEstudiosListRelationFilter = {
    every?: PlanEstudiosWhereInput
    some?: PlanEstudiosWhereInput
    none?: PlanEstudiosWhereInput
  }

  export type EncabezadoFacturaListRelationFilter = {
    every?: EncabezadoFacturaWhereInput
    some?: EncabezadoFacturaWhereInput
    none?: EncabezadoFacturaWhereInput
  }

  export type OfertaAcademicaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanEstudiosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncabezadoFacturaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CarreraOrderByRelevanceInput = {
    fields: CarreraOrderByRelevanceFieldEnum | CarreraOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CarreraCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    especialidad?: SortOrder
  }

  export type CarreraAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CarreraMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    especialidad?: SortOrder
  }

  export type CarreraMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    especialidad?: SortOrder
  }

  export type CarreraSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CargoScalarRelationFilter = {
    is?: CargoWhereInput
    isNot?: CargoWhereInput
  }

  export type CarreraScalarRelationFilter = {
    is?: CarreraWhereInput
    isNot?: CarreraWhereInput
  }

  export type CursoListRelationFilter = {
    every?: CursoWhereInput
    some?: CursoWhereInput
    none?: CursoWhereInput
  }

  export type HistoricoAcademicoListRelationFilter = {
    every?: HistoricoAcademicoWhereInput
    some?: HistoricoAcademicoWhereInput
    none?: HistoricoAcademicoWhereInput
  }

  export type AuditoriaListRelationFilter = {
    every?: AuditoriaWhereInput
    some?: AuditoriaWhereInput
    none?: AuditoriaWhereInput
  }

  export type MatriculaListRelationFilter = {
    every?: MatriculaWhereInput
    some?: MatriculaWhereInput
    none?: MatriculaWhereInput
  }

  export type CursoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HistoricoAcademicoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatriculaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioOrderByRelevanceInput = {
    fields: UsuarioOrderByRelevanceFieldEnum | UsuarioOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    fecha_nacimiento?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    id_cargo?: SortOrder
    id_carrera?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    id_cargo?: SortOrder
    id_carrera?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    fecha_nacimiento?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    id_cargo?: SortOrder
    id_carrera?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    fecha_nacimiento?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    id_cargo?: SortOrder
    id_carrera?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
    id_cargo?: SortOrder
    id_carrera?: SortOrder
  }

  export type MateriaListRelationFilter = {
    every?: MateriaWhereInput
    some?: MateriaWhereInput
    none?: MateriaWhereInput
  }

  export type MateriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanEstudiosOrderByRelevanceInput = {
    fields: PlanEstudiosOrderByRelevanceFieldEnum | PlanEstudiosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PlanEstudiosCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    anno?: SortOrder
    id_carrera?: SortOrder
  }

  export type PlanEstudiosAvgOrderByAggregateInput = {
    id?: SortOrder
    anno?: SortOrder
    id_carrera?: SortOrder
  }

  export type PlanEstudiosMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    anno?: SortOrder
    id_carrera?: SortOrder
  }

  export type PlanEstudiosMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    anno?: SortOrder
    id_carrera?: SortOrder
  }

  export type PlanEstudiosSumOrderByAggregateInput = {
    id?: SortOrder
    anno?: SortOrder
    id_carrera?: SortOrder
  }

  export type CuatrimestreCountOrderByAggregateInput = {
    id?: SortOrder
    numero_cuatrimestre?: SortOrder
    anno?: SortOrder
  }

  export type CuatrimestreAvgOrderByAggregateInput = {
    id?: SortOrder
    numero_cuatrimestre?: SortOrder
    anno?: SortOrder
  }

  export type CuatrimestreMaxOrderByAggregateInput = {
    id?: SortOrder
    numero_cuatrimestre?: SortOrder
    anno?: SortOrder
  }

  export type CuatrimestreMinOrderByAggregateInput = {
    id?: SortOrder
    numero_cuatrimestre?: SortOrder
    anno?: SortOrder
  }

  export type CuatrimestreSumOrderByAggregateInput = {
    id?: SortOrder
    numero_cuatrimestre?: SortOrder
    anno?: SortOrder
  }

  export type PlanEstudiosScalarRelationFilter = {
    is?: PlanEstudiosWhereInput
    isNot?: PlanEstudiosWhereInput
  }

  export type MateriaOrderByRelevanceInput = {
    fields: MateriaOrderByRelevanceFieldEnum | MateriaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MateriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    id_plan_estudios?: SortOrder
  }

  export type MateriaAvgOrderByAggregateInput = {
    id?: SortOrder
    id_plan_estudios?: SortOrder
  }

  export type MateriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    id_plan_estudios?: SortOrder
  }

  export type MateriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    codigo?: SortOrder
    id_plan_estudios?: SortOrder
  }

  export type MateriaSumOrderByAggregateInput = {
    id?: SortOrder
    id_plan_estudios?: SortOrder
  }

  export type MateriaScalarRelationFilter = {
    is?: MateriaWhereInput
    isNot?: MateriaWhereInput
  }

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type CuatrimestreScalarRelationFilter = {
    is?: CuatrimestreWhereInput
    isNot?: CuatrimestreWhereInput
  }

  export type DetalleFacturaListRelationFilter = {
    every?: DetalleFacturaWhereInput
    some?: DetalleFacturaWhereInput
    none?: DetalleFacturaWhereInput
  }

  export type DetalleFacturaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CursoOrderByRelevanceInput = {
    fields: CursoOrderByRelevanceFieldEnum | CursoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CursoCountOrderByAggregateInput = {
    id?: SortOrder
    id_materia?: SortOrder
    id_docente?: SortOrder
    horario?: SortOrder
    aula?: SortOrder
    id_cuatrimestre?: SortOrder
  }

  export type CursoAvgOrderByAggregateInput = {
    id?: SortOrder
    id_materia?: SortOrder
    id_docente?: SortOrder
    id_cuatrimestre?: SortOrder
  }

  export type CursoMaxOrderByAggregateInput = {
    id?: SortOrder
    id_materia?: SortOrder
    id_docente?: SortOrder
    horario?: SortOrder
    aula?: SortOrder
    id_cuatrimestre?: SortOrder
  }

  export type CursoMinOrderByAggregateInput = {
    id?: SortOrder
    id_materia?: SortOrder
    id_docente?: SortOrder
    horario?: SortOrder
    aula?: SortOrder
    id_cuatrimestre?: SortOrder
  }

  export type CursoSumOrderByAggregateInput = {
    id?: SortOrder
    id_materia?: SortOrder
    id_docente?: SortOrder
    id_cuatrimestre?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CursoScalarRelationFilter = {
    is?: CursoWhereInput
    isNot?: CursoWhereInput
  }

  export type MatriculaOrderByRelevanceInput = {
    fields: MatriculaOrderByRelevanceFieldEnum | MatriculaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MatriculaCountOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type MatriculaAvgOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
  }

  export type MatriculaMaxOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type MatriculaMinOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type MatriculaSumOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type OfertaAcademicaOrderByRelevanceInput = {
    fields: OfertaAcademicaOrderByRelevanceFieldEnum | OfertaAcademicaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OfertaAcademicaCountOrderByAggregateInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_carrera?: SortOrder
    id_cuatrimestre?: SortOrder
    anno?: SortOrder
  }

  export type OfertaAcademicaAvgOrderByAggregateInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_carrera?: SortOrder
    id_cuatrimestre?: SortOrder
  }

  export type OfertaAcademicaMaxOrderByAggregateInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_carrera?: SortOrder
    id_cuatrimestre?: SortOrder
    anno?: SortOrder
  }

  export type OfertaAcademicaMinOrderByAggregateInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_carrera?: SortOrder
    id_cuatrimestre?: SortOrder
    anno?: SortOrder
  }

  export type OfertaAcademicaSumOrderByAggregateInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_carrera?: SortOrder
    id_cuatrimestre?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type HistoricoAcademicoCountOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
    nota?: SortOrder
  }

  export type HistoricoAcademicoAvgOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
    nota?: SortOrder
  }

  export type HistoricoAcademicoMaxOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
    nota?: SortOrder
  }

  export type HistoricoAcademicoMinOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
    nota?: SortOrder
  }

  export type HistoricoAcademicoSumOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    id_curso?: SortOrder
    nota?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AuditoriaOrderByRelevanceInput = {
    fields: AuditoriaOrderByRelevanceFieldEnum | AuditoriaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AuditoriaCountOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    accion?: SortOrder
    fecha_hora?: SortOrder
    descripcion?: SortOrder
  }

  export type AuditoriaAvgOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
  }

  export type AuditoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    accion?: SortOrder
    fecha_hora?: SortOrder
    descripcion?: SortOrder
  }

  export type AuditoriaMinOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
    accion?: SortOrder
    fecha_hora?: SortOrder
    descripcion?: SortOrder
  }

  export type AuditoriaSumOrderByAggregateInput = {
    id?: SortOrder
    id_usuario?: SortOrder
  }

  export type EncabezadoFacturaCountOrderByAggregateInput = {
    id?: SortOrder
    id_cuatrimestre?: SortOrder
    id_carrera?: SortOrder
    id_usuario?: SortOrder
    fecha_hora?: SortOrder
  }

  export type EncabezadoFacturaAvgOrderByAggregateInput = {
    id?: SortOrder
    id_cuatrimestre?: SortOrder
    id_carrera?: SortOrder
    id_usuario?: SortOrder
  }

  export type EncabezadoFacturaMaxOrderByAggregateInput = {
    id?: SortOrder
    id_cuatrimestre?: SortOrder
    id_carrera?: SortOrder
    id_usuario?: SortOrder
    fecha_hora?: SortOrder
  }

  export type EncabezadoFacturaMinOrderByAggregateInput = {
    id?: SortOrder
    id_cuatrimestre?: SortOrder
    id_carrera?: SortOrder
    id_usuario?: SortOrder
    fecha_hora?: SortOrder
  }

  export type EncabezadoFacturaSumOrderByAggregateInput = {
    id?: SortOrder
    id_cuatrimestre?: SortOrder
    id_carrera?: SortOrder
    id_usuario?: SortOrder
  }

  export type EncabezadoFacturaScalarRelationFilter = {
    is?: EncabezadoFacturaWhereInput
    isNot?: EncabezadoFacturaWhereInput
  }

  export type DetalleFacturaCountOrderByAggregateInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_encabezadofactura?: SortOrder
    precio_unitario?: SortOrder
  }

  export type DetalleFacturaAvgOrderByAggregateInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_encabezadofactura?: SortOrder
    precio_unitario?: SortOrder
  }

  export type DetalleFacturaMaxOrderByAggregateInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_encabezadofactura?: SortOrder
    precio_unitario?: SortOrder
  }

  export type DetalleFacturaMinOrderByAggregateInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_encabezadofactura?: SortOrder
    precio_unitario?: SortOrder
  }

  export type DetalleFacturaSumOrderByAggregateInput = {
    id?: SortOrder
    id_curso?: SortOrder
    id_encabezadofactura?: SortOrder
    precio_unitario?: SortOrder
  }

  export type UsuarioCreateNestedManyWithoutCargoInput = {
    create?: XOR<UsuarioCreateWithoutCargoInput, UsuarioUncheckedCreateWithoutCargoInput> | UsuarioCreateWithoutCargoInput[] | UsuarioUncheckedCreateWithoutCargoInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCargoInput | UsuarioCreateOrConnectWithoutCargoInput[]
    createMany?: UsuarioCreateManyCargoInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutCargoInput = {
    create?: XOR<UsuarioCreateWithoutCargoInput, UsuarioUncheckedCreateWithoutCargoInput> | UsuarioCreateWithoutCargoInput[] | UsuarioUncheckedCreateWithoutCargoInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCargoInput | UsuarioCreateOrConnectWithoutCargoInput[]
    createMany?: UsuarioCreateManyCargoInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UsuarioUpdateManyWithoutCargoNestedInput = {
    create?: XOR<UsuarioCreateWithoutCargoInput, UsuarioUncheckedCreateWithoutCargoInput> | UsuarioCreateWithoutCargoInput[] | UsuarioUncheckedCreateWithoutCargoInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCargoInput | UsuarioCreateOrConnectWithoutCargoInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutCargoInput | UsuarioUpsertWithWhereUniqueWithoutCargoInput[]
    createMany?: UsuarioCreateManyCargoInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutCargoInput | UsuarioUpdateWithWhereUniqueWithoutCargoInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutCargoInput | UsuarioUpdateManyWithWhereWithoutCargoInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsuarioUncheckedUpdateManyWithoutCargoNestedInput = {
    create?: XOR<UsuarioCreateWithoutCargoInput, UsuarioUncheckedCreateWithoutCargoInput> | UsuarioCreateWithoutCargoInput[] | UsuarioUncheckedCreateWithoutCargoInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCargoInput | UsuarioCreateOrConnectWithoutCargoInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutCargoInput | UsuarioUpsertWithWhereUniqueWithoutCargoInput[]
    createMany?: UsuarioCreateManyCargoInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutCargoInput | UsuarioUpdateWithWhereUniqueWithoutCargoInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutCargoInput | UsuarioUpdateManyWithWhereWithoutCargoInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type OfertaAcademicaCreateNestedManyWithoutCarreraInput = {
    create?: XOR<OfertaAcademicaCreateWithoutCarreraInput, OfertaAcademicaUncheckedCreateWithoutCarreraInput> | OfertaAcademicaCreateWithoutCarreraInput[] | OfertaAcademicaUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: OfertaAcademicaCreateOrConnectWithoutCarreraInput | OfertaAcademicaCreateOrConnectWithoutCarreraInput[]
    createMany?: OfertaAcademicaCreateManyCarreraInputEnvelope
    connect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
  }

  export type PlanEstudiosCreateNestedManyWithoutCarreraInput = {
    create?: XOR<PlanEstudiosCreateWithoutCarreraInput, PlanEstudiosUncheckedCreateWithoutCarreraInput> | PlanEstudiosCreateWithoutCarreraInput[] | PlanEstudiosUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: PlanEstudiosCreateOrConnectWithoutCarreraInput | PlanEstudiosCreateOrConnectWithoutCarreraInput[]
    createMany?: PlanEstudiosCreateManyCarreraInputEnvelope
    connect?: PlanEstudiosWhereUniqueInput | PlanEstudiosWhereUniqueInput[]
  }

  export type UsuarioCreateNestedManyWithoutCarreraInput = {
    create?: XOR<UsuarioCreateWithoutCarreraInput, UsuarioUncheckedCreateWithoutCarreraInput> | UsuarioCreateWithoutCarreraInput[] | UsuarioUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCarreraInput | UsuarioCreateOrConnectWithoutCarreraInput[]
    createMany?: UsuarioCreateManyCarreraInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type EncabezadoFacturaCreateNestedManyWithoutCarreraInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutCarreraInput, EncabezadoFacturaUncheckedCreateWithoutCarreraInput> | EncabezadoFacturaCreateWithoutCarreraInput[] | EncabezadoFacturaUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutCarreraInput | EncabezadoFacturaCreateOrConnectWithoutCarreraInput[]
    createMany?: EncabezadoFacturaCreateManyCarreraInputEnvelope
    connect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
  }

  export type OfertaAcademicaUncheckedCreateNestedManyWithoutCarreraInput = {
    create?: XOR<OfertaAcademicaCreateWithoutCarreraInput, OfertaAcademicaUncheckedCreateWithoutCarreraInput> | OfertaAcademicaCreateWithoutCarreraInput[] | OfertaAcademicaUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: OfertaAcademicaCreateOrConnectWithoutCarreraInput | OfertaAcademicaCreateOrConnectWithoutCarreraInput[]
    createMany?: OfertaAcademicaCreateManyCarreraInputEnvelope
    connect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
  }

  export type PlanEstudiosUncheckedCreateNestedManyWithoutCarreraInput = {
    create?: XOR<PlanEstudiosCreateWithoutCarreraInput, PlanEstudiosUncheckedCreateWithoutCarreraInput> | PlanEstudiosCreateWithoutCarreraInput[] | PlanEstudiosUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: PlanEstudiosCreateOrConnectWithoutCarreraInput | PlanEstudiosCreateOrConnectWithoutCarreraInput[]
    createMany?: PlanEstudiosCreateManyCarreraInputEnvelope
    connect?: PlanEstudiosWhereUniqueInput | PlanEstudiosWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutCarreraInput = {
    create?: XOR<UsuarioCreateWithoutCarreraInput, UsuarioUncheckedCreateWithoutCarreraInput> | UsuarioCreateWithoutCarreraInput[] | UsuarioUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCarreraInput | UsuarioCreateOrConnectWithoutCarreraInput[]
    createMany?: UsuarioCreateManyCarreraInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type EncabezadoFacturaUncheckedCreateNestedManyWithoutCarreraInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutCarreraInput, EncabezadoFacturaUncheckedCreateWithoutCarreraInput> | EncabezadoFacturaCreateWithoutCarreraInput[] | EncabezadoFacturaUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutCarreraInput | EncabezadoFacturaCreateOrConnectWithoutCarreraInput[]
    createMany?: EncabezadoFacturaCreateManyCarreraInputEnvelope
    connect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
  }

  export type OfertaAcademicaUpdateManyWithoutCarreraNestedInput = {
    create?: XOR<OfertaAcademicaCreateWithoutCarreraInput, OfertaAcademicaUncheckedCreateWithoutCarreraInput> | OfertaAcademicaCreateWithoutCarreraInput[] | OfertaAcademicaUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: OfertaAcademicaCreateOrConnectWithoutCarreraInput | OfertaAcademicaCreateOrConnectWithoutCarreraInput[]
    upsert?: OfertaAcademicaUpsertWithWhereUniqueWithoutCarreraInput | OfertaAcademicaUpsertWithWhereUniqueWithoutCarreraInput[]
    createMany?: OfertaAcademicaCreateManyCarreraInputEnvelope
    set?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    disconnect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    delete?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    connect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    update?: OfertaAcademicaUpdateWithWhereUniqueWithoutCarreraInput | OfertaAcademicaUpdateWithWhereUniqueWithoutCarreraInput[]
    updateMany?: OfertaAcademicaUpdateManyWithWhereWithoutCarreraInput | OfertaAcademicaUpdateManyWithWhereWithoutCarreraInput[]
    deleteMany?: OfertaAcademicaScalarWhereInput | OfertaAcademicaScalarWhereInput[]
  }

  export type PlanEstudiosUpdateManyWithoutCarreraNestedInput = {
    create?: XOR<PlanEstudiosCreateWithoutCarreraInput, PlanEstudiosUncheckedCreateWithoutCarreraInput> | PlanEstudiosCreateWithoutCarreraInput[] | PlanEstudiosUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: PlanEstudiosCreateOrConnectWithoutCarreraInput | PlanEstudiosCreateOrConnectWithoutCarreraInput[]
    upsert?: PlanEstudiosUpsertWithWhereUniqueWithoutCarreraInput | PlanEstudiosUpsertWithWhereUniqueWithoutCarreraInput[]
    createMany?: PlanEstudiosCreateManyCarreraInputEnvelope
    set?: PlanEstudiosWhereUniqueInput | PlanEstudiosWhereUniqueInput[]
    disconnect?: PlanEstudiosWhereUniqueInput | PlanEstudiosWhereUniqueInput[]
    delete?: PlanEstudiosWhereUniqueInput | PlanEstudiosWhereUniqueInput[]
    connect?: PlanEstudiosWhereUniqueInput | PlanEstudiosWhereUniqueInput[]
    update?: PlanEstudiosUpdateWithWhereUniqueWithoutCarreraInput | PlanEstudiosUpdateWithWhereUniqueWithoutCarreraInput[]
    updateMany?: PlanEstudiosUpdateManyWithWhereWithoutCarreraInput | PlanEstudiosUpdateManyWithWhereWithoutCarreraInput[]
    deleteMany?: PlanEstudiosScalarWhereInput | PlanEstudiosScalarWhereInput[]
  }

  export type UsuarioUpdateManyWithoutCarreraNestedInput = {
    create?: XOR<UsuarioCreateWithoutCarreraInput, UsuarioUncheckedCreateWithoutCarreraInput> | UsuarioCreateWithoutCarreraInput[] | UsuarioUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCarreraInput | UsuarioCreateOrConnectWithoutCarreraInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutCarreraInput | UsuarioUpsertWithWhereUniqueWithoutCarreraInput[]
    createMany?: UsuarioCreateManyCarreraInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutCarreraInput | UsuarioUpdateWithWhereUniqueWithoutCarreraInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutCarreraInput | UsuarioUpdateManyWithWhereWithoutCarreraInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type EncabezadoFacturaUpdateManyWithoutCarreraNestedInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutCarreraInput, EncabezadoFacturaUncheckedCreateWithoutCarreraInput> | EncabezadoFacturaCreateWithoutCarreraInput[] | EncabezadoFacturaUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutCarreraInput | EncabezadoFacturaCreateOrConnectWithoutCarreraInput[]
    upsert?: EncabezadoFacturaUpsertWithWhereUniqueWithoutCarreraInput | EncabezadoFacturaUpsertWithWhereUniqueWithoutCarreraInput[]
    createMany?: EncabezadoFacturaCreateManyCarreraInputEnvelope
    set?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    disconnect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    delete?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    connect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    update?: EncabezadoFacturaUpdateWithWhereUniqueWithoutCarreraInput | EncabezadoFacturaUpdateWithWhereUniqueWithoutCarreraInput[]
    updateMany?: EncabezadoFacturaUpdateManyWithWhereWithoutCarreraInput | EncabezadoFacturaUpdateManyWithWhereWithoutCarreraInput[]
    deleteMany?: EncabezadoFacturaScalarWhereInput | EncabezadoFacturaScalarWhereInput[]
  }

  export type OfertaAcademicaUncheckedUpdateManyWithoutCarreraNestedInput = {
    create?: XOR<OfertaAcademicaCreateWithoutCarreraInput, OfertaAcademicaUncheckedCreateWithoutCarreraInput> | OfertaAcademicaCreateWithoutCarreraInput[] | OfertaAcademicaUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: OfertaAcademicaCreateOrConnectWithoutCarreraInput | OfertaAcademicaCreateOrConnectWithoutCarreraInput[]
    upsert?: OfertaAcademicaUpsertWithWhereUniqueWithoutCarreraInput | OfertaAcademicaUpsertWithWhereUniqueWithoutCarreraInput[]
    createMany?: OfertaAcademicaCreateManyCarreraInputEnvelope
    set?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    disconnect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    delete?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    connect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    update?: OfertaAcademicaUpdateWithWhereUniqueWithoutCarreraInput | OfertaAcademicaUpdateWithWhereUniqueWithoutCarreraInput[]
    updateMany?: OfertaAcademicaUpdateManyWithWhereWithoutCarreraInput | OfertaAcademicaUpdateManyWithWhereWithoutCarreraInput[]
    deleteMany?: OfertaAcademicaScalarWhereInput | OfertaAcademicaScalarWhereInput[]
  }

  export type PlanEstudiosUncheckedUpdateManyWithoutCarreraNestedInput = {
    create?: XOR<PlanEstudiosCreateWithoutCarreraInput, PlanEstudiosUncheckedCreateWithoutCarreraInput> | PlanEstudiosCreateWithoutCarreraInput[] | PlanEstudiosUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: PlanEstudiosCreateOrConnectWithoutCarreraInput | PlanEstudiosCreateOrConnectWithoutCarreraInput[]
    upsert?: PlanEstudiosUpsertWithWhereUniqueWithoutCarreraInput | PlanEstudiosUpsertWithWhereUniqueWithoutCarreraInput[]
    createMany?: PlanEstudiosCreateManyCarreraInputEnvelope
    set?: PlanEstudiosWhereUniqueInput | PlanEstudiosWhereUniqueInput[]
    disconnect?: PlanEstudiosWhereUniqueInput | PlanEstudiosWhereUniqueInput[]
    delete?: PlanEstudiosWhereUniqueInput | PlanEstudiosWhereUniqueInput[]
    connect?: PlanEstudiosWhereUniqueInput | PlanEstudiosWhereUniqueInput[]
    update?: PlanEstudiosUpdateWithWhereUniqueWithoutCarreraInput | PlanEstudiosUpdateWithWhereUniqueWithoutCarreraInput[]
    updateMany?: PlanEstudiosUpdateManyWithWhereWithoutCarreraInput | PlanEstudiosUpdateManyWithWhereWithoutCarreraInput[]
    deleteMany?: PlanEstudiosScalarWhereInput | PlanEstudiosScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutCarreraNestedInput = {
    create?: XOR<UsuarioCreateWithoutCarreraInput, UsuarioUncheckedCreateWithoutCarreraInput> | UsuarioCreateWithoutCarreraInput[] | UsuarioUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCarreraInput | UsuarioCreateOrConnectWithoutCarreraInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutCarreraInput | UsuarioUpsertWithWhereUniqueWithoutCarreraInput[]
    createMany?: UsuarioCreateManyCarreraInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutCarreraInput | UsuarioUpdateWithWhereUniqueWithoutCarreraInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutCarreraInput | UsuarioUpdateManyWithWhereWithoutCarreraInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type EncabezadoFacturaUncheckedUpdateManyWithoutCarreraNestedInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutCarreraInput, EncabezadoFacturaUncheckedCreateWithoutCarreraInput> | EncabezadoFacturaCreateWithoutCarreraInput[] | EncabezadoFacturaUncheckedCreateWithoutCarreraInput[]
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutCarreraInput | EncabezadoFacturaCreateOrConnectWithoutCarreraInput[]
    upsert?: EncabezadoFacturaUpsertWithWhereUniqueWithoutCarreraInput | EncabezadoFacturaUpsertWithWhereUniqueWithoutCarreraInput[]
    createMany?: EncabezadoFacturaCreateManyCarreraInputEnvelope
    set?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    disconnect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    delete?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    connect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    update?: EncabezadoFacturaUpdateWithWhereUniqueWithoutCarreraInput | EncabezadoFacturaUpdateWithWhereUniqueWithoutCarreraInput[]
    updateMany?: EncabezadoFacturaUpdateManyWithWhereWithoutCarreraInput | EncabezadoFacturaUpdateManyWithWhereWithoutCarreraInput[]
    deleteMany?: EncabezadoFacturaScalarWhereInput | EncabezadoFacturaScalarWhereInput[]
  }

  export type CargoCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<CargoCreateWithoutUsuarioInput, CargoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CargoCreateOrConnectWithoutUsuarioInput
    connect?: CargoWhereUniqueInput
  }

  export type CarreraCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<CarreraCreateWithoutUsuarioInput, CarreraUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CarreraCreateOrConnectWithoutUsuarioInput
    connect?: CarreraWhereUniqueInput
  }

  export type CursoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<CursoCreateWithoutUsuarioInput, CursoUncheckedCreateWithoutUsuarioInput> | CursoCreateWithoutUsuarioInput[] | CursoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutUsuarioInput | CursoCreateOrConnectWithoutUsuarioInput[]
    createMany?: CursoCreateManyUsuarioInputEnvelope
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
  }

  export type HistoricoAcademicoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<HistoricoAcademicoCreateWithoutUsuarioInput, HistoricoAcademicoUncheckedCreateWithoutUsuarioInput> | HistoricoAcademicoCreateWithoutUsuarioInput[] | HistoricoAcademicoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: HistoricoAcademicoCreateOrConnectWithoutUsuarioInput | HistoricoAcademicoCreateOrConnectWithoutUsuarioInput[]
    createMany?: HistoricoAcademicoCreateManyUsuarioInputEnvelope
    connect?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
  }

  export type AuditoriaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<AuditoriaCreateWithoutUsuarioInput, AuditoriaUncheckedCreateWithoutUsuarioInput> | AuditoriaCreateWithoutUsuarioInput[] | AuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AuditoriaCreateOrConnectWithoutUsuarioInput | AuditoriaCreateOrConnectWithoutUsuarioInput[]
    createMany?: AuditoriaCreateManyUsuarioInputEnvelope
    connect?: AuditoriaWhereUniqueInput | AuditoriaWhereUniqueInput[]
  }

  export type EncabezadoFacturaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutUsuarioInput, EncabezadoFacturaUncheckedCreateWithoutUsuarioInput> | EncabezadoFacturaCreateWithoutUsuarioInput[] | EncabezadoFacturaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutUsuarioInput | EncabezadoFacturaCreateOrConnectWithoutUsuarioInput[]
    createMany?: EncabezadoFacturaCreateManyUsuarioInputEnvelope
    connect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
  }

  export type MatriculaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<MatriculaCreateWithoutUsuarioInput, MatriculaUncheckedCreateWithoutUsuarioInput> | MatriculaCreateWithoutUsuarioInput[] | MatriculaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutUsuarioInput | MatriculaCreateOrConnectWithoutUsuarioInput[]
    createMany?: MatriculaCreateManyUsuarioInputEnvelope
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
  }

  export type CursoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<CursoCreateWithoutUsuarioInput, CursoUncheckedCreateWithoutUsuarioInput> | CursoCreateWithoutUsuarioInput[] | CursoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutUsuarioInput | CursoCreateOrConnectWithoutUsuarioInput[]
    createMany?: CursoCreateManyUsuarioInputEnvelope
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
  }

  export type HistoricoAcademicoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<HistoricoAcademicoCreateWithoutUsuarioInput, HistoricoAcademicoUncheckedCreateWithoutUsuarioInput> | HistoricoAcademicoCreateWithoutUsuarioInput[] | HistoricoAcademicoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: HistoricoAcademicoCreateOrConnectWithoutUsuarioInput | HistoricoAcademicoCreateOrConnectWithoutUsuarioInput[]
    createMany?: HistoricoAcademicoCreateManyUsuarioInputEnvelope
    connect?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
  }

  export type AuditoriaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<AuditoriaCreateWithoutUsuarioInput, AuditoriaUncheckedCreateWithoutUsuarioInput> | AuditoriaCreateWithoutUsuarioInput[] | AuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AuditoriaCreateOrConnectWithoutUsuarioInput | AuditoriaCreateOrConnectWithoutUsuarioInput[]
    createMany?: AuditoriaCreateManyUsuarioInputEnvelope
    connect?: AuditoriaWhereUniqueInput | AuditoriaWhereUniqueInput[]
  }

  export type EncabezadoFacturaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutUsuarioInput, EncabezadoFacturaUncheckedCreateWithoutUsuarioInput> | EncabezadoFacturaCreateWithoutUsuarioInput[] | EncabezadoFacturaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutUsuarioInput | EncabezadoFacturaCreateOrConnectWithoutUsuarioInput[]
    createMany?: EncabezadoFacturaCreateManyUsuarioInputEnvelope
    connect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
  }

  export type MatriculaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<MatriculaCreateWithoutUsuarioInput, MatriculaUncheckedCreateWithoutUsuarioInput> | MatriculaCreateWithoutUsuarioInput[] | MatriculaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutUsuarioInput | MatriculaCreateOrConnectWithoutUsuarioInput[]
    createMany?: MatriculaCreateManyUsuarioInputEnvelope
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
  }

  export type CargoUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<CargoCreateWithoutUsuarioInput, CargoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CargoCreateOrConnectWithoutUsuarioInput
    upsert?: CargoUpsertWithoutUsuarioInput
    connect?: CargoWhereUniqueInput
    update?: XOR<XOR<CargoUpdateToOneWithWhereWithoutUsuarioInput, CargoUpdateWithoutUsuarioInput>, CargoUncheckedUpdateWithoutUsuarioInput>
  }

  export type CarreraUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<CarreraCreateWithoutUsuarioInput, CarreraUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CarreraCreateOrConnectWithoutUsuarioInput
    upsert?: CarreraUpsertWithoutUsuarioInput
    connect?: CarreraWhereUniqueInput
    update?: XOR<XOR<CarreraUpdateToOneWithWhereWithoutUsuarioInput, CarreraUpdateWithoutUsuarioInput>, CarreraUncheckedUpdateWithoutUsuarioInput>
  }

  export type CursoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<CursoCreateWithoutUsuarioInput, CursoUncheckedCreateWithoutUsuarioInput> | CursoCreateWithoutUsuarioInput[] | CursoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutUsuarioInput | CursoCreateOrConnectWithoutUsuarioInput[]
    upsert?: CursoUpsertWithWhereUniqueWithoutUsuarioInput | CursoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: CursoCreateManyUsuarioInputEnvelope
    set?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    disconnect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    delete?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    update?: CursoUpdateWithWhereUniqueWithoutUsuarioInput | CursoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: CursoUpdateManyWithWhereWithoutUsuarioInput | CursoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: CursoScalarWhereInput | CursoScalarWhereInput[]
  }

  export type HistoricoAcademicoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<HistoricoAcademicoCreateWithoutUsuarioInput, HistoricoAcademicoUncheckedCreateWithoutUsuarioInput> | HistoricoAcademicoCreateWithoutUsuarioInput[] | HistoricoAcademicoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: HistoricoAcademicoCreateOrConnectWithoutUsuarioInput | HistoricoAcademicoCreateOrConnectWithoutUsuarioInput[]
    upsert?: HistoricoAcademicoUpsertWithWhereUniqueWithoutUsuarioInput | HistoricoAcademicoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: HistoricoAcademicoCreateManyUsuarioInputEnvelope
    set?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    disconnect?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    delete?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    connect?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    update?: HistoricoAcademicoUpdateWithWhereUniqueWithoutUsuarioInput | HistoricoAcademicoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: HistoricoAcademicoUpdateManyWithWhereWithoutUsuarioInput | HistoricoAcademicoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: HistoricoAcademicoScalarWhereInput | HistoricoAcademicoScalarWhereInput[]
  }

  export type AuditoriaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<AuditoriaCreateWithoutUsuarioInput, AuditoriaUncheckedCreateWithoutUsuarioInput> | AuditoriaCreateWithoutUsuarioInput[] | AuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AuditoriaCreateOrConnectWithoutUsuarioInput | AuditoriaCreateOrConnectWithoutUsuarioInput[]
    upsert?: AuditoriaUpsertWithWhereUniqueWithoutUsuarioInput | AuditoriaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: AuditoriaCreateManyUsuarioInputEnvelope
    set?: AuditoriaWhereUniqueInput | AuditoriaWhereUniqueInput[]
    disconnect?: AuditoriaWhereUniqueInput | AuditoriaWhereUniqueInput[]
    delete?: AuditoriaWhereUniqueInput | AuditoriaWhereUniqueInput[]
    connect?: AuditoriaWhereUniqueInput | AuditoriaWhereUniqueInput[]
    update?: AuditoriaUpdateWithWhereUniqueWithoutUsuarioInput | AuditoriaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: AuditoriaUpdateManyWithWhereWithoutUsuarioInput | AuditoriaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: AuditoriaScalarWhereInput | AuditoriaScalarWhereInput[]
  }

  export type EncabezadoFacturaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutUsuarioInput, EncabezadoFacturaUncheckedCreateWithoutUsuarioInput> | EncabezadoFacturaCreateWithoutUsuarioInput[] | EncabezadoFacturaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutUsuarioInput | EncabezadoFacturaCreateOrConnectWithoutUsuarioInput[]
    upsert?: EncabezadoFacturaUpsertWithWhereUniqueWithoutUsuarioInput | EncabezadoFacturaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EncabezadoFacturaCreateManyUsuarioInputEnvelope
    set?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    disconnect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    delete?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    connect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    update?: EncabezadoFacturaUpdateWithWhereUniqueWithoutUsuarioInput | EncabezadoFacturaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EncabezadoFacturaUpdateManyWithWhereWithoutUsuarioInput | EncabezadoFacturaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EncabezadoFacturaScalarWhereInput | EncabezadoFacturaScalarWhereInput[]
  }

  export type MatriculaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<MatriculaCreateWithoutUsuarioInput, MatriculaUncheckedCreateWithoutUsuarioInput> | MatriculaCreateWithoutUsuarioInput[] | MatriculaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutUsuarioInput | MatriculaCreateOrConnectWithoutUsuarioInput[]
    upsert?: MatriculaUpsertWithWhereUniqueWithoutUsuarioInput | MatriculaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: MatriculaCreateManyUsuarioInputEnvelope
    set?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    disconnect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    delete?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    update?: MatriculaUpdateWithWhereUniqueWithoutUsuarioInput | MatriculaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: MatriculaUpdateManyWithWhereWithoutUsuarioInput | MatriculaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: MatriculaScalarWhereInput | MatriculaScalarWhereInput[]
  }

  export type CursoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<CursoCreateWithoutUsuarioInput, CursoUncheckedCreateWithoutUsuarioInput> | CursoCreateWithoutUsuarioInput[] | CursoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutUsuarioInput | CursoCreateOrConnectWithoutUsuarioInput[]
    upsert?: CursoUpsertWithWhereUniqueWithoutUsuarioInput | CursoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: CursoCreateManyUsuarioInputEnvelope
    set?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    disconnect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    delete?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    update?: CursoUpdateWithWhereUniqueWithoutUsuarioInput | CursoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: CursoUpdateManyWithWhereWithoutUsuarioInput | CursoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: CursoScalarWhereInput | CursoScalarWhereInput[]
  }

  export type HistoricoAcademicoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<HistoricoAcademicoCreateWithoutUsuarioInput, HistoricoAcademicoUncheckedCreateWithoutUsuarioInput> | HistoricoAcademicoCreateWithoutUsuarioInput[] | HistoricoAcademicoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: HistoricoAcademicoCreateOrConnectWithoutUsuarioInput | HistoricoAcademicoCreateOrConnectWithoutUsuarioInput[]
    upsert?: HistoricoAcademicoUpsertWithWhereUniqueWithoutUsuarioInput | HistoricoAcademicoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: HistoricoAcademicoCreateManyUsuarioInputEnvelope
    set?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    disconnect?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    delete?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    connect?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    update?: HistoricoAcademicoUpdateWithWhereUniqueWithoutUsuarioInput | HistoricoAcademicoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: HistoricoAcademicoUpdateManyWithWhereWithoutUsuarioInput | HistoricoAcademicoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: HistoricoAcademicoScalarWhereInput | HistoricoAcademicoScalarWhereInput[]
  }

  export type AuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<AuditoriaCreateWithoutUsuarioInput, AuditoriaUncheckedCreateWithoutUsuarioInput> | AuditoriaCreateWithoutUsuarioInput[] | AuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AuditoriaCreateOrConnectWithoutUsuarioInput | AuditoriaCreateOrConnectWithoutUsuarioInput[]
    upsert?: AuditoriaUpsertWithWhereUniqueWithoutUsuarioInput | AuditoriaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: AuditoriaCreateManyUsuarioInputEnvelope
    set?: AuditoriaWhereUniqueInput | AuditoriaWhereUniqueInput[]
    disconnect?: AuditoriaWhereUniqueInput | AuditoriaWhereUniqueInput[]
    delete?: AuditoriaWhereUniqueInput | AuditoriaWhereUniqueInput[]
    connect?: AuditoriaWhereUniqueInput | AuditoriaWhereUniqueInput[]
    update?: AuditoriaUpdateWithWhereUniqueWithoutUsuarioInput | AuditoriaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: AuditoriaUpdateManyWithWhereWithoutUsuarioInput | AuditoriaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: AuditoriaScalarWhereInput | AuditoriaScalarWhereInput[]
  }

  export type EncabezadoFacturaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutUsuarioInput, EncabezadoFacturaUncheckedCreateWithoutUsuarioInput> | EncabezadoFacturaCreateWithoutUsuarioInput[] | EncabezadoFacturaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutUsuarioInput | EncabezadoFacturaCreateOrConnectWithoutUsuarioInput[]
    upsert?: EncabezadoFacturaUpsertWithWhereUniqueWithoutUsuarioInput | EncabezadoFacturaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EncabezadoFacturaCreateManyUsuarioInputEnvelope
    set?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    disconnect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    delete?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    connect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    update?: EncabezadoFacturaUpdateWithWhereUniqueWithoutUsuarioInput | EncabezadoFacturaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EncabezadoFacturaUpdateManyWithWhereWithoutUsuarioInput | EncabezadoFacturaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EncabezadoFacturaScalarWhereInput | EncabezadoFacturaScalarWhereInput[]
  }

  export type MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<MatriculaCreateWithoutUsuarioInput, MatriculaUncheckedCreateWithoutUsuarioInput> | MatriculaCreateWithoutUsuarioInput[] | MatriculaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutUsuarioInput | MatriculaCreateOrConnectWithoutUsuarioInput[]
    upsert?: MatriculaUpsertWithWhereUniqueWithoutUsuarioInput | MatriculaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: MatriculaCreateManyUsuarioInputEnvelope
    set?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    disconnect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    delete?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    update?: MatriculaUpdateWithWhereUniqueWithoutUsuarioInput | MatriculaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: MatriculaUpdateManyWithWhereWithoutUsuarioInput | MatriculaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: MatriculaScalarWhereInput | MatriculaScalarWhereInput[]
  }

  export type CarreraCreateNestedOneWithoutPlanEstudiosInput = {
    create?: XOR<CarreraCreateWithoutPlanEstudiosInput, CarreraUncheckedCreateWithoutPlanEstudiosInput>
    connectOrCreate?: CarreraCreateOrConnectWithoutPlanEstudiosInput
    connect?: CarreraWhereUniqueInput
  }

  export type MateriaCreateNestedManyWithoutPlanEstudiosInput = {
    create?: XOR<MateriaCreateWithoutPlanEstudiosInput, MateriaUncheckedCreateWithoutPlanEstudiosInput> | MateriaCreateWithoutPlanEstudiosInput[] | MateriaUncheckedCreateWithoutPlanEstudiosInput[]
    connectOrCreate?: MateriaCreateOrConnectWithoutPlanEstudiosInput | MateriaCreateOrConnectWithoutPlanEstudiosInput[]
    createMany?: MateriaCreateManyPlanEstudiosInputEnvelope
    connect?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
  }

  export type MateriaUncheckedCreateNestedManyWithoutPlanEstudiosInput = {
    create?: XOR<MateriaCreateWithoutPlanEstudiosInput, MateriaUncheckedCreateWithoutPlanEstudiosInput> | MateriaCreateWithoutPlanEstudiosInput[] | MateriaUncheckedCreateWithoutPlanEstudiosInput[]
    connectOrCreate?: MateriaCreateOrConnectWithoutPlanEstudiosInput | MateriaCreateOrConnectWithoutPlanEstudiosInput[]
    createMany?: MateriaCreateManyPlanEstudiosInputEnvelope
    connect?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
  }

  export type CarreraUpdateOneRequiredWithoutPlanEstudiosNestedInput = {
    create?: XOR<CarreraCreateWithoutPlanEstudiosInput, CarreraUncheckedCreateWithoutPlanEstudiosInput>
    connectOrCreate?: CarreraCreateOrConnectWithoutPlanEstudiosInput
    upsert?: CarreraUpsertWithoutPlanEstudiosInput
    connect?: CarreraWhereUniqueInput
    update?: XOR<XOR<CarreraUpdateToOneWithWhereWithoutPlanEstudiosInput, CarreraUpdateWithoutPlanEstudiosInput>, CarreraUncheckedUpdateWithoutPlanEstudiosInput>
  }

  export type MateriaUpdateManyWithoutPlanEstudiosNestedInput = {
    create?: XOR<MateriaCreateWithoutPlanEstudiosInput, MateriaUncheckedCreateWithoutPlanEstudiosInput> | MateriaCreateWithoutPlanEstudiosInput[] | MateriaUncheckedCreateWithoutPlanEstudiosInput[]
    connectOrCreate?: MateriaCreateOrConnectWithoutPlanEstudiosInput | MateriaCreateOrConnectWithoutPlanEstudiosInput[]
    upsert?: MateriaUpsertWithWhereUniqueWithoutPlanEstudiosInput | MateriaUpsertWithWhereUniqueWithoutPlanEstudiosInput[]
    createMany?: MateriaCreateManyPlanEstudiosInputEnvelope
    set?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    disconnect?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    delete?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    connect?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    update?: MateriaUpdateWithWhereUniqueWithoutPlanEstudiosInput | MateriaUpdateWithWhereUniqueWithoutPlanEstudiosInput[]
    updateMany?: MateriaUpdateManyWithWhereWithoutPlanEstudiosInput | MateriaUpdateManyWithWhereWithoutPlanEstudiosInput[]
    deleteMany?: MateriaScalarWhereInput | MateriaScalarWhereInput[]
  }

  export type MateriaUncheckedUpdateManyWithoutPlanEstudiosNestedInput = {
    create?: XOR<MateriaCreateWithoutPlanEstudiosInput, MateriaUncheckedCreateWithoutPlanEstudiosInput> | MateriaCreateWithoutPlanEstudiosInput[] | MateriaUncheckedCreateWithoutPlanEstudiosInput[]
    connectOrCreate?: MateriaCreateOrConnectWithoutPlanEstudiosInput | MateriaCreateOrConnectWithoutPlanEstudiosInput[]
    upsert?: MateriaUpsertWithWhereUniqueWithoutPlanEstudiosInput | MateriaUpsertWithWhereUniqueWithoutPlanEstudiosInput[]
    createMany?: MateriaCreateManyPlanEstudiosInputEnvelope
    set?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    disconnect?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    delete?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    connect?: MateriaWhereUniqueInput | MateriaWhereUniqueInput[]
    update?: MateriaUpdateWithWhereUniqueWithoutPlanEstudiosInput | MateriaUpdateWithWhereUniqueWithoutPlanEstudiosInput[]
    updateMany?: MateriaUpdateManyWithWhereWithoutPlanEstudiosInput | MateriaUpdateManyWithWhereWithoutPlanEstudiosInput[]
    deleteMany?: MateriaScalarWhereInput | MateriaScalarWhereInput[]
  }

  export type OfertaAcademicaCreateNestedManyWithoutCuatrimestreInput = {
    create?: XOR<OfertaAcademicaCreateWithoutCuatrimestreInput, OfertaAcademicaUncheckedCreateWithoutCuatrimestreInput> | OfertaAcademicaCreateWithoutCuatrimestreInput[] | OfertaAcademicaUncheckedCreateWithoutCuatrimestreInput[]
    connectOrCreate?: OfertaAcademicaCreateOrConnectWithoutCuatrimestreInput | OfertaAcademicaCreateOrConnectWithoutCuatrimestreInput[]
    createMany?: OfertaAcademicaCreateManyCuatrimestreInputEnvelope
    connect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
  }

  export type CursoCreateNestedManyWithoutCuatrimestreInput = {
    create?: XOR<CursoCreateWithoutCuatrimestreInput, CursoUncheckedCreateWithoutCuatrimestreInput> | CursoCreateWithoutCuatrimestreInput[] | CursoUncheckedCreateWithoutCuatrimestreInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutCuatrimestreInput | CursoCreateOrConnectWithoutCuatrimestreInput[]
    createMany?: CursoCreateManyCuatrimestreInputEnvelope
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
  }

  export type EncabezadoFacturaCreateNestedManyWithoutCuatrimestreInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutCuatrimestreInput, EncabezadoFacturaUncheckedCreateWithoutCuatrimestreInput> | EncabezadoFacturaCreateWithoutCuatrimestreInput[] | EncabezadoFacturaUncheckedCreateWithoutCuatrimestreInput[]
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutCuatrimestreInput | EncabezadoFacturaCreateOrConnectWithoutCuatrimestreInput[]
    createMany?: EncabezadoFacturaCreateManyCuatrimestreInputEnvelope
    connect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
  }

  export type OfertaAcademicaUncheckedCreateNestedManyWithoutCuatrimestreInput = {
    create?: XOR<OfertaAcademicaCreateWithoutCuatrimestreInput, OfertaAcademicaUncheckedCreateWithoutCuatrimestreInput> | OfertaAcademicaCreateWithoutCuatrimestreInput[] | OfertaAcademicaUncheckedCreateWithoutCuatrimestreInput[]
    connectOrCreate?: OfertaAcademicaCreateOrConnectWithoutCuatrimestreInput | OfertaAcademicaCreateOrConnectWithoutCuatrimestreInput[]
    createMany?: OfertaAcademicaCreateManyCuatrimestreInputEnvelope
    connect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
  }

  export type CursoUncheckedCreateNestedManyWithoutCuatrimestreInput = {
    create?: XOR<CursoCreateWithoutCuatrimestreInput, CursoUncheckedCreateWithoutCuatrimestreInput> | CursoCreateWithoutCuatrimestreInput[] | CursoUncheckedCreateWithoutCuatrimestreInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutCuatrimestreInput | CursoCreateOrConnectWithoutCuatrimestreInput[]
    createMany?: CursoCreateManyCuatrimestreInputEnvelope
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
  }

  export type EncabezadoFacturaUncheckedCreateNestedManyWithoutCuatrimestreInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutCuatrimestreInput, EncabezadoFacturaUncheckedCreateWithoutCuatrimestreInput> | EncabezadoFacturaCreateWithoutCuatrimestreInput[] | EncabezadoFacturaUncheckedCreateWithoutCuatrimestreInput[]
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutCuatrimestreInput | EncabezadoFacturaCreateOrConnectWithoutCuatrimestreInput[]
    createMany?: EncabezadoFacturaCreateManyCuatrimestreInputEnvelope
    connect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
  }

  export type OfertaAcademicaUpdateManyWithoutCuatrimestreNestedInput = {
    create?: XOR<OfertaAcademicaCreateWithoutCuatrimestreInput, OfertaAcademicaUncheckedCreateWithoutCuatrimestreInput> | OfertaAcademicaCreateWithoutCuatrimestreInput[] | OfertaAcademicaUncheckedCreateWithoutCuatrimestreInput[]
    connectOrCreate?: OfertaAcademicaCreateOrConnectWithoutCuatrimestreInput | OfertaAcademicaCreateOrConnectWithoutCuatrimestreInput[]
    upsert?: OfertaAcademicaUpsertWithWhereUniqueWithoutCuatrimestreInput | OfertaAcademicaUpsertWithWhereUniqueWithoutCuatrimestreInput[]
    createMany?: OfertaAcademicaCreateManyCuatrimestreInputEnvelope
    set?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    disconnect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    delete?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    connect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    update?: OfertaAcademicaUpdateWithWhereUniqueWithoutCuatrimestreInput | OfertaAcademicaUpdateWithWhereUniqueWithoutCuatrimestreInput[]
    updateMany?: OfertaAcademicaUpdateManyWithWhereWithoutCuatrimestreInput | OfertaAcademicaUpdateManyWithWhereWithoutCuatrimestreInput[]
    deleteMany?: OfertaAcademicaScalarWhereInput | OfertaAcademicaScalarWhereInput[]
  }

  export type CursoUpdateManyWithoutCuatrimestreNestedInput = {
    create?: XOR<CursoCreateWithoutCuatrimestreInput, CursoUncheckedCreateWithoutCuatrimestreInput> | CursoCreateWithoutCuatrimestreInput[] | CursoUncheckedCreateWithoutCuatrimestreInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutCuatrimestreInput | CursoCreateOrConnectWithoutCuatrimestreInput[]
    upsert?: CursoUpsertWithWhereUniqueWithoutCuatrimestreInput | CursoUpsertWithWhereUniqueWithoutCuatrimestreInput[]
    createMany?: CursoCreateManyCuatrimestreInputEnvelope
    set?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    disconnect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    delete?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    update?: CursoUpdateWithWhereUniqueWithoutCuatrimestreInput | CursoUpdateWithWhereUniqueWithoutCuatrimestreInput[]
    updateMany?: CursoUpdateManyWithWhereWithoutCuatrimestreInput | CursoUpdateManyWithWhereWithoutCuatrimestreInput[]
    deleteMany?: CursoScalarWhereInput | CursoScalarWhereInput[]
  }

  export type EncabezadoFacturaUpdateManyWithoutCuatrimestreNestedInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutCuatrimestreInput, EncabezadoFacturaUncheckedCreateWithoutCuatrimestreInput> | EncabezadoFacturaCreateWithoutCuatrimestreInput[] | EncabezadoFacturaUncheckedCreateWithoutCuatrimestreInput[]
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutCuatrimestreInput | EncabezadoFacturaCreateOrConnectWithoutCuatrimestreInput[]
    upsert?: EncabezadoFacturaUpsertWithWhereUniqueWithoutCuatrimestreInput | EncabezadoFacturaUpsertWithWhereUniqueWithoutCuatrimestreInput[]
    createMany?: EncabezadoFacturaCreateManyCuatrimestreInputEnvelope
    set?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    disconnect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    delete?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    connect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    update?: EncabezadoFacturaUpdateWithWhereUniqueWithoutCuatrimestreInput | EncabezadoFacturaUpdateWithWhereUniqueWithoutCuatrimestreInput[]
    updateMany?: EncabezadoFacturaUpdateManyWithWhereWithoutCuatrimestreInput | EncabezadoFacturaUpdateManyWithWhereWithoutCuatrimestreInput[]
    deleteMany?: EncabezadoFacturaScalarWhereInput | EncabezadoFacturaScalarWhereInput[]
  }

  export type OfertaAcademicaUncheckedUpdateManyWithoutCuatrimestreNestedInput = {
    create?: XOR<OfertaAcademicaCreateWithoutCuatrimestreInput, OfertaAcademicaUncheckedCreateWithoutCuatrimestreInput> | OfertaAcademicaCreateWithoutCuatrimestreInput[] | OfertaAcademicaUncheckedCreateWithoutCuatrimestreInput[]
    connectOrCreate?: OfertaAcademicaCreateOrConnectWithoutCuatrimestreInput | OfertaAcademicaCreateOrConnectWithoutCuatrimestreInput[]
    upsert?: OfertaAcademicaUpsertWithWhereUniqueWithoutCuatrimestreInput | OfertaAcademicaUpsertWithWhereUniqueWithoutCuatrimestreInput[]
    createMany?: OfertaAcademicaCreateManyCuatrimestreInputEnvelope
    set?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    disconnect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    delete?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    connect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    update?: OfertaAcademicaUpdateWithWhereUniqueWithoutCuatrimestreInput | OfertaAcademicaUpdateWithWhereUniqueWithoutCuatrimestreInput[]
    updateMany?: OfertaAcademicaUpdateManyWithWhereWithoutCuatrimestreInput | OfertaAcademicaUpdateManyWithWhereWithoutCuatrimestreInput[]
    deleteMany?: OfertaAcademicaScalarWhereInput | OfertaAcademicaScalarWhereInput[]
  }

  export type CursoUncheckedUpdateManyWithoutCuatrimestreNestedInput = {
    create?: XOR<CursoCreateWithoutCuatrimestreInput, CursoUncheckedCreateWithoutCuatrimestreInput> | CursoCreateWithoutCuatrimestreInput[] | CursoUncheckedCreateWithoutCuatrimestreInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutCuatrimestreInput | CursoCreateOrConnectWithoutCuatrimestreInput[]
    upsert?: CursoUpsertWithWhereUniqueWithoutCuatrimestreInput | CursoUpsertWithWhereUniqueWithoutCuatrimestreInput[]
    createMany?: CursoCreateManyCuatrimestreInputEnvelope
    set?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    disconnect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    delete?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    update?: CursoUpdateWithWhereUniqueWithoutCuatrimestreInput | CursoUpdateWithWhereUniqueWithoutCuatrimestreInput[]
    updateMany?: CursoUpdateManyWithWhereWithoutCuatrimestreInput | CursoUpdateManyWithWhereWithoutCuatrimestreInput[]
    deleteMany?: CursoScalarWhereInput | CursoScalarWhereInput[]
  }

  export type EncabezadoFacturaUncheckedUpdateManyWithoutCuatrimestreNestedInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutCuatrimestreInput, EncabezadoFacturaUncheckedCreateWithoutCuatrimestreInput> | EncabezadoFacturaCreateWithoutCuatrimestreInput[] | EncabezadoFacturaUncheckedCreateWithoutCuatrimestreInput[]
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutCuatrimestreInput | EncabezadoFacturaCreateOrConnectWithoutCuatrimestreInput[]
    upsert?: EncabezadoFacturaUpsertWithWhereUniqueWithoutCuatrimestreInput | EncabezadoFacturaUpsertWithWhereUniqueWithoutCuatrimestreInput[]
    createMany?: EncabezadoFacturaCreateManyCuatrimestreInputEnvelope
    set?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    disconnect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    delete?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    connect?: EncabezadoFacturaWhereUniqueInput | EncabezadoFacturaWhereUniqueInput[]
    update?: EncabezadoFacturaUpdateWithWhereUniqueWithoutCuatrimestreInput | EncabezadoFacturaUpdateWithWhereUniqueWithoutCuatrimestreInput[]
    updateMany?: EncabezadoFacturaUpdateManyWithWhereWithoutCuatrimestreInput | EncabezadoFacturaUpdateManyWithWhereWithoutCuatrimestreInput[]
    deleteMany?: EncabezadoFacturaScalarWhereInput | EncabezadoFacturaScalarWhereInput[]
  }

  export type PlanEstudiosCreateNestedOneWithoutMateriaInput = {
    create?: XOR<PlanEstudiosCreateWithoutMateriaInput, PlanEstudiosUncheckedCreateWithoutMateriaInput>
    connectOrCreate?: PlanEstudiosCreateOrConnectWithoutMateriaInput
    connect?: PlanEstudiosWhereUniqueInput
  }

  export type CursoCreateNestedManyWithoutMateriaInput = {
    create?: XOR<CursoCreateWithoutMateriaInput, CursoUncheckedCreateWithoutMateriaInput> | CursoCreateWithoutMateriaInput[] | CursoUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutMateriaInput | CursoCreateOrConnectWithoutMateriaInput[]
    createMany?: CursoCreateManyMateriaInputEnvelope
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
  }

  export type CursoUncheckedCreateNestedManyWithoutMateriaInput = {
    create?: XOR<CursoCreateWithoutMateriaInput, CursoUncheckedCreateWithoutMateriaInput> | CursoCreateWithoutMateriaInput[] | CursoUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutMateriaInput | CursoCreateOrConnectWithoutMateriaInput[]
    createMany?: CursoCreateManyMateriaInputEnvelope
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
  }

  export type PlanEstudiosUpdateOneRequiredWithoutMateriaNestedInput = {
    create?: XOR<PlanEstudiosCreateWithoutMateriaInput, PlanEstudiosUncheckedCreateWithoutMateriaInput>
    connectOrCreate?: PlanEstudiosCreateOrConnectWithoutMateriaInput
    upsert?: PlanEstudiosUpsertWithoutMateriaInput
    connect?: PlanEstudiosWhereUniqueInput
    update?: XOR<XOR<PlanEstudiosUpdateToOneWithWhereWithoutMateriaInput, PlanEstudiosUpdateWithoutMateriaInput>, PlanEstudiosUncheckedUpdateWithoutMateriaInput>
  }

  export type CursoUpdateManyWithoutMateriaNestedInput = {
    create?: XOR<CursoCreateWithoutMateriaInput, CursoUncheckedCreateWithoutMateriaInput> | CursoCreateWithoutMateriaInput[] | CursoUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutMateriaInput | CursoCreateOrConnectWithoutMateriaInput[]
    upsert?: CursoUpsertWithWhereUniqueWithoutMateriaInput | CursoUpsertWithWhereUniqueWithoutMateriaInput[]
    createMany?: CursoCreateManyMateriaInputEnvelope
    set?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    disconnect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    delete?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    update?: CursoUpdateWithWhereUniqueWithoutMateriaInput | CursoUpdateWithWhereUniqueWithoutMateriaInput[]
    updateMany?: CursoUpdateManyWithWhereWithoutMateriaInput | CursoUpdateManyWithWhereWithoutMateriaInput[]
    deleteMany?: CursoScalarWhereInput | CursoScalarWhereInput[]
  }

  export type CursoUncheckedUpdateManyWithoutMateriaNestedInput = {
    create?: XOR<CursoCreateWithoutMateriaInput, CursoUncheckedCreateWithoutMateriaInput> | CursoCreateWithoutMateriaInput[] | CursoUncheckedCreateWithoutMateriaInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutMateriaInput | CursoCreateOrConnectWithoutMateriaInput[]
    upsert?: CursoUpsertWithWhereUniqueWithoutMateriaInput | CursoUpsertWithWhereUniqueWithoutMateriaInput[]
    createMany?: CursoCreateManyMateriaInputEnvelope
    set?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    disconnect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    delete?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    update?: CursoUpdateWithWhereUniqueWithoutMateriaInput | CursoUpdateWithWhereUniqueWithoutMateriaInput[]
    updateMany?: CursoUpdateManyWithWhereWithoutMateriaInput | CursoUpdateManyWithWhereWithoutMateriaInput[]
    deleteMany?: CursoScalarWhereInput | CursoScalarWhereInput[]
  }

  export type MateriaCreateNestedOneWithoutCursoInput = {
    create?: XOR<MateriaCreateWithoutCursoInput, MateriaUncheckedCreateWithoutCursoInput>
    connectOrCreate?: MateriaCreateOrConnectWithoutCursoInput
    connect?: MateriaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutCursoInput = {
    create?: XOR<UsuarioCreateWithoutCursoInput, UsuarioUncheckedCreateWithoutCursoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCursoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type CuatrimestreCreateNestedOneWithoutCursoInput = {
    create?: XOR<CuatrimestreCreateWithoutCursoInput, CuatrimestreUncheckedCreateWithoutCursoInput>
    connectOrCreate?: CuatrimestreCreateOrConnectWithoutCursoInput
    connect?: CuatrimestreWhereUniqueInput
  }

  export type DetalleFacturaCreateNestedManyWithoutCursoInput = {
    create?: XOR<DetalleFacturaCreateWithoutCursoInput, DetalleFacturaUncheckedCreateWithoutCursoInput> | DetalleFacturaCreateWithoutCursoInput[] | DetalleFacturaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: DetalleFacturaCreateOrConnectWithoutCursoInput | DetalleFacturaCreateOrConnectWithoutCursoInput[]
    createMany?: DetalleFacturaCreateManyCursoInputEnvelope
    connect?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
  }

  export type OfertaAcademicaCreateNestedManyWithoutCursoInput = {
    create?: XOR<OfertaAcademicaCreateWithoutCursoInput, OfertaAcademicaUncheckedCreateWithoutCursoInput> | OfertaAcademicaCreateWithoutCursoInput[] | OfertaAcademicaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: OfertaAcademicaCreateOrConnectWithoutCursoInput | OfertaAcademicaCreateOrConnectWithoutCursoInput[]
    createMany?: OfertaAcademicaCreateManyCursoInputEnvelope
    connect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
  }

  export type HistoricoAcademicoCreateNestedManyWithoutCursoInput = {
    create?: XOR<HistoricoAcademicoCreateWithoutCursoInput, HistoricoAcademicoUncheckedCreateWithoutCursoInput> | HistoricoAcademicoCreateWithoutCursoInput[] | HistoricoAcademicoUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: HistoricoAcademicoCreateOrConnectWithoutCursoInput | HistoricoAcademicoCreateOrConnectWithoutCursoInput[]
    createMany?: HistoricoAcademicoCreateManyCursoInputEnvelope
    connect?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
  }

  export type MatriculaCreateNestedManyWithoutCursoInput = {
    create?: XOR<MatriculaCreateWithoutCursoInput, MatriculaUncheckedCreateWithoutCursoInput> | MatriculaCreateWithoutCursoInput[] | MatriculaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutCursoInput | MatriculaCreateOrConnectWithoutCursoInput[]
    createMany?: MatriculaCreateManyCursoInputEnvelope
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
  }

  export type DetalleFacturaUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<DetalleFacturaCreateWithoutCursoInput, DetalleFacturaUncheckedCreateWithoutCursoInput> | DetalleFacturaCreateWithoutCursoInput[] | DetalleFacturaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: DetalleFacturaCreateOrConnectWithoutCursoInput | DetalleFacturaCreateOrConnectWithoutCursoInput[]
    createMany?: DetalleFacturaCreateManyCursoInputEnvelope
    connect?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
  }

  export type OfertaAcademicaUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<OfertaAcademicaCreateWithoutCursoInput, OfertaAcademicaUncheckedCreateWithoutCursoInput> | OfertaAcademicaCreateWithoutCursoInput[] | OfertaAcademicaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: OfertaAcademicaCreateOrConnectWithoutCursoInput | OfertaAcademicaCreateOrConnectWithoutCursoInput[]
    createMany?: OfertaAcademicaCreateManyCursoInputEnvelope
    connect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
  }

  export type HistoricoAcademicoUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<HistoricoAcademicoCreateWithoutCursoInput, HistoricoAcademicoUncheckedCreateWithoutCursoInput> | HistoricoAcademicoCreateWithoutCursoInput[] | HistoricoAcademicoUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: HistoricoAcademicoCreateOrConnectWithoutCursoInput | HistoricoAcademicoCreateOrConnectWithoutCursoInput[]
    createMany?: HistoricoAcademicoCreateManyCursoInputEnvelope
    connect?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
  }

  export type MatriculaUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<MatriculaCreateWithoutCursoInput, MatriculaUncheckedCreateWithoutCursoInput> | MatriculaCreateWithoutCursoInput[] | MatriculaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutCursoInput | MatriculaCreateOrConnectWithoutCursoInput[]
    createMany?: MatriculaCreateManyCursoInputEnvelope
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
  }

  export type MateriaUpdateOneRequiredWithoutCursoNestedInput = {
    create?: XOR<MateriaCreateWithoutCursoInput, MateriaUncheckedCreateWithoutCursoInput>
    connectOrCreate?: MateriaCreateOrConnectWithoutCursoInput
    upsert?: MateriaUpsertWithoutCursoInput
    connect?: MateriaWhereUniqueInput
    update?: XOR<XOR<MateriaUpdateToOneWithWhereWithoutCursoInput, MateriaUpdateWithoutCursoInput>, MateriaUncheckedUpdateWithoutCursoInput>
  }

  export type UsuarioUpdateOneRequiredWithoutCursoNestedInput = {
    create?: XOR<UsuarioCreateWithoutCursoInput, UsuarioUncheckedCreateWithoutCursoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCursoInput
    upsert?: UsuarioUpsertWithoutCursoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutCursoInput, UsuarioUpdateWithoutCursoInput>, UsuarioUncheckedUpdateWithoutCursoInput>
  }

  export type CuatrimestreUpdateOneRequiredWithoutCursoNestedInput = {
    create?: XOR<CuatrimestreCreateWithoutCursoInput, CuatrimestreUncheckedCreateWithoutCursoInput>
    connectOrCreate?: CuatrimestreCreateOrConnectWithoutCursoInput
    upsert?: CuatrimestreUpsertWithoutCursoInput
    connect?: CuatrimestreWhereUniqueInput
    update?: XOR<XOR<CuatrimestreUpdateToOneWithWhereWithoutCursoInput, CuatrimestreUpdateWithoutCursoInput>, CuatrimestreUncheckedUpdateWithoutCursoInput>
  }

  export type DetalleFacturaUpdateManyWithoutCursoNestedInput = {
    create?: XOR<DetalleFacturaCreateWithoutCursoInput, DetalleFacturaUncheckedCreateWithoutCursoInput> | DetalleFacturaCreateWithoutCursoInput[] | DetalleFacturaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: DetalleFacturaCreateOrConnectWithoutCursoInput | DetalleFacturaCreateOrConnectWithoutCursoInput[]
    upsert?: DetalleFacturaUpsertWithWhereUniqueWithoutCursoInput | DetalleFacturaUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: DetalleFacturaCreateManyCursoInputEnvelope
    set?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    disconnect?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    delete?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    connect?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    update?: DetalleFacturaUpdateWithWhereUniqueWithoutCursoInput | DetalleFacturaUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: DetalleFacturaUpdateManyWithWhereWithoutCursoInput | DetalleFacturaUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: DetalleFacturaScalarWhereInput | DetalleFacturaScalarWhereInput[]
  }

  export type OfertaAcademicaUpdateManyWithoutCursoNestedInput = {
    create?: XOR<OfertaAcademicaCreateWithoutCursoInput, OfertaAcademicaUncheckedCreateWithoutCursoInput> | OfertaAcademicaCreateWithoutCursoInput[] | OfertaAcademicaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: OfertaAcademicaCreateOrConnectWithoutCursoInput | OfertaAcademicaCreateOrConnectWithoutCursoInput[]
    upsert?: OfertaAcademicaUpsertWithWhereUniqueWithoutCursoInput | OfertaAcademicaUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: OfertaAcademicaCreateManyCursoInputEnvelope
    set?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    disconnect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    delete?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    connect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    update?: OfertaAcademicaUpdateWithWhereUniqueWithoutCursoInput | OfertaAcademicaUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: OfertaAcademicaUpdateManyWithWhereWithoutCursoInput | OfertaAcademicaUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: OfertaAcademicaScalarWhereInput | OfertaAcademicaScalarWhereInput[]
  }

  export type HistoricoAcademicoUpdateManyWithoutCursoNestedInput = {
    create?: XOR<HistoricoAcademicoCreateWithoutCursoInput, HistoricoAcademicoUncheckedCreateWithoutCursoInput> | HistoricoAcademicoCreateWithoutCursoInput[] | HistoricoAcademicoUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: HistoricoAcademicoCreateOrConnectWithoutCursoInput | HistoricoAcademicoCreateOrConnectWithoutCursoInput[]
    upsert?: HistoricoAcademicoUpsertWithWhereUniqueWithoutCursoInput | HistoricoAcademicoUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: HistoricoAcademicoCreateManyCursoInputEnvelope
    set?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    disconnect?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    delete?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    connect?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    update?: HistoricoAcademicoUpdateWithWhereUniqueWithoutCursoInput | HistoricoAcademicoUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: HistoricoAcademicoUpdateManyWithWhereWithoutCursoInput | HistoricoAcademicoUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: HistoricoAcademicoScalarWhereInput | HistoricoAcademicoScalarWhereInput[]
  }

  export type MatriculaUpdateManyWithoutCursoNestedInput = {
    create?: XOR<MatriculaCreateWithoutCursoInput, MatriculaUncheckedCreateWithoutCursoInput> | MatriculaCreateWithoutCursoInput[] | MatriculaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutCursoInput | MatriculaCreateOrConnectWithoutCursoInput[]
    upsert?: MatriculaUpsertWithWhereUniqueWithoutCursoInput | MatriculaUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: MatriculaCreateManyCursoInputEnvelope
    set?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    disconnect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    delete?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    update?: MatriculaUpdateWithWhereUniqueWithoutCursoInput | MatriculaUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: MatriculaUpdateManyWithWhereWithoutCursoInput | MatriculaUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: MatriculaScalarWhereInput | MatriculaScalarWhereInput[]
  }

  export type DetalleFacturaUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<DetalleFacturaCreateWithoutCursoInput, DetalleFacturaUncheckedCreateWithoutCursoInput> | DetalleFacturaCreateWithoutCursoInput[] | DetalleFacturaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: DetalleFacturaCreateOrConnectWithoutCursoInput | DetalleFacturaCreateOrConnectWithoutCursoInput[]
    upsert?: DetalleFacturaUpsertWithWhereUniqueWithoutCursoInput | DetalleFacturaUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: DetalleFacturaCreateManyCursoInputEnvelope
    set?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    disconnect?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    delete?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    connect?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    update?: DetalleFacturaUpdateWithWhereUniqueWithoutCursoInput | DetalleFacturaUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: DetalleFacturaUpdateManyWithWhereWithoutCursoInput | DetalleFacturaUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: DetalleFacturaScalarWhereInput | DetalleFacturaScalarWhereInput[]
  }

  export type OfertaAcademicaUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<OfertaAcademicaCreateWithoutCursoInput, OfertaAcademicaUncheckedCreateWithoutCursoInput> | OfertaAcademicaCreateWithoutCursoInput[] | OfertaAcademicaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: OfertaAcademicaCreateOrConnectWithoutCursoInput | OfertaAcademicaCreateOrConnectWithoutCursoInput[]
    upsert?: OfertaAcademicaUpsertWithWhereUniqueWithoutCursoInput | OfertaAcademicaUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: OfertaAcademicaCreateManyCursoInputEnvelope
    set?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    disconnect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    delete?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    connect?: OfertaAcademicaWhereUniqueInput | OfertaAcademicaWhereUniqueInput[]
    update?: OfertaAcademicaUpdateWithWhereUniqueWithoutCursoInput | OfertaAcademicaUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: OfertaAcademicaUpdateManyWithWhereWithoutCursoInput | OfertaAcademicaUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: OfertaAcademicaScalarWhereInput | OfertaAcademicaScalarWhereInput[]
  }

  export type HistoricoAcademicoUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<HistoricoAcademicoCreateWithoutCursoInput, HistoricoAcademicoUncheckedCreateWithoutCursoInput> | HistoricoAcademicoCreateWithoutCursoInput[] | HistoricoAcademicoUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: HistoricoAcademicoCreateOrConnectWithoutCursoInput | HistoricoAcademicoCreateOrConnectWithoutCursoInput[]
    upsert?: HistoricoAcademicoUpsertWithWhereUniqueWithoutCursoInput | HistoricoAcademicoUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: HistoricoAcademicoCreateManyCursoInputEnvelope
    set?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    disconnect?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    delete?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    connect?: HistoricoAcademicoWhereUniqueInput | HistoricoAcademicoWhereUniqueInput[]
    update?: HistoricoAcademicoUpdateWithWhereUniqueWithoutCursoInput | HistoricoAcademicoUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: HistoricoAcademicoUpdateManyWithWhereWithoutCursoInput | HistoricoAcademicoUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: HistoricoAcademicoScalarWhereInput | HistoricoAcademicoScalarWhereInput[]
  }

  export type MatriculaUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<MatriculaCreateWithoutCursoInput, MatriculaUncheckedCreateWithoutCursoInput> | MatriculaCreateWithoutCursoInput[] | MatriculaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutCursoInput | MatriculaCreateOrConnectWithoutCursoInput[]
    upsert?: MatriculaUpsertWithWhereUniqueWithoutCursoInput | MatriculaUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: MatriculaCreateManyCursoInputEnvelope
    set?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    disconnect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    delete?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    update?: MatriculaUpdateWithWhereUniqueWithoutCursoInput | MatriculaUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: MatriculaUpdateManyWithWhereWithoutCursoInput | MatriculaUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: MatriculaScalarWhereInput | MatriculaScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutMatriculaInput = {
    create?: XOR<UsuarioCreateWithoutMatriculaInput, UsuarioUncheckedCreateWithoutMatriculaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMatriculaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type CursoCreateNestedOneWithoutCuMatriculaInput = {
    create?: XOR<CursoCreateWithoutCuMatriculaInput, CursoUncheckedCreateWithoutCuMatriculaInput>
    connectOrCreate?: CursoCreateOrConnectWithoutCuMatriculaInput
    connect?: CursoWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UsuarioUpdateOneRequiredWithoutMatriculaNestedInput = {
    create?: XOR<UsuarioCreateWithoutMatriculaInput, UsuarioUncheckedCreateWithoutMatriculaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMatriculaInput
    upsert?: UsuarioUpsertWithoutMatriculaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutMatriculaInput, UsuarioUpdateWithoutMatriculaInput>, UsuarioUncheckedUpdateWithoutMatriculaInput>
  }

  export type CursoUpdateOneRequiredWithoutCuMatriculaNestedInput = {
    create?: XOR<CursoCreateWithoutCuMatriculaInput, CursoUncheckedCreateWithoutCuMatriculaInput>
    connectOrCreate?: CursoCreateOrConnectWithoutCuMatriculaInput
    upsert?: CursoUpsertWithoutCuMatriculaInput
    connect?: CursoWhereUniqueInput
    update?: XOR<XOR<CursoUpdateToOneWithWhereWithoutCuMatriculaInput, CursoUpdateWithoutCuMatriculaInput>, CursoUncheckedUpdateWithoutCuMatriculaInput>
  }

  export type CursoCreateNestedOneWithoutOfertaAcademicaInput = {
    create?: XOR<CursoCreateWithoutOfertaAcademicaInput, CursoUncheckedCreateWithoutOfertaAcademicaInput>
    connectOrCreate?: CursoCreateOrConnectWithoutOfertaAcademicaInput
    connect?: CursoWhereUniqueInput
  }

  export type CuatrimestreCreateNestedOneWithoutOfertaAcademicaInput = {
    create?: XOR<CuatrimestreCreateWithoutOfertaAcademicaInput, CuatrimestreUncheckedCreateWithoutOfertaAcademicaInput>
    connectOrCreate?: CuatrimestreCreateOrConnectWithoutOfertaAcademicaInput
    connect?: CuatrimestreWhereUniqueInput
  }

  export type CarreraCreateNestedOneWithoutOfertaAcademicaInput = {
    create?: XOR<CarreraCreateWithoutOfertaAcademicaInput, CarreraUncheckedCreateWithoutOfertaAcademicaInput>
    connectOrCreate?: CarreraCreateOrConnectWithoutOfertaAcademicaInput
    connect?: CarreraWhereUniqueInput
  }

  export type CursoUpdateOneRequiredWithoutOfertaAcademicaNestedInput = {
    create?: XOR<CursoCreateWithoutOfertaAcademicaInput, CursoUncheckedCreateWithoutOfertaAcademicaInput>
    connectOrCreate?: CursoCreateOrConnectWithoutOfertaAcademicaInput
    upsert?: CursoUpsertWithoutOfertaAcademicaInput
    connect?: CursoWhereUniqueInput
    update?: XOR<XOR<CursoUpdateToOneWithWhereWithoutOfertaAcademicaInput, CursoUpdateWithoutOfertaAcademicaInput>, CursoUncheckedUpdateWithoutOfertaAcademicaInput>
  }

  export type CuatrimestreUpdateOneRequiredWithoutOfertaAcademicaNestedInput = {
    create?: XOR<CuatrimestreCreateWithoutOfertaAcademicaInput, CuatrimestreUncheckedCreateWithoutOfertaAcademicaInput>
    connectOrCreate?: CuatrimestreCreateOrConnectWithoutOfertaAcademicaInput
    upsert?: CuatrimestreUpsertWithoutOfertaAcademicaInput
    connect?: CuatrimestreWhereUniqueInput
    update?: XOR<XOR<CuatrimestreUpdateToOneWithWhereWithoutOfertaAcademicaInput, CuatrimestreUpdateWithoutOfertaAcademicaInput>, CuatrimestreUncheckedUpdateWithoutOfertaAcademicaInput>
  }

  export type CarreraUpdateOneRequiredWithoutOfertaAcademicaNestedInput = {
    create?: XOR<CarreraCreateWithoutOfertaAcademicaInput, CarreraUncheckedCreateWithoutOfertaAcademicaInput>
    connectOrCreate?: CarreraCreateOrConnectWithoutOfertaAcademicaInput
    upsert?: CarreraUpsertWithoutOfertaAcademicaInput
    connect?: CarreraWhereUniqueInput
    update?: XOR<XOR<CarreraUpdateToOneWithWhereWithoutOfertaAcademicaInput, CarreraUpdateWithoutOfertaAcademicaInput>, CarreraUncheckedUpdateWithoutOfertaAcademicaInput>
  }

  export type UsuarioCreateNestedOneWithoutHistoricoAcademicoInput = {
    create?: XOR<UsuarioCreateWithoutHistoricoAcademicoInput, UsuarioUncheckedCreateWithoutHistoricoAcademicoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutHistoricoAcademicoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type CursoCreateNestedOneWithoutHistoricoAcademicoInput = {
    create?: XOR<CursoCreateWithoutHistoricoAcademicoInput, CursoUncheckedCreateWithoutHistoricoAcademicoInput>
    connectOrCreate?: CursoCreateOrConnectWithoutHistoricoAcademicoInput
    connect?: CursoWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsuarioUpdateOneRequiredWithoutHistoricoAcademicoNestedInput = {
    create?: XOR<UsuarioCreateWithoutHistoricoAcademicoInput, UsuarioUncheckedCreateWithoutHistoricoAcademicoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutHistoricoAcademicoInput
    upsert?: UsuarioUpsertWithoutHistoricoAcademicoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutHistoricoAcademicoInput, UsuarioUpdateWithoutHistoricoAcademicoInput>, UsuarioUncheckedUpdateWithoutHistoricoAcademicoInput>
  }

  export type CursoUpdateOneRequiredWithoutHistoricoAcademicoNestedInput = {
    create?: XOR<CursoCreateWithoutHistoricoAcademicoInput, CursoUncheckedCreateWithoutHistoricoAcademicoInput>
    connectOrCreate?: CursoCreateOrConnectWithoutHistoricoAcademicoInput
    upsert?: CursoUpsertWithoutHistoricoAcademicoInput
    connect?: CursoWhereUniqueInput
    update?: XOR<XOR<CursoUpdateToOneWithWhereWithoutHistoricoAcademicoInput, CursoUpdateWithoutHistoricoAcademicoInput>, CursoUncheckedUpdateWithoutHistoricoAcademicoInput>
  }

  export type UsuarioCreateNestedOneWithoutAuditoriaInput = {
    create?: XOR<UsuarioCreateWithoutAuditoriaInput, UsuarioUncheckedCreateWithoutAuditoriaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAuditoriaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutAuditoriaNestedInput = {
    create?: XOR<UsuarioCreateWithoutAuditoriaInput, UsuarioUncheckedCreateWithoutAuditoriaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAuditoriaInput
    upsert?: UsuarioUpsertWithoutAuditoriaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutAuditoriaInput, UsuarioUpdateWithoutAuditoriaInput>, UsuarioUncheckedUpdateWithoutAuditoriaInput>
  }

  export type CarreraCreateNestedOneWithoutEncabezadoFacturaInput = {
    create?: XOR<CarreraCreateWithoutEncabezadoFacturaInput, CarreraUncheckedCreateWithoutEncabezadoFacturaInput>
    connectOrCreate?: CarreraCreateOrConnectWithoutEncabezadoFacturaInput
    connect?: CarreraWhereUniqueInput
  }

  export type CuatrimestreCreateNestedOneWithoutEncabezadoFacturaInput = {
    create?: XOR<CuatrimestreCreateWithoutEncabezadoFacturaInput, CuatrimestreUncheckedCreateWithoutEncabezadoFacturaInput>
    connectOrCreate?: CuatrimestreCreateOrConnectWithoutEncabezadoFacturaInput
    connect?: CuatrimestreWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutEncabezadoFacturaInput = {
    create?: XOR<UsuarioCreateWithoutEncabezadoFacturaInput, UsuarioUncheckedCreateWithoutEncabezadoFacturaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEncabezadoFacturaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type DetalleFacturaCreateNestedManyWithoutEncabezadoFacturaInput = {
    create?: XOR<DetalleFacturaCreateWithoutEncabezadoFacturaInput, DetalleFacturaUncheckedCreateWithoutEncabezadoFacturaInput> | DetalleFacturaCreateWithoutEncabezadoFacturaInput[] | DetalleFacturaUncheckedCreateWithoutEncabezadoFacturaInput[]
    connectOrCreate?: DetalleFacturaCreateOrConnectWithoutEncabezadoFacturaInput | DetalleFacturaCreateOrConnectWithoutEncabezadoFacturaInput[]
    createMany?: DetalleFacturaCreateManyEncabezadoFacturaInputEnvelope
    connect?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
  }

  export type DetalleFacturaUncheckedCreateNestedManyWithoutEncabezadoFacturaInput = {
    create?: XOR<DetalleFacturaCreateWithoutEncabezadoFacturaInput, DetalleFacturaUncheckedCreateWithoutEncabezadoFacturaInput> | DetalleFacturaCreateWithoutEncabezadoFacturaInput[] | DetalleFacturaUncheckedCreateWithoutEncabezadoFacturaInput[]
    connectOrCreate?: DetalleFacturaCreateOrConnectWithoutEncabezadoFacturaInput | DetalleFacturaCreateOrConnectWithoutEncabezadoFacturaInput[]
    createMany?: DetalleFacturaCreateManyEncabezadoFacturaInputEnvelope
    connect?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
  }

  export type CarreraUpdateOneRequiredWithoutEncabezadoFacturaNestedInput = {
    create?: XOR<CarreraCreateWithoutEncabezadoFacturaInput, CarreraUncheckedCreateWithoutEncabezadoFacturaInput>
    connectOrCreate?: CarreraCreateOrConnectWithoutEncabezadoFacturaInput
    upsert?: CarreraUpsertWithoutEncabezadoFacturaInput
    connect?: CarreraWhereUniqueInput
    update?: XOR<XOR<CarreraUpdateToOneWithWhereWithoutEncabezadoFacturaInput, CarreraUpdateWithoutEncabezadoFacturaInput>, CarreraUncheckedUpdateWithoutEncabezadoFacturaInput>
  }

  export type CuatrimestreUpdateOneRequiredWithoutEncabezadoFacturaNestedInput = {
    create?: XOR<CuatrimestreCreateWithoutEncabezadoFacturaInput, CuatrimestreUncheckedCreateWithoutEncabezadoFacturaInput>
    connectOrCreate?: CuatrimestreCreateOrConnectWithoutEncabezadoFacturaInput
    upsert?: CuatrimestreUpsertWithoutEncabezadoFacturaInput
    connect?: CuatrimestreWhereUniqueInput
    update?: XOR<XOR<CuatrimestreUpdateToOneWithWhereWithoutEncabezadoFacturaInput, CuatrimestreUpdateWithoutEncabezadoFacturaInput>, CuatrimestreUncheckedUpdateWithoutEncabezadoFacturaInput>
  }

  export type UsuarioUpdateOneRequiredWithoutEncabezadoFacturaNestedInput = {
    create?: XOR<UsuarioCreateWithoutEncabezadoFacturaInput, UsuarioUncheckedCreateWithoutEncabezadoFacturaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEncabezadoFacturaInput
    upsert?: UsuarioUpsertWithoutEncabezadoFacturaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEncabezadoFacturaInput, UsuarioUpdateWithoutEncabezadoFacturaInput>, UsuarioUncheckedUpdateWithoutEncabezadoFacturaInput>
  }

  export type DetalleFacturaUpdateManyWithoutEncabezadoFacturaNestedInput = {
    create?: XOR<DetalleFacturaCreateWithoutEncabezadoFacturaInput, DetalleFacturaUncheckedCreateWithoutEncabezadoFacturaInput> | DetalleFacturaCreateWithoutEncabezadoFacturaInput[] | DetalleFacturaUncheckedCreateWithoutEncabezadoFacturaInput[]
    connectOrCreate?: DetalleFacturaCreateOrConnectWithoutEncabezadoFacturaInput | DetalleFacturaCreateOrConnectWithoutEncabezadoFacturaInput[]
    upsert?: DetalleFacturaUpsertWithWhereUniqueWithoutEncabezadoFacturaInput | DetalleFacturaUpsertWithWhereUniqueWithoutEncabezadoFacturaInput[]
    createMany?: DetalleFacturaCreateManyEncabezadoFacturaInputEnvelope
    set?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    disconnect?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    delete?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    connect?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    update?: DetalleFacturaUpdateWithWhereUniqueWithoutEncabezadoFacturaInput | DetalleFacturaUpdateWithWhereUniqueWithoutEncabezadoFacturaInput[]
    updateMany?: DetalleFacturaUpdateManyWithWhereWithoutEncabezadoFacturaInput | DetalleFacturaUpdateManyWithWhereWithoutEncabezadoFacturaInput[]
    deleteMany?: DetalleFacturaScalarWhereInput | DetalleFacturaScalarWhereInput[]
  }

  export type DetalleFacturaUncheckedUpdateManyWithoutEncabezadoFacturaNestedInput = {
    create?: XOR<DetalleFacturaCreateWithoutEncabezadoFacturaInput, DetalleFacturaUncheckedCreateWithoutEncabezadoFacturaInput> | DetalleFacturaCreateWithoutEncabezadoFacturaInput[] | DetalleFacturaUncheckedCreateWithoutEncabezadoFacturaInput[]
    connectOrCreate?: DetalleFacturaCreateOrConnectWithoutEncabezadoFacturaInput | DetalleFacturaCreateOrConnectWithoutEncabezadoFacturaInput[]
    upsert?: DetalleFacturaUpsertWithWhereUniqueWithoutEncabezadoFacturaInput | DetalleFacturaUpsertWithWhereUniqueWithoutEncabezadoFacturaInput[]
    createMany?: DetalleFacturaCreateManyEncabezadoFacturaInputEnvelope
    set?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    disconnect?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    delete?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    connect?: DetalleFacturaWhereUniqueInput | DetalleFacturaWhereUniqueInput[]
    update?: DetalleFacturaUpdateWithWhereUniqueWithoutEncabezadoFacturaInput | DetalleFacturaUpdateWithWhereUniqueWithoutEncabezadoFacturaInput[]
    updateMany?: DetalleFacturaUpdateManyWithWhereWithoutEncabezadoFacturaInput | DetalleFacturaUpdateManyWithWhereWithoutEncabezadoFacturaInput[]
    deleteMany?: DetalleFacturaScalarWhereInput | DetalleFacturaScalarWhereInput[]
  }

  export type CursoCreateNestedOneWithoutDetalleFacturaInput = {
    create?: XOR<CursoCreateWithoutDetalleFacturaInput, CursoUncheckedCreateWithoutDetalleFacturaInput>
    connectOrCreate?: CursoCreateOrConnectWithoutDetalleFacturaInput
    connect?: CursoWhereUniqueInput
  }

  export type EncabezadoFacturaCreateNestedOneWithoutDetalleFacturaInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutDetalleFacturaInput, EncabezadoFacturaUncheckedCreateWithoutDetalleFacturaInput>
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutDetalleFacturaInput
    connect?: EncabezadoFacturaWhereUniqueInput
  }

  export type CursoUpdateOneRequiredWithoutDetalleFacturaNestedInput = {
    create?: XOR<CursoCreateWithoutDetalleFacturaInput, CursoUncheckedCreateWithoutDetalleFacturaInput>
    connectOrCreate?: CursoCreateOrConnectWithoutDetalleFacturaInput
    upsert?: CursoUpsertWithoutDetalleFacturaInput
    connect?: CursoWhereUniqueInput
    update?: XOR<XOR<CursoUpdateToOneWithWhereWithoutDetalleFacturaInput, CursoUpdateWithoutDetalleFacturaInput>, CursoUncheckedUpdateWithoutDetalleFacturaInput>
  }

  export type EncabezadoFacturaUpdateOneRequiredWithoutDetalleFacturaNestedInput = {
    create?: XOR<EncabezadoFacturaCreateWithoutDetalleFacturaInput, EncabezadoFacturaUncheckedCreateWithoutDetalleFacturaInput>
    connectOrCreate?: EncabezadoFacturaCreateOrConnectWithoutDetalleFacturaInput
    upsert?: EncabezadoFacturaUpsertWithoutDetalleFacturaInput
    connect?: EncabezadoFacturaWhereUniqueInput
    update?: XOR<XOR<EncabezadoFacturaUpdateToOneWithWhereWithoutDetalleFacturaInput, EncabezadoFacturaUpdateWithoutDetalleFacturaInput>, EncabezadoFacturaUncheckedUpdateWithoutDetalleFacturaInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UsuarioCreateWithoutCargoInput = {
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    Carrera: CarreraCreateNestedOneWithoutUsuarioInput
    Curso?: CursoCreateNestedManyWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutCargoInput = {
    id?: number
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    id_carrera: number
    Curso?: CursoUncheckedCreateNestedManyWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutCargoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCargoInput, UsuarioUncheckedCreateWithoutCargoInput>
  }

  export type UsuarioCreateManyCargoInputEnvelope = {
    data: UsuarioCreateManyCargoInput | UsuarioCreateManyCargoInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithWhereUniqueWithoutCargoInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutCargoInput, UsuarioUncheckedUpdateWithoutCargoInput>
    create: XOR<UsuarioCreateWithoutCargoInput, UsuarioUncheckedCreateWithoutCargoInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutCargoInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutCargoInput, UsuarioUncheckedUpdateWithoutCargoInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutCargoInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutCargoInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id?: IntFilter<"Usuario"> | number
    cedula?: StringFilter<"Usuario"> | string
    nombre?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    fecha_nacimiento?: StringFilter<"Usuario"> | string
    correo?: StringFilter<"Usuario"> | string
    contrasena?: StringFilter<"Usuario"> | string
    id_cargo?: IntFilter<"Usuario"> | number
    id_carrera?: IntFilter<"Usuario"> | number
  }

  export type OfertaAcademicaCreateWithoutCarreraInput = {
    anno: string
    Curso: CursoCreateNestedOneWithoutOfertaAcademicaInput
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutOfertaAcademicaInput
  }

  export type OfertaAcademicaUncheckedCreateWithoutCarreraInput = {
    id?: number
    id_curso: number
    id_cuatrimestre: number
    anno: string
  }

  export type OfertaAcademicaCreateOrConnectWithoutCarreraInput = {
    where: OfertaAcademicaWhereUniqueInput
    create: XOR<OfertaAcademicaCreateWithoutCarreraInput, OfertaAcademicaUncheckedCreateWithoutCarreraInput>
  }

  export type OfertaAcademicaCreateManyCarreraInputEnvelope = {
    data: OfertaAcademicaCreateManyCarreraInput | OfertaAcademicaCreateManyCarreraInput[]
    skipDuplicates?: boolean
  }

  export type PlanEstudiosCreateWithoutCarreraInput = {
    nombre: string
    anno: number
    Materia?: MateriaCreateNestedManyWithoutPlanEstudiosInput
  }

  export type PlanEstudiosUncheckedCreateWithoutCarreraInput = {
    id?: number
    nombre: string
    anno: number
    Materia?: MateriaUncheckedCreateNestedManyWithoutPlanEstudiosInput
  }

  export type PlanEstudiosCreateOrConnectWithoutCarreraInput = {
    where: PlanEstudiosWhereUniqueInput
    create: XOR<PlanEstudiosCreateWithoutCarreraInput, PlanEstudiosUncheckedCreateWithoutCarreraInput>
  }

  export type PlanEstudiosCreateManyCarreraInputEnvelope = {
    data: PlanEstudiosCreateManyCarreraInput | PlanEstudiosCreateManyCarreraInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioCreateWithoutCarreraInput = {
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    Cargo: CargoCreateNestedOneWithoutUsuarioInput
    Curso?: CursoCreateNestedManyWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutCarreraInput = {
    id?: number
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    id_cargo: number
    Curso?: CursoUncheckedCreateNestedManyWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutCarreraInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCarreraInput, UsuarioUncheckedCreateWithoutCarreraInput>
  }

  export type UsuarioCreateManyCarreraInputEnvelope = {
    data: UsuarioCreateManyCarreraInput | UsuarioCreateManyCarreraInput[]
    skipDuplicates?: boolean
  }

  export type EncabezadoFacturaCreateWithoutCarreraInput = {
    fecha_hora?: Date | string
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutEncabezadoFacturaInput
    Usuario: UsuarioCreateNestedOneWithoutEncabezadoFacturaInput
    DetalleFactura?: DetalleFacturaCreateNestedManyWithoutEncabezadoFacturaInput
  }

  export type EncabezadoFacturaUncheckedCreateWithoutCarreraInput = {
    id?: number
    id_cuatrimestre: number
    id_usuario: number
    fecha_hora?: Date | string
    DetalleFactura?: DetalleFacturaUncheckedCreateNestedManyWithoutEncabezadoFacturaInput
  }

  export type EncabezadoFacturaCreateOrConnectWithoutCarreraInput = {
    where: EncabezadoFacturaWhereUniqueInput
    create: XOR<EncabezadoFacturaCreateWithoutCarreraInput, EncabezadoFacturaUncheckedCreateWithoutCarreraInput>
  }

  export type EncabezadoFacturaCreateManyCarreraInputEnvelope = {
    data: EncabezadoFacturaCreateManyCarreraInput | EncabezadoFacturaCreateManyCarreraInput[]
    skipDuplicates?: boolean
  }

  export type OfertaAcademicaUpsertWithWhereUniqueWithoutCarreraInput = {
    where: OfertaAcademicaWhereUniqueInput
    update: XOR<OfertaAcademicaUpdateWithoutCarreraInput, OfertaAcademicaUncheckedUpdateWithoutCarreraInput>
    create: XOR<OfertaAcademicaCreateWithoutCarreraInput, OfertaAcademicaUncheckedCreateWithoutCarreraInput>
  }

  export type OfertaAcademicaUpdateWithWhereUniqueWithoutCarreraInput = {
    where: OfertaAcademicaWhereUniqueInput
    data: XOR<OfertaAcademicaUpdateWithoutCarreraInput, OfertaAcademicaUncheckedUpdateWithoutCarreraInput>
  }

  export type OfertaAcademicaUpdateManyWithWhereWithoutCarreraInput = {
    where: OfertaAcademicaScalarWhereInput
    data: XOR<OfertaAcademicaUpdateManyMutationInput, OfertaAcademicaUncheckedUpdateManyWithoutCarreraInput>
  }

  export type OfertaAcademicaScalarWhereInput = {
    AND?: OfertaAcademicaScalarWhereInput | OfertaAcademicaScalarWhereInput[]
    OR?: OfertaAcademicaScalarWhereInput[]
    NOT?: OfertaAcademicaScalarWhereInput | OfertaAcademicaScalarWhereInput[]
    id?: IntFilter<"OfertaAcademica"> | number
    id_curso?: IntFilter<"OfertaAcademica"> | number
    id_carrera?: IntFilter<"OfertaAcademica"> | number
    id_cuatrimestre?: IntFilter<"OfertaAcademica"> | number
    anno?: StringFilter<"OfertaAcademica"> | string
  }

  export type PlanEstudiosUpsertWithWhereUniqueWithoutCarreraInput = {
    where: PlanEstudiosWhereUniqueInput
    update: XOR<PlanEstudiosUpdateWithoutCarreraInput, PlanEstudiosUncheckedUpdateWithoutCarreraInput>
    create: XOR<PlanEstudiosCreateWithoutCarreraInput, PlanEstudiosUncheckedCreateWithoutCarreraInput>
  }

  export type PlanEstudiosUpdateWithWhereUniqueWithoutCarreraInput = {
    where: PlanEstudiosWhereUniqueInput
    data: XOR<PlanEstudiosUpdateWithoutCarreraInput, PlanEstudiosUncheckedUpdateWithoutCarreraInput>
  }

  export type PlanEstudiosUpdateManyWithWhereWithoutCarreraInput = {
    where: PlanEstudiosScalarWhereInput
    data: XOR<PlanEstudiosUpdateManyMutationInput, PlanEstudiosUncheckedUpdateManyWithoutCarreraInput>
  }

  export type PlanEstudiosScalarWhereInput = {
    AND?: PlanEstudiosScalarWhereInput | PlanEstudiosScalarWhereInput[]
    OR?: PlanEstudiosScalarWhereInput[]
    NOT?: PlanEstudiosScalarWhereInput | PlanEstudiosScalarWhereInput[]
    id?: IntFilter<"PlanEstudios"> | number
    nombre?: StringFilter<"PlanEstudios"> | string
    anno?: IntFilter<"PlanEstudios"> | number
    id_carrera?: IntFilter<"PlanEstudios"> | number
  }

  export type UsuarioUpsertWithWhereUniqueWithoutCarreraInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutCarreraInput, UsuarioUncheckedUpdateWithoutCarreraInput>
    create: XOR<UsuarioCreateWithoutCarreraInput, UsuarioUncheckedCreateWithoutCarreraInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutCarreraInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutCarreraInput, UsuarioUncheckedUpdateWithoutCarreraInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutCarreraInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutCarreraInput>
  }

  export type EncabezadoFacturaUpsertWithWhereUniqueWithoutCarreraInput = {
    where: EncabezadoFacturaWhereUniqueInput
    update: XOR<EncabezadoFacturaUpdateWithoutCarreraInput, EncabezadoFacturaUncheckedUpdateWithoutCarreraInput>
    create: XOR<EncabezadoFacturaCreateWithoutCarreraInput, EncabezadoFacturaUncheckedCreateWithoutCarreraInput>
  }

  export type EncabezadoFacturaUpdateWithWhereUniqueWithoutCarreraInput = {
    where: EncabezadoFacturaWhereUniqueInput
    data: XOR<EncabezadoFacturaUpdateWithoutCarreraInput, EncabezadoFacturaUncheckedUpdateWithoutCarreraInput>
  }

  export type EncabezadoFacturaUpdateManyWithWhereWithoutCarreraInput = {
    where: EncabezadoFacturaScalarWhereInput
    data: XOR<EncabezadoFacturaUpdateManyMutationInput, EncabezadoFacturaUncheckedUpdateManyWithoutCarreraInput>
  }

  export type EncabezadoFacturaScalarWhereInput = {
    AND?: EncabezadoFacturaScalarWhereInput | EncabezadoFacturaScalarWhereInput[]
    OR?: EncabezadoFacturaScalarWhereInput[]
    NOT?: EncabezadoFacturaScalarWhereInput | EncabezadoFacturaScalarWhereInput[]
    id?: IntFilter<"EncabezadoFactura"> | number
    id_cuatrimestre?: IntFilter<"EncabezadoFactura"> | number
    id_carrera?: IntFilter<"EncabezadoFactura"> | number
    id_usuario?: IntFilter<"EncabezadoFactura"> | number
    fecha_hora?: DateTimeFilter<"EncabezadoFactura"> | Date | string
  }

  export type CargoCreateWithoutUsuarioInput = {
    nombre: string
  }

  export type CargoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nombre: string
  }

  export type CargoCreateOrConnectWithoutUsuarioInput = {
    where: CargoWhereUniqueInput
    create: XOR<CargoCreateWithoutUsuarioInput, CargoUncheckedCreateWithoutUsuarioInput>
  }

  export type CarreraCreateWithoutUsuarioInput = {
    nombre: string
    especialidad: string
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCarreraInput
    PlanEstudios?: PlanEstudiosCreateNestedManyWithoutCarreraInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutCarreraInput
  }

  export type CarreraUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nombre: string
    especialidad: string
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCarreraInput
    PlanEstudios?: PlanEstudiosUncheckedCreateNestedManyWithoutCarreraInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutCarreraInput
  }

  export type CarreraCreateOrConnectWithoutUsuarioInput = {
    where: CarreraWhereUniqueInput
    create: XOR<CarreraCreateWithoutUsuarioInput, CarreraUncheckedCreateWithoutUsuarioInput>
  }

  export type CursoCreateWithoutUsuarioInput = {
    horario: string
    aula: string
    Materia: MateriaCreateNestedOneWithoutCursoInput
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutCursoInput
    DetalleFactura?: DetalleFacturaCreateNestedManyWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    id_materia: number
    horario: string
    aula: string
    id_cuatrimestre: number
    DetalleFactura?: DetalleFacturaUncheckedCreateNestedManyWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutUsuarioInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutUsuarioInput, CursoUncheckedCreateWithoutUsuarioInput>
  }

  export type CursoCreateManyUsuarioInputEnvelope = {
    data: CursoCreateManyUsuarioInput | CursoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type HistoricoAcademicoCreateWithoutUsuarioInput = {
    nota: number
    Curso: CursoCreateNestedOneWithoutHistoricoAcademicoInput
  }

  export type HistoricoAcademicoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    id_curso: number
    nota: number
  }

  export type HistoricoAcademicoCreateOrConnectWithoutUsuarioInput = {
    where: HistoricoAcademicoWhereUniqueInput
    create: XOR<HistoricoAcademicoCreateWithoutUsuarioInput, HistoricoAcademicoUncheckedCreateWithoutUsuarioInput>
  }

  export type HistoricoAcademicoCreateManyUsuarioInputEnvelope = {
    data: HistoricoAcademicoCreateManyUsuarioInput | HistoricoAcademicoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type AuditoriaCreateWithoutUsuarioInput = {
    accion: string
    fecha_hora?: Date | string
    descripcion: string
  }

  export type AuditoriaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    accion: string
    fecha_hora?: Date | string
    descripcion: string
  }

  export type AuditoriaCreateOrConnectWithoutUsuarioInput = {
    where: AuditoriaWhereUniqueInput
    create: XOR<AuditoriaCreateWithoutUsuarioInput, AuditoriaUncheckedCreateWithoutUsuarioInput>
  }

  export type AuditoriaCreateManyUsuarioInputEnvelope = {
    data: AuditoriaCreateManyUsuarioInput | AuditoriaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type EncabezadoFacturaCreateWithoutUsuarioInput = {
    fecha_hora?: Date | string
    Carrera: CarreraCreateNestedOneWithoutEncabezadoFacturaInput
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutEncabezadoFacturaInput
    DetalleFactura?: DetalleFacturaCreateNestedManyWithoutEncabezadoFacturaInput
  }

  export type EncabezadoFacturaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    id_cuatrimestre: number
    id_carrera: number
    fecha_hora?: Date | string
    DetalleFactura?: DetalleFacturaUncheckedCreateNestedManyWithoutEncabezadoFacturaInput
  }

  export type EncabezadoFacturaCreateOrConnectWithoutUsuarioInput = {
    where: EncabezadoFacturaWhereUniqueInput
    create: XOR<EncabezadoFacturaCreateWithoutUsuarioInput, EncabezadoFacturaUncheckedCreateWithoutUsuarioInput>
  }

  export type EncabezadoFacturaCreateManyUsuarioInputEnvelope = {
    data: EncabezadoFacturaCreateManyUsuarioInput | EncabezadoFacturaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type MatriculaCreateWithoutUsuarioInput = {
    fecha?: Date | string
    estado: string
    Curso: CursoCreateNestedOneWithoutCuMatriculaInput
  }

  export type MatriculaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    id_curso: number
    fecha?: Date | string
    estado: string
  }

  export type MatriculaCreateOrConnectWithoutUsuarioInput = {
    where: MatriculaWhereUniqueInput
    create: XOR<MatriculaCreateWithoutUsuarioInput, MatriculaUncheckedCreateWithoutUsuarioInput>
  }

  export type MatriculaCreateManyUsuarioInputEnvelope = {
    data: MatriculaCreateManyUsuarioInput | MatriculaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type CargoUpsertWithoutUsuarioInput = {
    update: XOR<CargoUpdateWithoutUsuarioInput, CargoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<CargoCreateWithoutUsuarioInput, CargoUncheckedCreateWithoutUsuarioInput>
    where?: CargoWhereInput
  }

  export type CargoUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: CargoWhereInput
    data: XOR<CargoUpdateWithoutUsuarioInput, CargoUncheckedUpdateWithoutUsuarioInput>
  }

  export type CargoUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CargoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CarreraUpsertWithoutUsuarioInput = {
    update: XOR<CarreraUpdateWithoutUsuarioInput, CarreraUncheckedUpdateWithoutUsuarioInput>
    create: XOR<CarreraCreateWithoutUsuarioInput, CarreraUncheckedCreateWithoutUsuarioInput>
    where?: CarreraWhereInput
  }

  export type CarreraUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: CarreraWhereInput
    data: XOR<CarreraUpdateWithoutUsuarioInput, CarreraUncheckedUpdateWithoutUsuarioInput>
  }

  export type CarreraUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: StringFieldUpdateOperationsInput | string
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCarreraNestedInput
    PlanEstudios?: PlanEstudiosUpdateManyWithoutCarreraNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutCarreraNestedInput
  }

  export type CarreraUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: StringFieldUpdateOperationsInput | string
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCarreraNestedInput
    PlanEstudios?: PlanEstudiosUncheckedUpdateManyWithoutCarreraNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutCarreraNestedInput
  }

  export type CursoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: CursoWhereUniqueInput
    update: XOR<CursoUpdateWithoutUsuarioInput, CursoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<CursoCreateWithoutUsuarioInput, CursoUncheckedCreateWithoutUsuarioInput>
  }

  export type CursoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: CursoWhereUniqueInput
    data: XOR<CursoUpdateWithoutUsuarioInput, CursoUncheckedUpdateWithoutUsuarioInput>
  }

  export type CursoUpdateManyWithWhereWithoutUsuarioInput = {
    where: CursoScalarWhereInput
    data: XOR<CursoUpdateManyMutationInput, CursoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type CursoScalarWhereInput = {
    AND?: CursoScalarWhereInput | CursoScalarWhereInput[]
    OR?: CursoScalarWhereInput[]
    NOT?: CursoScalarWhereInput | CursoScalarWhereInput[]
    id?: IntFilter<"Curso"> | number
    id_materia?: IntFilter<"Curso"> | number
    id_docente?: IntFilter<"Curso"> | number
    horario?: StringFilter<"Curso"> | string
    aula?: StringFilter<"Curso"> | string
    id_cuatrimestre?: IntFilter<"Curso"> | number
  }

  export type HistoricoAcademicoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: HistoricoAcademicoWhereUniqueInput
    update: XOR<HistoricoAcademicoUpdateWithoutUsuarioInput, HistoricoAcademicoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<HistoricoAcademicoCreateWithoutUsuarioInput, HistoricoAcademicoUncheckedCreateWithoutUsuarioInput>
  }

  export type HistoricoAcademicoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: HistoricoAcademicoWhereUniqueInput
    data: XOR<HistoricoAcademicoUpdateWithoutUsuarioInput, HistoricoAcademicoUncheckedUpdateWithoutUsuarioInput>
  }

  export type HistoricoAcademicoUpdateManyWithWhereWithoutUsuarioInput = {
    where: HistoricoAcademicoScalarWhereInput
    data: XOR<HistoricoAcademicoUpdateManyMutationInput, HistoricoAcademicoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type HistoricoAcademicoScalarWhereInput = {
    AND?: HistoricoAcademicoScalarWhereInput | HistoricoAcademicoScalarWhereInput[]
    OR?: HistoricoAcademicoScalarWhereInput[]
    NOT?: HistoricoAcademicoScalarWhereInput | HistoricoAcademicoScalarWhereInput[]
    id?: IntFilter<"HistoricoAcademico"> | number
    id_usuario?: IntFilter<"HistoricoAcademico"> | number
    id_curso?: IntFilter<"HistoricoAcademico"> | number
    nota?: FloatFilter<"HistoricoAcademico"> | number
  }

  export type AuditoriaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: AuditoriaWhereUniqueInput
    update: XOR<AuditoriaUpdateWithoutUsuarioInput, AuditoriaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<AuditoriaCreateWithoutUsuarioInput, AuditoriaUncheckedCreateWithoutUsuarioInput>
  }

  export type AuditoriaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: AuditoriaWhereUniqueInput
    data: XOR<AuditoriaUpdateWithoutUsuarioInput, AuditoriaUncheckedUpdateWithoutUsuarioInput>
  }

  export type AuditoriaUpdateManyWithWhereWithoutUsuarioInput = {
    where: AuditoriaScalarWhereInput
    data: XOR<AuditoriaUpdateManyMutationInput, AuditoriaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type AuditoriaScalarWhereInput = {
    AND?: AuditoriaScalarWhereInput | AuditoriaScalarWhereInput[]
    OR?: AuditoriaScalarWhereInput[]
    NOT?: AuditoriaScalarWhereInput | AuditoriaScalarWhereInput[]
    id?: IntFilter<"Auditoria"> | number
    id_usuario?: IntFilter<"Auditoria"> | number
    accion?: StringFilter<"Auditoria"> | string
    fecha_hora?: DateTimeFilter<"Auditoria"> | Date | string
    descripcion?: StringFilter<"Auditoria"> | string
  }

  export type EncabezadoFacturaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: EncabezadoFacturaWhereUniqueInput
    update: XOR<EncabezadoFacturaUpdateWithoutUsuarioInput, EncabezadoFacturaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EncabezadoFacturaCreateWithoutUsuarioInput, EncabezadoFacturaUncheckedCreateWithoutUsuarioInput>
  }

  export type EncabezadoFacturaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: EncabezadoFacturaWhereUniqueInput
    data: XOR<EncabezadoFacturaUpdateWithoutUsuarioInput, EncabezadoFacturaUncheckedUpdateWithoutUsuarioInput>
  }

  export type EncabezadoFacturaUpdateManyWithWhereWithoutUsuarioInput = {
    where: EncabezadoFacturaScalarWhereInput
    data: XOR<EncabezadoFacturaUpdateManyMutationInput, EncabezadoFacturaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type MatriculaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: MatriculaWhereUniqueInput
    update: XOR<MatriculaUpdateWithoutUsuarioInput, MatriculaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<MatriculaCreateWithoutUsuarioInput, MatriculaUncheckedCreateWithoutUsuarioInput>
  }

  export type MatriculaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: MatriculaWhereUniqueInput
    data: XOR<MatriculaUpdateWithoutUsuarioInput, MatriculaUncheckedUpdateWithoutUsuarioInput>
  }

  export type MatriculaUpdateManyWithWhereWithoutUsuarioInput = {
    where: MatriculaScalarWhereInput
    data: XOR<MatriculaUpdateManyMutationInput, MatriculaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type MatriculaScalarWhereInput = {
    AND?: MatriculaScalarWhereInput | MatriculaScalarWhereInput[]
    OR?: MatriculaScalarWhereInput[]
    NOT?: MatriculaScalarWhereInput | MatriculaScalarWhereInput[]
    id?: IntFilter<"Matricula"> | number
    id_usuario?: IntFilter<"Matricula"> | number
    id_curso?: IntFilter<"Matricula"> | number
    fecha?: DateTimeFilter<"Matricula"> | Date | string
    estado?: StringFilter<"Matricula"> | string
  }

  export type CarreraCreateWithoutPlanEstudiosInput = {
    nombre: string
    especialidad: string
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCarreraInput
    Usuario?: UsuarioCreateNestedManyWithoutCarreraInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutCarreraInput
  }

  export type CarreraUncheckedCreateWithoutPlanEstudiosInput = {
    id?: number
    nombre: string
    especialidad: string
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCarreraInput
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutCarreraInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutCarreraInput
  }

  export type CarreraCreateOrConnectWithoutPlanEstudiosInput = {
    where: CarreraWhereUniqueInput
    create: XOR<CarreraCreateWithoutPlanEstudiosInput, CarreraUncheckedCreateWithoutPlanEstudiosInput>
  }

  export type MateriaCreateWithoutPlanEstudiosInput = {
    nombre: string
    codigo: string
    Curso?: CursoCreateNestedManyWithoutMateriaInput
  }

  export type MateriaUncheckedCreateWithoutPlanEstudiosInput = {
    id?: number
    nombre: string
    codigo: string
    Curso?: CursoUncheckedCreateNestedManyWithoutMateriaInput
  }

  export type MateriaCreateOrConnectWithoutPlanEstudiosInput = {
    where: MateriaWhereUniqueInput
    create: XOR<MateriaCreateWithoutPlanEstudiosInput, MateriaUncheckedCreateWithoutPlanEstudiosInput>
  }

  export type MateriaCreateManyPlanEstudiosInputEnvelope = {
    data: MateriaCreateManyPlanEstudiosInput | MateriaCreateManyPlanEstudiosInput[]
    skipDuplicates?: boolean
  }

  export type CarreraUpsertWithoutPlanEstudiosInput = {
    update: XOR<CarreraUpdateWithoutPlanEstudiosInput, CarreraUncheckedUpdateWithoutPlanEstudiosInput>
    create: XOR<CarreraCreateWithoutPlanEstudiosInput, CarreraUncheckedCreateWithoutPlanEstudiosInput>
    where?: CarreraWhereInput
  }

  export type CarreraUpdateToOneWithWhereWithoutPlanEstudiosInput = {
    where?: CarreraWhereInput
    data: XOR<CarreraUpdateWithoutPlanEstudiosInput, CarreraUncheckedUpdateWithoutPlanEstudiosInput>
  }

  export type CarreraUpdateWithoutPlanEstudiosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: StringFieldUpdateOperationsInput | string
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCarreraNestedInput
    Usuario?: UsuarioUpdateManyWithoutCarreraNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutCarreraNestedInput
  }

  export type CarreraUncheckedUpdateWithoutPlanEstudiosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: StringFieldUpdateOperationsInput | string
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCarreraNestedInput
    Usuario?: UsuarioUncheckedUpdateManyWithoutCarreraNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutCarreraNestedInput
  }

  export type MateriaUpsertWithWhereUniqueWithoutPlanEstudiosInput = {
    where: MateriaWhereUniqueInput
    update: XOR<MateriaUpdateWithoutPlanEstudiosInput, MateriaUncheckedUpdateWithoutPlanEstudiosInput>
    create: XOR<MateriaCreateWithoutPlanEstudiosInput, MateriaUncheckedCreateWithoutPlanEstudiosInput>
  }

  export type MateriaUpdateWithWhereUniqueWithoutPlanEstudiosInput = {
    where: MateriaWhereUniqueInput
    data: XOR<MateriaUpdateWithoutPlanEstudiosInput, MateriaUncheckedUpdateWithoutPlanEstudiosInput>
  }

  export type MateriaUpdateManyWithWhereWithoutPlanEstudiosInput = {
    where: MateriaScalarWhereInput
    data: XOR<MateriaUpdateManyMutationInput, MateriaUncheckedUpdateManyWithoutPlanEstudiosInput>
  }

  export type MateriaScalarWhereInput = {
    AND?: MateriaScalarWhereInput | MateriaScalarWhereInput[]
    OR?: MateriaScalarWhereInput[]
    NOT?: MateriaScalarWhereInput | MateriaScalarWhereInput[]
    id?: IntFilter<"Materia"> | number
    nombre?: StringFilter<"Materia"> | string
    codigo?: StringFilter<"Materia"> | string
    id_plan_estudios?: IntFilter<"Materia"> | number
  }

  export type OfertaAcademicaCreateWithoutCuatrimestreInput = {
    anno: string
    Curso: CursoCreateNestedOneWithoutOfertaAcademicaInput
    Carrera: CarreraCreateNestedOneWithoutOfertaAcademicaInput
  }

  export type OfertaAcademicaUncheckedCreateWithoutCuatrimestreInput = {
    id?: number
    id_curso: number
    id_carrera: number
    anno: string
  }

  export type OfertaAcademicaCreateOrConnectWithoutCuatrimestreInput = {
    where: OfertaAcademicaWhereUniqueInput
    create: XOR<OfertaAcademicaCreateWithoutCuatrimestreInput, OfertaAcademicaUncheckedCreateWithoutCuatrimestreInput>
  }

  export type OfertaAcademicaCreateManyCuatrimestreInputEnvelope = {
    data: OfertaAcademicaCreateManyCuatrimestreInput | OfertaAcademicaCreateManyCuatrimestreInput[]
    skipDuplicates?: boolean
  }

  export type CursoCreateWithoutCuatrimestreInput = {
    horario: string
    aula: string
    Materia: MateriaCreateNestedOneWithoutCursoInput
    Usuario: UsuarioCreateNestedOneWithoutCursoInput
    DetalleFactura?: DetalleFacturaCreateNestedManyWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutCuatrimestreInput = {
    id?: number
    id_materia: number
    id_docente: number
    horario: string
    aula: string
    DetalleFactura?: DetalleFacturaUncheckedCreateNestedManyWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutCuatrimestreInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutCuatrimestreInput, CursoUncheckedCreateWithoutCuatrimestreInput>
  }

  export type CursoCreateManyCuatrimestreInputEnvelope = {
    data: CursoCreateManyCuatrimestreInput | CursoCreateManyCuatrimestreInput[]
    skipDuplicates?: boolean
  }

  export type EncabezadoFacturaCreateWithoutCuatrimestreInput = {
    fecha_hora?: Date | string
    Carrera: CarreraCreateNestedOneWithoutEncabezadoFacturaInput
    Usuario: UsuarioCreateNestedOneWithoutEncabezadoFacturaInput
    DetalleFactura?: DetalleFacturaCreateNestedManyWithoutEncabezadoFacturaInput
  }

  export type EncabezadoFacturaUncheckedCreateWithoutCuatrimestreInput = {
    id?: number
    id_carrera: number
    id_usuario: number
    fecha_hora?: Date | string
    DetalleFactura?: DetalleFacturaUncheckedCreateNestedManyWithoutEncabezadoFacturaInput
  }

  export type EncabezadoFacturaCreateOrConnectWithoutCuatrimestreInput = {
    where: EncabezadoFacturaWhereUniqueInput
    create: XOR<EncabezadoFacturaCreateWithoutCuatrimestreInput, EncabezadoFacturaUncheckedCreateWithoutCuatrimestreInput>
  }

  export type EncabezadoFacturaCreateManyCuatrimestreInputEnvelope = {
    data: EncabezadoFacturaCreateManyCuatrimestreInput | EncabezadoFacturaCreateManyCuatrimestreInput[]
    skipDuplicates?: boolean
  }

  export type OfertaAcademicaUpsertWithWhereUniqueWithoutCuatrimestreInput = {
    where: OfertaAcademicaWhereUniqueInput
    update: XOR<OfertaAcademicaUpdateWithoutCuatrimestreInput, OfertaAcademicaUncheckedUpdateWithoutCuatrimestreInput>
    create: XOR<OfertaAcademicaCreateWithoutCuatrimestreInput, OfertaAcademicaUncheckedCreateWithoutCuatrimestreInput>
  }

  export type OfertaAcademicaUpdateWithWhereUniqueWithoutCuatrimestreInput = {
    where: OfertaAcademicaWhereUniqueInput
    data: XOR<OfertaAcademicaUpdateWithoutCuatrimestreInput, OfertaAcademicaUncheckedUpdateWithoutCuatrimestreInput>
  }

  export type OfertaAcademicaUpdateManyWithWhereWithoutCuatrimestreInput = {
    where: OfertaAcademicaScalarWhereInput
    data: XOR<OfertaAcademicaUpdateManyMutationInput, OfertaAcademicaUncheckedUpdateManyWithoutCuatrimestreInput>
  }

  export type CursoUpsertWithWhereUniqueWithoutCuatrimestreInput = {
    where: CursoWhereUniqueInput
    update: XOR<CursoUpdateWithoutCuatrimestreInput, CursoUncheckedUpdateWithoutCuatrimestreInput>
    create: XOR<CursoCreateWithoutCuatrimestreInput, CursoUncheckedCreateWithoutCuatrimestreInput>
  }

  export type CursoUpdateWithWhereUniqueWithoutCuatrimestreInput = {
    where: CursoWhereUniqueInput
    data: XOR<CursoUpdateWithoutCuatrimestreInput, CursoUncheckedUpdateWithoutCuatrimestreInput>
  }

  export type CursoUpdateManyWithWhereWithoutCuatrimestreInput = {
    where: CursoScalarWhereInput
    data: XOR<CursoUpdateManyMutationInput, CursoUncheckedUpdateManyWithoutCuatrimestreInput>
  }

  export type EncabezadoFacturaUpsertWithWhereUniqueWithoutCuatrimestreInput = {
    where: EncabezadoFacturaWhereUniqueInput
    update: XOR<EncabezadoFacturaUpdateWithoutCuatrimestreInput, EncabezadoFacturaUncheckedUpdateWithoutCuatrimestreInput>
    create: XOR<EncabezadoFacturaCreateWithoutCuatrimestreInput, EncabezadoFacturaUncheckedCreateWithoutCuatrimestreInput>
  }

  export type EncabezadoFacturaUpdateWithWhereUniqueWithoutCuatrimestreInput = {
    where: EncabezadoFacturaWhereUniqueInput
    data: XOR<EncabezadoFacturaUpdateWithoutCuatrimestreInput, EncabezadoFacturaUncheckedUpdateWithoutCuatrimestreInput>
  }

  export type EncabezadoFacturaUpdateManyWithWhereWithoutCuatrimestreInput = {
    where: EncabezadoFacturaScalarWhereInput
    data: XOR<EncabezadoFacturaUpdateManyMutationInput, EncabezadoFacturaUncheckedUpdateManyWithoutCuatrimestreInput>
  }

  export type PlanEstudiosCreateWithoutMateriaInput = {
    nombre: string
    anno: number
    Carrera: CarreraCreateNestedOneWithoutPlanEstudiosInput
  }

  export type PlanEstudiosUncheckedCreateWithoutMateriaInput = {
    id?: number
    nombre: string
    anno: number
    id_carrera: number
  }

  export type PlanEstudiosCreateOrConnectWithoutMateriaInput = {
    where: PlanEstudiosWhereUniqueInput
    create: XOR<PlanEstudiosCreateWithoutMateriaInput, PlanEstudiosUncheckedCreateWithoutMateriaInput>
  }

  export type CursoCreateWithoutMateriaInput = {
    horario: string
    aula: string
    Usuario: UsuarioCreateNestedOneWithoutCursoInput
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutCursoInput
    DetalleFactura?: DetalleFacturaCreateNestedManyWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutMateriaInput = {
    id?: number
    id_docente: number
    horario: string
    aula: string
    id_cuatrimestre: number
    DetalleFactura?: DetalleFacturaUncheckedCreateNestedManyWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutMateriaInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutMateriaInput, CursoUncheckedCreateWithoutMateriaInput>
  }

  export type CursoCreateManyMateriaInputEnvelope = {
    data: CursoCreateManyMateriaInput | CursoCreateManyMateriaInput[]
    skipDuplicates?: boolean
  }

  export type PlanEstudiosUpsertWithoutMateriaInput = {
    update: XOR<PlanEstudiosUpdateWithoutMateriaInput, PlanEstudiosUncheckedUpdateWithoutMateriaInput>
    create: XOR<PlanEstudiosCreateWithoutMateriaInput, PlanEstudiosUncheckedCreateWithoutMateriaInput>
    where?: PlanEstudiosWhereInput
  }

  export type PlanEstudiosUpdateToOneWithWhereWithoutMateriaInput = {
    where?: PlanEstudiosWhereInput
    data: XOR<PlanEstudiosUpdateWithoutMateriaInput, PlanEstudiosUncheckedUpdateWithoutMateriaInput>
  }

  export type PlanEstudiosUpdateWithoutMateriaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    anno?: IntFieldUpdateOperationsInput | number
    Carrera?: CarreraUpdateOneRequiredWithoutPlanEstudiosNestedInput
  }

  export type PlanEstudiosUncheckedUpdateWithoutMateriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    anno?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
  }

  export type CursoUpsertWithWhereUniqueWithoutMateriaInput = {
    where: CursoWhereUniqueInput
    update: XOR<CursoUpdateWithoutMateriaInput, CursoUncheckedUpdateWithoutMateriaInput>
    create: XOR<CursoCreateWithoutMateriaInput, CursoUncheckedCreateWithoutMateriaInput>
  }

  export type CursoUpdateWithWhereUniqueWithoutMateriaInput = {
    where: CursoWhereUniqueInput
    data: XOR<CursoUpdateWithoutMateriaInput, CursoUncheckedUpdateWithoutMateriaInput>
  }

  export type CursoUpdateManyWithWhereWithoutMateriaInput = {
    where: CursoScalarWhereInput
    data: XOR<CursoUpdateManyMutationInput, CursoUncheckedUpdateManyWithoutMateriaInput>
  }

  export type MateriaCreateWithoutCursoInput = {
    nombre: string
    codigo: string
    PlanEstudios: PlanEstudiosCreateNestedOneWithoutMateriaInput
  }

  export type MateriaUncheckedCreateWithoutCursoInput = {
    id?: number
    nombre: string
    codigo: string
    id_plan_estudios: number
  }

  export type MateriaCreateOrConnectWithoutCursoInput = {
    where: MateriaWhereUniqueInput
    create: XOR<MateriaCreateWithoutCursoInput, MateriaUncheckedCreateWithoutCursoInput>
  }

  export type UsuarioCreateWithoutCursoInput = {
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    Cargo: CargoCreateNestedOneWithoutUsuarioInput
    Carrera: CarreraCreateNestedOneWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutCursoInput = {
    id?: number
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    id_cargo: number
    id_carrera: number
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutCursoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCursoInput, UsuarioUncheckedCreateWithoutCursoInput>
  }

  export type CuatrimestreCreateWithoutCursoInput = {
    numero_cuatrimestre: number
    anno: number
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCuatrimestreInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutCuatrimestreInput
  }

  export type CuatrimestreUncheckedCreateWithoutCursoInput = {
    id?: number
    numero_cuatrimestre: number
    anno: number
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCuatrimestreInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutCuatrimestreInput
  }

  export type CuatrimestreCreateOrConnectWithoutCursoInput = {
    where: CuatrimestreWhereUniqueInput
    create: XOR<CuatrimestreCreateWithoutCursoInput, CuatrimestreUncheckedCreateWithoutCursoInput>
  }

  export type DetalleFacturaCreateWithoutCursoInput = {
    precio_unitario: number
    EncabezadoFactura: EncabezadoFacturaCreateNestedOneWithoutDetalleFacturaInput
  }

  export type DetalleFacturaUncheckedCreateWithoutCursoInput = {
    id?: number
    id_encabezadofactura: number
    precio_unitario: number
  }

  export type DetalleFacturaCreateOrConnectWithoutCursoInput = {
    where: DetalleFacturaWhereUniqueInput
    create: XOR<DetalleFacturaCreateWithoutCursoInput, DetalleFacturaUncheckedCreateWithoutCursoInput>
  }

  export type DetalleFacturaCreateManyCursoInputEnvelope = {
    data: DetalleFacturaCreateManyCursoInput | DetalleFacturaCreateManyCursoInput[]
    skipDuplicates?: boolean
  }

  export type OfertaAcademicaCreateWithoutCursoInput = {
    anno: string
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutOfertaAcademicaInput
    Carrera: CarreraCreateNestedOneWithoutOfertaAcademicaInput
  }

  export type OfertaAcademicaUncheckedCreateWithoutCursoInput = {
    id?: number
    id_carrera: number
    id_cuatrimestre: number
    anno: string
  }

  export type OfertaAcademicaCreateOrConnectWithoutCursoInput = {
    where: OfertaAcademicaWhereUniqueInput
    create: XOR<OfertaAcademicaCreateWithoutCursoInput, OfertaAcademicaUncheckedCreateWithoutCursoInput>
  }

  export type OfertaAcademicaCreateManyCursoInputEnvelope = {
    data: OfertaAcademicaCreateManyCursoInput | OfertaAcademicaCreateManyCursoInput[]
    skipDuplicates?: boolean
  }

  export type HistoricoAcademicoCreateWithoutCursoInput = {
    nota: number
    Usuario: UsuarioCreateNestedOneWithoutHistoricoAcademicoInput
  }

  export type HistoricoAcademicoUncheckedCreateWithoutCursoInput = {
    id?: number
    id_usuario: number
    nota: number
  }

  export type HistoricoAcademicoCreateOrConnectWithoutCursoInput = {
    where: HistoricoAcademicoWhereUniqueInput
    create: XOR<HistoricoAcademicoCreateWithoutCursoInput, HistoricoAcademicoUncheckedCreateWithoutCursoInput>
  }

  export type HistoricoAcademicoCreateManyCursoInputEnvelope = {
    data: HistoricoAcademicoCreateManyCursoInput | HistoricoAcademicoCreateManyCursoInput[]
    skipDuplicates?: boolean
  }

  export type MatriculaCreateWithoutCursoInput = {
    fecha?: Date | string
    estado: string
    Usuario: UsuarioCreateNestedOneWithoutMatriculaInput
  }

  export type MatriculaUncheckedCreateWithoutCursoInput = {
    id?: number
    id_usuario: number
    fecha?: Date | string
    estado: string
  }

  export type MatriculaCreateOrConnectWithoutCursoInput = {
    where: MatriculaWhereUniqueInput
    create: XOR<MatriculaCreateWithoutCursoInput, MatriculaUncheckedCreateWithoutCursoInput>
  }

  export type MatriculaCreateManyCursoInputEnvelope = {
    data: MatriculaCreateManyCursoInput | MatriculaCreateManyCursoInput[]
    skipDuplicates?: boolean
  }

  export type MateriaUpsertWithoutCursoInput = {
    update: XOR<MateriaUpdateWithoutCursoInput, MateriaUncheckedUpdateWithoutCursoInput>
    create: XOR<MateriaCreateWithoutCursoInput, MateriaUncheckedCreateWithoutCursoInput>
    where?: MateriaWhereInput
  }

  export type MateriaUpdateToOneWithWhereWithoutCursoInput = {
    where?: MateriaWhereInput
    data: XOR<MateriaUpdateWithoutCursoInput, MateriaUncheckedUpdateWithoutCursoInput>
  }

  export type MateriaUpdateWithoutCursoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    PlanEstudios?: PlanEstudiosUpdateOneRequiredWithoutMateriaNestedInput
  }

  export type MateriaUncheckedUpdateWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    id_plan_estudios?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioUpsertWithoutCursoInput = {
    update: XOR<UsuarioUpdateWithoutCursoInput, UsuarioUncheckedUpdateWithoutCursoInput>
    create: XOR<UsuarioCreateWithoutCursoInput, UsuarioUncheckedCreateWithoutCursoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutCursoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutCursoInput, UsuarioUncheckedUpdateWithoutCursoInput>
  }

  export type UsuarioUpdateWithoutCursoInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    Cargo?: CargoUpdateOneRequiredWithoutUsuarioNestedInput
    Carrera?: CarreraUpdateOneRequiredWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    id_cargo?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CuatrimestreUpsertWithoutCursoInput = {
    update: XOR<CuatrimestreUpdateWithoutCursoInput, CuatrimestreUncheckedUpdateWithoutCursoInput>
    create: XOR<CuatrimestreCreateWithoutCursoInput, CuatrimestreUncheckedCreateWithoutCursoInput>
    where?: CuatrimestreWhereInput
  }

  export type CuatrimestreUpdateToOneWithWhereWithoutCursoInput = {
    where?: CuatrimestreWhereInput
    data: XOR<CuatrimestreUpdateWithoutCursoInput, CuatrimestreUncheckedUpdateWithoutCursoInput>
  }

  export type CuatrimestreUpdateWithoutCursoInput = {
    numero_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: IntFieldUpdateOperationsInput | number
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCuatrimestreNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutCuatrimestreNestedInput
  }

  export type CuatrimestreUncheckedUpdateWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: IntFieldUpdateOperationsInput | number
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCuatrimestreNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutCuatrimestreNestedInput
  }

  export type DetalleFacturaUpsertWithWhereUniqueWithoutCursoInput = {
    where: DetalleFacturaWhereUniqueInput
    update: XOR<DetalleFacturaUpdateWithoutCursoInput, DetalleFacturaUncheckedUpdateWithoutCursoInput>
    create: XOR<DetalleFacturaCreateWithoutCursoInput, DetalleFacturaUncheckedCreateWithoutCursoInput>
  }

  export type DetalleFacturaUpdateWithWhereUniqueWithoutCursoInput = {
    where: DetalleFacturaWhereUniqueInput
    data: XOR<DetalleFacturaUpdateWithoutCursoInput, DetalleFacturaUncheckedUpdateWithoutCursoInput>
  }

  export type DetalleFacturaUpdateManyWithWhereWithoutCursoInput = {
    where: DetalleFacturaScalarWhereInput
    data: XOR<DetalleFacturaUpdateManyMutationInput, DetalleFacturaUncheckedUpdateManyWithoutCursoInput>
  }

  export type DetalleFacturaScalarWhereInput = {
    AND?: DetalleFacturaScalarWhereInput | DetalleFacturaScalarWhereInput[]
    OR?: DetalleFacturaScalarWhereInput[]
    NOT?: DetalleFacturaScalarWhereInput | DetalleFacturaScalarWhereInput[]
    id?: IntFilter<"DetalleFactura"> | number
    id_curso?: IntFilter<"DetalleFactura"> | number
    id_encabezadofactura?: IntFilter<"DetalleFactura"> | number
    precio_unitario?: FloatFilter<"DetalleFactura"> | number
  }

  export type OfertaAcademicaUpsertWithWhereUniqueWithoutCursoInput = {
    where: OfertaAcademicaWhereUniqueInput
    update: XOR<OfertaAcademicaUpdateWithoutCursoInput, OfertaAcademicaUncheckedUpdateWithoutCursoInput>
    create: XOR<OfertaAcademicaCreateWithoutCursoInput, OfertaAcademicaUncheckedCreateWithoutCursoInput>
  }

  export type OfertaAcademicaUpdateWithWhereUniqueWithoutCursoInput = {
    where: OfertaAcademicaWhereUniqueInput
    data: XOR<OfertaAcademicaUpdateWithoutCursoInput, OfertaAcademicaUncheckedUpdateWithoutCursoInput>
  }

  export type OfertaAcademicaUpdateManyWithWhereWithoutCursoInput = {
    where: OfertaAcademicaScalarWhereInput
    data: XOR<OfertaAcademicaUpdateManyMutationInput, OfertaAcademicaUncheckedUpdateManyWithoutCursoInput>
  }

  export type HistoricoAcademicoUpsertWithWhereUniqueWithoutCursoInput = {
    where: HistoricoAcademicoWhereUniqueInput
    update: XOR<HistoricoAcademicoUpdateWithoutCursoInput, HistoricoAcademicoUncheckedUpdateWithoutCursoInput>
    create: XOR<HistoricoAcademicoCreateWithoutCursoInput, HistoricoAcademicoUncheckedCreateWithoutCursoInput>
  }

  export type HistoricoAcademicoUpdateWithWhereUniqueWithoutCursoInput = {
    where: HistoricoAcademicoWhereUniqueInput
    data: XOR<HistoricoAcademicoUpdateWithoutCursoInput, HistoricoAcademicoUncheckedUpdateWithoutCursoInput>
  }

  export type HistoricoAcademicoUpdateManyWithWhereWithoutCursoInput = {
    where: HistoricoAcademicoScalarWhereInput
    data: XOR<HistoricoAcademicoUpdateManyMutationInput, HistoricoAcademicoUncheckedUpdateManyWithoutCursoInput>
  }

  export type MatriculaUpsertWithWhereUniqueWithoutCursoInput = {
    where: MatriculaWhereUniqueInput
    update: XOR<MatriculaUpdateWithoutCursoInput, MatriculaUncheckedUpdateWithoutCursoInput>
    create: XOR<MatriculaCreateWithoutCursoInput, MatriculaUncheckedCreateWithoutCursoInput>
  }

  export type MatriculaUpdateWithWhereUniqueWithoutCursoInput = {
    where: MatriculaWhereUniqueInput
    data: XOR<MatriculaUpdateWithoutCursoInput, MatriculaUncheckedUpdateWithoutCursoInput>
  }

  export type MatriculaUpdateManyWithWhereWithoutCursoInput = {
    where: MatriculaScalarWhereInput
    data: XOR<MatriculaUpdateManyMutationInput, MatriculaUncheckedUpdateManyWithoutCursoInput>
  }

  export type UsuarioCreateWithoutMatriculaInput = {
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    Cargo: CargoCreateNestedOneWithoutUsuarioInput
    Carrera: CarreraCreateNestedOneWithoutUsuarioInput
    Curso?: CursoCreateNestedManyWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutMatriculaInput = {
    id?: number
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    id_cargo: number
    id_carrera: number
    Curso?: CursoUncheckedCreateNestedManyWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutMatriculaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutMatriculaInput, UsuarioUncheckedCreateWithoutMatriculaInput>
  }

  export type CursoCreateWithoutCuMatriculaInput = {
    horario: string
    aula: string
    Materia: MateriaCreateNestedOneWithoutCursoInput
    Usuario: UsuarioCreateNestedOneWithoutCursoInput
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutCursoInput
    DetalleFactura?: DetalleFacturaCreateNestedManyWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutCuMatriculaInput = {
    id?: number
    id_materia: number
    id_docente: number
    horario: string
    aula: string
    id_cuatrimestre: number
    DetalleFactura?: DetalleFacturaUncheckedCreateNestedManyWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutCuMatriculaInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutCuMatriculaInput, CursoUncheckedCreateWithoutCuMatriculaInput>
  }

  export type UsuarioUpsertWithoutMatriculaInput = {
    update: XOR<UsuarioUpdateWithoutMatriculaInput, UsuarioUncheckedUpdateWithoutMatriculaInput>
    create: XOR<UsuarioCreateWithoutMatriculaInput, UsuarioUncheckedCreateWithoutMatriculaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutMatriculaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutMatriculaInput, UsuarioUncheckedUpdateWithoutMatriculaInput>
  }

  export type UsuarioUpdateWithoutMatriculaInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    Cargo?: CargoUpdateOneRequiredWithoutUsuarioNestedInput
    Carrera?: CarreraUpdateOneRequiredWithoutUsuarioNestedInput
    Curso?: CursoUpdateManyWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutMatriculaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    id_cargo?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    Curso?: CursoUncheckedUpdateManyWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CursoUpsertWithoutCuMatriculaInput = {
    update: XOR<CursoUpdateWithoutCuMatriculaInput, CursoUncheckedUpdateWithoutCuMatriculaInput>
    create: XOR<CursoCreateWithoutCuMatriculaInput, CursoUncheckedCreateWithoutCuMatriculaInput>
    where?: CursoWhereInput
  }

  export type CursoUpdateToOneWithWhereWithoutCuMatriculaInput = {
    where?: CursoWhereInput
    data: XOR<CursoUpdateWithoutCuMatriculaInput, CursoUncheckedUpdateWithoutCuMatriculaInput>
  }

  export type CursoUpdateWithoutCuMatriculaInput = {
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    Materia?: MateriaUpdateOneRequiredWithoutCursoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutCursoNestedInput
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutCursoNestedInput
    DetalleFactura?: DetalleFacturaUpdateManyWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateWithoutCuMatriculaInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_materia?: IntFieldUpdateOperationsInput | number
    id_docente?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    DetalleFactura?: DetalleFacturaUncheckedUpdateManyWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type CursoCreateWithoutOfertaAcademicaInput = {
    horario: string
    aula: string
    Materia: MateriaCreateNestedOneWithoutCursoInput
    Usuario: UsuarioCreateNestedOneWithoutCursoInput
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutCursoInput
    DetalleFactura?: DetalleFacturaCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutOfertaAcademicaInput = {
    id?: number
    id_materia: number
    id_docente: number
    horario: string
    aula: string
    id_cuatrimestre: number
    DetalleFactura?: DetalleFacturaUncheckedCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutOfertaAcademicaInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutOfertaAcademicaInput, CursoUncheckedCreateWithoutOfertaAcademicaInput>
  }

  export type CuatrimestreCreateWithoutOfertaAcademicaInput = {
    numero_cuatrimestre: number
    anno: number
    Curso?: CursoCreateNestedManyWithoutCuatrimestreInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutCuatrimestreInput
  }

  export type CuatrimestreUncheckedCreateWithoutOfertaAcademicaInput = {
    id?: number
    numero_cuatrimestre: number
    anno: number
    Curso?: CursoUncheckedCreateNestedManyWithoutCuatrimestreInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutCuatrimestreInput
  }

  export type CuatrimestreCreateOrConnectWithoutOfertaAcademicaInput = {
    where: CuatrimestreWhereUniqueInput
    create: XOR<CuatrimestreCreateWithoutOfertaAcademicaInput, CuatrimestreUncheckedCreateWithoutOfertaAcademicaInput>
  }

  export type CarreraCreateWithoutOfertaAcademicaInput = {
    nombre: string
    especialidad: string
    PlanEstudios?: PlanEstudiosCreateNestedManyWithoutCarreraInput
    Usuario?: UsuarioCreateNestedManyWithoutCarreraInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutCarreraInput
  }

  export type CarreraUncheckedCreateWithoutOfertaAcademicaInput = {
    id?: number
    nombre: string
    especialidad: string
    PlanEstudios?: PlanEstudiosUncheckedCreateNestedManyWithoutCarreraInput
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutCarreraInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutCarreraInput
  }

  export type CarreraCreateOrConnectWithoutOfertaAcademicaInput = {
    where: CarreraWhereUniqueInput
    create: XOR<CarreraCreateWithoutOfertaAcademicaInput, CarreraUncheckedCreateWithoutOfertaAcademicaInput>
  }

  export type CursoUpsertWithoutOfertaAcademicaInput = {
    update: XOR<CursoUpdateWithoutOfertaAcademicaInput, CursoUncheckedUpdateWithoutOfertaAcademicaInput>
    create: XOR<CursoCreateWithoutOfertaAcademicaInput, CursoUncheckedCreateWithoutOfertaAcademicaInput>
    where?: CursoWhereInput
  }

  export type CursoUpdateToOneWithWhereWithoutOfertaAcademicaInput = {
    where?: CursoWhereInput
    data: XOR<CursoUpdateWithoutOfertaAcademicaInput, CursoUncheckedUpdateWithoutOfertaAcademicaInput>
  }

  export type CursoUpdateWithoutOfertaAcademicaInput = {
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    Materia?: MateriaUpdateOneRequiredWithoutCursoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutCursoNestedInput
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutCursoNestedInput
    DetalleFactura?: DetalleFacturaUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateWithoutOfertaAcademicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_materia?: IntFieldUpdateOperationsInput | number
    id_docente?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    DetalleFactura?: DetalleFacturaUncheckedUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type CuatrimestreUpsertWithoutOfertaAcademicaInput = {
    update: XOR<CuatrimestreUpdateWithoutOfertaAcademicaInput, CuatrimestreUncheckedUpdateWithoutOfertaAcademicaInput>
    create: XOR<CuatrimestreCreateWithoutOfertaAcademicaInput, CuatrimestreUncheckedCreateWithoutOfertaAcademicaInput>
    where?: CuatrimestreWhereInput
  }

  export type CuatrimestreUpdateToOneWithWhereWithoutOfertaAcademicaInput = {
    where?: CuatrimestreWhereInput
    data: XOR<CuatrimestreUpdateWithoutOfertaAcademicaInput, CuatrimestreUncheckedUpdateWithoutOfertaAcademicaInput>
  }

  export type CuatrimestreUpdateWithoutOfertaAcademicaInput = {
    numero_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: IntFieldUpdateOperationsInput | number
    Curso?: CursoUpdateManyWithoutCuatrimestreNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutCuatrimestreNestedInput
  }

  export type CuatrimestreUncheckedUpdateWithoutOfertaAcademicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: IntFieldUpdateOperationsInput | number
    Curso?: CursoUncheckedUpdateManyWithoutCuatrimestreNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutCuatrimestreNestedInput
  }

  export type CarreraUpsertWithoutOfertaAcademicaInput = {
    update: XOR<CarreraUpdateWithoutOfertaAcademicaInput, CarreraUncheckedUpdateWithoutOfertaAcademicaInput>
    create: XOR<CarreraCreateWithoutOfertaAcademicaInput, CarreraUncheckedCreateWithoutOfertaAcademicaInput>
    where?: CarreraWhereInput
  }

  export type CarreraUpdateToOneWithWhereWithoutOfertaAcademicaInput = {
    where?: CarreraWhereInput
    data: XOR<CarreraUpdateWithoutOfertaAcademicaInput, CarreraUncheckedUpdateWithoutOfertaAcademicaInput>
  }

  export type CarreraUpdateWithoutOfertaAcademicaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: StringFieldUpdateOperationsInput | string
    PlanEstudios?: PlanEstudiosUpdateManyWithoutCarreraNestedInput
    Usuario?: UsuarioUpdateManyWithoutCarreraNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutCarreraNestedInput
  }

  export type CarreraUncheckedUpdateWithoutOfertaAcademicaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: StringFieldUpdateOperationsInput | string
    PlanEstudios?: PlanEstudiosUncheckedUpdateManyWithoutCarreraNestedInput
    Usuario?: UsuarioUncheckedUpdateManyWithoutCarreraNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutCarreraNestedInput
  }

  export type UsuarioCreateWithoutHistoricoAcademicoInput = {
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    Cargo: CargoCreateNestedOneWithoutUsuarioInput
    Carrera: CarreraCreateNestedOneWithoutUsuarioInput
    Curso?: CursoCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutHistoricoAcademicoInput = {
    id?: number
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    id_cargo: number
    id_carrera: number
    Curso?: CursoUncheckedCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutHistoricoAcademicoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutHistoricoAcademicoInput, UsuarioUncheckedCreateWithoutHistoricoAcademicoInput>
  }

  export type CursoCreateWithoutHistoricoAcademicoInput = {
    horario: string
    aula: string
    Materia: MateriaCreateNestedOneWithoutCursoInput
    Usuario: UsuarioCreateNestedOneWithoutCursoInput
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutCursoInput
    DetalleFactura?: DetalleFacturaCreateNestedManyWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutHistoricoAcademicoInput = {
    id?: number
    id_materia: number
    id_docente: number
    horario: string
    aula: string
    id_cuatrimestre: number
    DetalleFactura?: DetalleFacturaUncheckedCreateNestedManyWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutHistoricoAcademicoInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutHistoricoAcademicoInput, CursoUncheckedCreateWithoutHistoricoAcademicoInput>
  }

  export type UsuarioUpsertWithoutHistoricoAcademicoInput = {
    update: XOR<UsuarioUpdateWithoutHistoricoAcademicoInput, UsuarioUncheckedUpdateWithoutHistoricoAcademicoInput>
    create: XOR<UsuarioCreateWithoutHistoricoAcademicoInput, UsuarioUncheckedCreateWithoutHistoricoAcademicoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutHistoricoAcademicoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutHistoricoAcademicoInput, UsuarioUncheckedUpdateWithoutHistoricoAcademicoInput>
  }

  export type UsuarioUpdateWithoutHistoricoAcademicoInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    Cargo?: CargoUpdateOneRequiredWithoutUsuarioNestedInput
    Carrera?: CarreraUpdateOneRequiredWithoutUsuarioNestedInput
    Curso?: CursoUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutHistoricoAcademicoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    id_cargo?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    Curso?: CursoUncheckedUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CursoUpsertWithoutHistoricoAcademicoInput = {
    update: XOR<CursoUpdateWithoutHistoricoAcademicoInput, CursoUncheckedUpdateWithoutHistoricoAcademicoInput>
    create: XOR<CursoCreateWithoutHistoricoAcademicoInput, CursoUncheckedCreateWithoutHistoricoAcademicoInput>
    where?: CursoWhereInput
  }

  export type CursoUpdateToOneWithWhereWithoutHistoricoAcademicoInput = {
    where?: CursoWhereInput
    data: XOR<CursoUpdateWithoutHistoricoAcademicoInput, CursoUncheckedUpdateWithoutHistoricoAcademicoInput>
  }

  export type CursoUpdateWithoutHistoricoAcademicoInput = {
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    Materia?: MateriaUpdateOneRequiredWithoutCursoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutCursoNestedInput
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutCursoNestedInput
    DetalleFactura?: DetalleFacturaUpdateManyWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateWithoutHistoricoAcademicoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_materia?: IntFieldUpdateOperationsInput | number
    id_docente?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    DetalleFactura?: DetalleFacturaUncheckedUpdateManyWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type UsuarioCreateWithoutAuditoriaInput = {
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    Cargo: CargoCreateNestedOneWithoutUsuarioInput
    Carrera: CarreraCreateNestedOneWithoutUsuarioInput
    Curso?: CursoCreateNestedManyWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutAuditoriaInput = {
    id?: number
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    id_cargo: number
    id_carrera: number
    Curso?: CursoUncheckedCreateNestedManyWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutUsuarioInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutAuditoriaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutAuditoriaInput, UsuarioUncheckedCreateWithoutAuditoriaInput>
  }

  export type UsuarioUpsertWithoutAuditoriaInput = {
    update: XOR<UsuarioUpdateWithoutAuditoriaInput, UsuarioUncheckedUpdateWithoutAuditoriaInput>
    create: XOR<UsuarioCreateWithoutAuditoriaInput, UsuarioUncheckedCreateWithoutAuditoriaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutAuditoriaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutAuditoriaInput, UsuarioUncheckedUpdateWithoutAuditoriaInput>
  }

  export type UsuarioUpdateWithoutAuditoriaInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    Cargo?: CargoUpdateOneRequiredWithoutUsuarioNestedInput
    Carrera?: CarreraUpdateOneRequiredWithoutUsuarioNestedInput
    Curso?: CursoUpdateManyWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutAuditoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    id_cargo?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    Curso?: CursoUncheckedUpdateManyWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CarreraCreateWithoutEncabezadoFacturaInput = {
    nombre: string
    especialidad: string
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCarreraInput
    PlanEstudios?: PlanEstudiosCreateNestedManyWithoutCarreraInput
    Usuario?: UsuarioCreateNestedManyWithoutCarreraInput
  }

  export type CarreraUncheckedCreateWithoutEncabezadoFacturaInput = {
    id?: number
    nombre: string
    especialidad: string
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCarreraInput
    PlanEstudios?: PlanEstudiosUncheckedCreateNestedManyWithoutCarreraInput
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutCarreraInput
  }

  export type CarreraCreateOrConnectWithoutEncabezadoFacturaInput = {
    where: CarreraWhereUniqueInput
    create: XOR<CarreraCreateWithoutEncabezadoFacturaInput, CarreraUncheckedCreateWithoutEncabezadoFacturaInput>
  }

  export type CuatrimestreCreateWithoutEncabezadoFacturaInput = {
    numero_cuatrimestre: number
    anno: number
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCuatrimestreInput
    Curso?: CursoCreateNestedManyWithoutCuatrimestreInput
  }

  export type CuatrimestreUncheckedCreateWithoutEncabezadoFacturaInput = {
    id?: number
    numero_cuatrimestre: number
    anno: number
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCuatrimestreInput
    Curso?: CursoUncheckedCreateNestedManyWithoutCuatrimestreInput
  }

  export type CuatrimestreCreateOrConnectWithoutEncabezadoFacturaInput = {
    where: CuatrimestreWhereUniqueInput
    create: XOR<CuatrimestreCreateWithoutEncabezadoFacturaInput, CuatrimestreUncheckedCreateWithoutEncabezadoFacturaInput>
  }

  export type UsuarioCreateWithoutEncabezadoFacturaInput = {
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    Cargo: CargoCreateNestedOneWithoutUsuarioInput
    Carrera: CarreraCreateNestedOneWithoutUsuarioInput
    Curso?: CursoCreateNestedManyWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutEncabezadoFacturaInput = {
    id?: number
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    id_cargo: number
    id_carrera: number
    Curso?: CursoUncheckedCreateNestedManyWithoutUsuarioInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutUsuarioInput
    Auditoria?: AuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    Matricula?: MatriculaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutEncabezadoFacturaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEncabezadoFacturaInput, UsuarioUncheckedCreateWithoutEncabezadoFacturaInput>
  }

  export type DetalleFacturaCreateWithoutEncabezadoFacturaInput = {
    precio_unitario: number
    Curso: CursoCreateNestedOneWithoutDetalleFacturaInput
  }

  export type DetalleFacturaUncheckedCreateWithoutEncabezadoFacturaInput = {
    id?: number
    id_curso: number
    precio_unitario: number
  }

  export type DetalleFacturaCreateOrConnectWithoutEncabezadoFacturaInput = {
    where: DetalleFacturaWhereUniqueInput
    create: XOR<DetalleFacturaCreateWithoutEncabezadoFacturaInput, DetalleFacturaUncheckedCreateWithoutEncabezadoFacturaInput>
  }

  export type DetalleFacturaCreateManyEncabezadoFacturaInputEnvelope = {
    data: DetalleFacturaCreateManyEncabezadoFacturaInput | DetalleFacturaCreateManyEncabezadoFacturaInput[]
    skipDuplicates?: boolean
  }

  export type CarreraUpsertWithoutEncabezadoFacturaInput = {
    update: XOR<CarreraUpdateWithoutEncabezadoFacturaInput, CarreraUncheckedUpdateWithoutEncabezadoFacturaInput>
    create: XOR<CarreraCreateWithoutEncabezadoFacturaInput, CarreraUncheckedCreateWithoutEncabezadoFacturaInput>
    where?: CarreraWhereInput
  }

  export type CarreraUpdateToOneWithWhereWithoutEncabezadoFacturaInput = {
    where?: CarreraWhereInput
    data: XOR<CarreraUpdateWithoutEncabezadoFacturaInput, CarreraUncheckedUpdateWithoutEncabezadoFacturaInput>
  }

  export type CarreraUpdateWithoutEncabezadoFacturaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: StringFieldUpdateOperationsInput | string
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCarreraNestedInput
    PlanEstudios?: PlanEstudiosUpdateManyWithoutCarreraNestedInput
    Usuario?: UsuarioUpdateManyWithoutCarreraNestedInput
  }

  export type CarreraUncheckedUpdateWithoutEncabezadoFacturaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especialidad?: StringFieldUpdateOperationsInput | string
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCarreraNestedInput
    PlanEstudios?: PlanEstudiosUncheckedUpdateManyWithoutCarreraNestedInput
    Usuario?: UsuarioUncheckedUpdateManyWithoutCarreraNestedInput
  }

  export type CuatrimestreUpsertWithoutEncabezadoFacturaInput = {
    update: XOR<CuatrimestreUpdateWithoutEncabezadoFacturaInput, CuatrimestreUncheckedUpdateWithoutEncabezadoFacturaInput>
    create: XOR<CuatrimestreCreateWithoutEncabezadoFacturaInput, CuatrimestreUncheckedCreateWithoutEncabezadoFacturaInput>
    where?: CuatrimestreWhereInput
  }

  export type CuatrimestreUpdateToOneWithWhereWithoutEncabezadoFacturaInput = {
    where?: CuatrimestreWhereInput
    data: XOR<CuatrimestreUpdateWithoutEncabezadoFacturaInput, CuatrimestreUncheckedUpdateWithoutEncabezadoFacturaInput>
  }

  export type CuatrimestreUpdateWithoutEncabezadoFacturaInput = {
    numero_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: IntFieldUpdateOperationsInput | number
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCuatrimestreNestedInput
    Curso?: CursoUpdateManyWithoutCuatrimestreNestedInput
  }

  export type CuatrimestreUncheckedUpdateWithoutEncabezadoFacturaInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: IntFieldUpdateOperationsInput | number
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCuatrimestreNestedInput
    Curso?: CursoUncheckedUpdateManyWithoutCuatrimestreNestedInput
  }

  export type UsuarioUpsertWithoutEncabezadoFacturaInput = {
    update: XOR<UsuarioUpdateWithoutEncabezadoFacturaInput, UsuarioUncheckedUpdateWithoutEncabezadoFacturaInput>
    create: XOR<UsuarioCreateWithoutEncabezadoFacturaInput, UsuarioUncheckedCreateWithoutEncabezadoFacturaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEncabezadoFacturaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEncabezadoFacturaInput, UsuarioUncheckedUpdateWithoutEncabezadoFacturaInput>
  }

  export type UsuarioUpdateWithoutEncabezadoFacturaInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    Cargo?: CargoUpdateOneRequiredWithoutUsuarioNestedInput
    Carrera?: CarreraUpdateOneRequiredWithoutUsuarioNestedInput
    Curso?: CursoUpdateManyWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEncabezadoFacturaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    id_cargo?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    Curso?: CursoUncheckedUpdateManyWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type DetalleFacturaUpsertWithWhereUniqueWithoutEncabezadoFacturaInput = {
    where: DetalleFacturaWhereUniqueInput
    update: XOR<DetalleFacturaUpdateWithoutEncabezadoFacturaInput, DetalleFacturaUncheckedUpdateWithoutEncabezadoFacturaInput>
    create: XOR<DetalleFacturaCreateWithoutEncabezadoFacturaInput, DetalleFacturaUncheckedCreateWithoutEncabezadoFacturaInput>
  }

  export type DetalleFacturaUpdateWithWhereUniqueWithoutEncabezadoFacturaInput = {
    where: DetalleFacturaWhereUniqueInput
    data: XOR<DetalleFacturaUpdateWithoutEncabezadoFacturaInput, DetalleFacturaUncheckedUpdateWithoutEncabezadoFacturaInput>
  }

  export type DetalleFacturaUpdateManyWithWhereWithoutEncabezadoFacturaInput = {
    where: DetalleFacturaScalarWhereInput
    data: XOR<DetalleFacturaUpdateManyMutationInput, DetalleFacturaUncheckedUpdateManyWithoutEncabezadoFacturaInput>
  }

  export type CursoCreateWithoutDetalleFacturaInput = {
    horario: string
    aula: string
    Materia: MateriaCreateNestedOneWithoutCursoInput
    Usuario: UsuarioCreateNestedOneWithoutCursoInput
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutCursoInput
    OfertaAcademica?: OfertaAcademicaCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutDetalleFacturaInput = {
    id?: number
    id_materia: number
    id_docente: number
    horario: string
    aula: string
    id_cuatrimestre: number
    OfertaAcademica?: OfertaAcademicaUncheckedCreateNestedManyWithoutCursoInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedCreateNestedManyWithoutCursoInput
    CuMatricula?: MatriculaUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutDetalleFacturaInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutDetalleFacturaInput, CursoUncheckedCreateWithoutDetalleFacturaInput>
  }

  export type EncabezadoFacturaCreateWithoutDetalleFacturaInput = {
    fecha_hora?: Date | string
    Carrera: CarreraCreateNestedOneWithoutEncabezadoFacturaInput
    Cuatrimestre: CuatrimestreCreateNestedOneWithoutEncabezadoFacturaInput
    Usuario: UsuarioCreateNestedOneWithoutEncabezadoFacturaInput
  }

  export type EncabezadoFacturaUncheckedCreateWithoutDetalleFacturaInput = {
    id?: number
    id_cuatrimestre: number
    id_carrera: number
    id_usuario: number
    fecha_hora?: Date | string
  }

  export type EncabezadoFacturaCreateOrConnectWithoutDetalleFacturaInput = {
    where: EncabezadoFacturaWhereUniqueInput
    create: XOR<EncabezadoFacturaCreateWithoutDetalleFacturaInput, EncabezadoFacturaUncheckedCreateWithoutDetalleFacturaInput>
  }

  export type CursoUpsertWithoutDetalleFacturaInput = {
    update: XOR<CursoUpdateWithoutDetalleFacturaInput, CursoUncheckedUpdateWithoutDetalleFacturaInput>
    create: XOR<CursoCreateWithoutDetalleFacturaInput, CursoUncheckedCreateWithoutDetalleFacturaInput>
    where?: CursoWhereInput
  }

  export type CursoUpdateToOneWithWhereWithoutDetalleFacturaInput = {
    where?: CursoWhereInput
    data: XOR<CursoUpdateWithoutDetalleFacturaInput, CursoUncheckedUpdateWithoutDetalleFacturaInput>
  }

  export type CursoUpdateWithoutDetalleFacturaInput = {
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    Materia?: MateriaUpdateOneRequiredWithoutCursoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutCursoNestedInput
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateWithoutDetalleFacturaInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_materia?: IntFieldUpdateOperationsInput | number
    id_docente?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type EncabezadoFacturaUpsertWithoutDetalleFacturaInput = {
    update: XOR<EncabezadoFacturaUpdateWithoutDetalleFacturaInput, EncabezadoFacturaUncheckedUpdateWithoutDetalleFacturaInput>
    create: XOR<EncabezadoFacturaCreateWithoutDetalleFacturaInput, EncabezadoFacturaUncheckedCreateWithoutDetalleFacturaInput>
    where?: EncabezadoFacturaWhereInput
  }

  export type EncabezadoFacturaUpdateToOneWithWhereWithoutDetalleFacturaInput = {
    where?: EncabezadoFacturaWhereInput
    data: XOR<EncabezadoFacturaUpdateWithoutDetalleFacturaInput, EncabezadoFacturaUncheckedUpdateWithoutDetalleFacturaInput>
  }

  export type EncabezadoFacturaUpdateWithoutDetalleFacturaInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    Carrera?: CarreraUpdateOneRequiredWithoutEncabezadoFacturaNestedInput
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutEncabezadoFacturaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutEncabezadoFacturaNestedInput
  }

  export type EncabezadoFacturaUncheckedUpdateWithoutDetalleFacturaInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioCreateManyCargoInput = {
    id?: number
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    id_carrera: number
  }

  export type UsuarioUpdateWithoutCargoInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    Carrera?: CarreraUpdateOneRequiredWithoutUsuarioNestedInput
    Curso?: CursoUpdateManyWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCargoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    id_carrera?: IntFieldUpdateOperationsInput | number
    Curso?: CursoUncheckedUpdateManyWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutCargoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    id_carrera?: IntFieldUpdateOperationsInput | number
  }

  export type OfertaAcademicaCreateManyCarreraInput = {
    id?: number
    id_curso: number
    id_cuatrimestre: number
    anno: string
  }

  export type PlanEstudiosCreateManyCarreraInput = {
    id?: number
    nombre: string
    anno: number
  }

  export type UsuarioCreateManyCarreraInput = {
    id?: number
    cedula: string
    nombre: string
    apellidos: string
    fecha_nacimiento: string
    correo: string
    contrasena: string
    id_cargo: number
  }

  export type EncabezadoFacturaCreateManyCarreraInput = {
    id?: number
    id_cuatrimestre: number
    id_usuario: number
    fecha_hora?: Date | string
  }

  export type OfertaAcademicaUpdateWithoutCarreraInput = {
    anno?: StringFieldUpdateOperationsInput | string
    Curso?: CursoUpdateOneRequiredWithoutOfertaAcademicaNestedInput
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutOfertaAcademicaNestedInput
  }

  export type OfertaAcademicaUncheckedUpdateWithoutCarreraInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: StringFieldUpdateOperationsInput | string
  }

  export type OfertaAcademicaUncheckedUpdateManyWithoutCarreraInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: StringFieldUpdateOperationsInput | string
  }

  export type PlanEstudiosUpdateWithoutCarreraInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    anno?: IntFieldUpdateOperationsInput | number
    Materia?: MateriaUpdateManyWithoutPlanEstudiosNestedInput
  }

  export type PlanEstudiosUncheckedUpdateWithoutCarreraInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    anno?: IntFieldUpdateOperationsInput | number
    Materia?: MateriaUncheckedUpdateManyWithoutPlanEstudiosNestedInput
  }

  export type PlanEstudiosUncheckedUpdateManyWithoutCarreraInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    anno?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioUpdateWithoutCarreraInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    Cargo?: CargoUpdateOneRequiredWithoutUsuarioNestedInput
    Curso?: CursoUpdateManyWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCarreraInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    id_cargo?: IntFieldUpdateOperationsInput | number
    Curso?: CursoUncheckedUpdateManyWithoutUsuarioNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutUsuarioNestedInput
    Auditoria?: AuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    EncabezadoFactura?: EncabezadoFacturaUncheckedUpdateManyWithoutUsuarioNestedInput
    Matricula?: MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutCarreraInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    id_cargo?: IntFieldUpdateOperationsInput | number
  }

  export type EncabezadoFacturaUpdateWithoutCarreraInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutEncabezadoFacturaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutEncabezadoFacturaNestedInput
    DetalleFactura?: DetalleFacturaUpdateManyWithoutEncabezadoFacturaNestedInput
  }

  export type EncabezadoFacturaUncheckedUpdateWithoutCarreraInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    DetalleFactura?: DetalleFacturaUncheckedUpdateManyWithoutEncabezadoFacturaNestedInput
  }

  export type EncabezadoFacturaUncheckedUpdateManyWithoutCarreraInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursoCreateManyUsuarioInput = {
    id?: number
    id_materia: number
    horario: string
    aula: string
    id_cuatrimestre: number
  }

  export type HistoricoAcademicoCreateManyUsuarioInput = {
    id?: number
    id_curso: number
    nota: number
  }

  export type AuditoriaCreateManyUsuarioInput = {
    id?: number
    accion: string
    fecha_hora?: Date | string
    descripcion: string
  }

  export type EncabezadoFacturaCreateManyUsuarioInput = {
    id?: number
    id_cuatrimestre: number
    id_carrera: number
    fecha_hora?: Date | string
  }

  export type MatriculaCreateManyUsuarioInput = {
    id?: number
    id_curso: number
    fecha?: Date | string
    estado: string
  }

  export type CursoUpdateWithoutUsuarioInput = {
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    Materia?: MateriaUpdateOneRequiredWithoutCursoNestedInput
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutCursoNestedInput
    DetalleFactura?: DetalleFacturaUpdateManyWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_materia?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    DetalleFactura?: DetalleFacturaUncheckedUpdateManyWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_materia?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
  }

  export type HistoricoAcademicoUpdateWithoutUsuarioInput = {
    nota?: FloatFieldUpdateOperationsInput | number
    Curso?: CursoUpdateOneRequiredWithoutHistoricoAcademicoNestedInput
  }

  export type HistoricoAcademicoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    nota?: FloatFieldUpdateOperationsInput | number
  }

  export type HistoricoAcademicoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    nota?: FloatFieldUpdateOperationsInput | number
  }

  export type AuditoriaUpdateWithoutUsuarioInput = {
    accion?: StringFieldUpdateOperationsInput | string
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type AuditoriaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    accion?: StringFieldUpdateOperationsInput | string
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type AuditoriaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    accion?: StringFieldUpdateOperationsInput | string
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type EncabezadoFacturaUpdateWithoutUsuarioInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    Carrera?: CarreraUpdateOneRequiredWithoutEncabezadoFacturaNestedInput
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutEncabezadoFacturaNestedInput
    DetalleFactura?: DetalleFacturaUpdateManyWithoutEncabezadoFacturaNestedInput
  }

  export type EncabezadoFacturaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    DetalleFactura?: DetalleFacturaUncheckedUpdateManyWithoutEncabezadoFacturaNestedInput
  }

  export type EncabezadoFacturaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatriculaUpdateWithoutUsuarioInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    Curso?: CursoUpdateOneRequiredWithoutCuMatriculaNestedInput
  }

  export type MatriculaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type MatriculaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type MateriaCreateManyPlanEstudiosInput = {
    id?: number
    nombre: string
    codigo: string
  }

  export type MateriaUpdateWithoutPlanEstudiosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    Curso?: CursoUpdateManyWithoutMateriaNestedInput
  }

  export type MateriaUncheckedUpdateWithoutPlanEstudiosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    Curso?: CursoUncheckedUpdateManyWithoutMateriaNestedInput
  }

  export type MateriaUncheckedUpdateManyWithoutPlanEstudiosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
  }

  export type OfertaAcademicaCreateManyCuatrimestreInput = {
    id?: number
    id_curso: number
    id_carrera: number
    anno: string
  }

  export type CursoCreateManyCuatrimestreInput = {
    id?: number
    id_materia: number
    id_docente: number
    horario: string
    aula: string
  }

  export type EncabezadoFacturaCreateManyCuatrimestreInput = {
    id?: number
    id_carrera: number
    id_usuario: number
    fecha_hora?: Date | string
  }

  export type OfertaAcademicaUpdateWithoutCuatrimestreInput = {
    anno?: StringFieldUpdateOperationsInput | string
    Curso?: CursoUpdateOneRequiredWithoutOfertaAcademicaNestedInput
    Carrera?: CarreraUpdateOneRequiredWithoutOfertaAcademicaNestedInput
  }

  export type OfertaAcademicaUncheckedUpdateWithoutCuatrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    anno?: StringFieldUpdateOperationsInput | string
  }

  export type OfertaAcademicaUncheckedUpdateManyWithoutCuatrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    anno?: StringFieldUpdateOperationsInput | string
  }

  export type CursoUpdateWithoutCuatrimestreInput = {
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    Materia?: MateriaUpdateOneRequiredWithoutCursoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutCursoNestedInput
    DetalleFactura?: DetalleFacturaUpdateManyWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateWithoutCuatrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_materia?: IntFieldUpdateOperationsInput | number
    id_docente?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    DetalleFactura?: DetalleFacturaUncheckedUpdateManyWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateManyWithoutCuatrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_materia?: IntFieldUpdateOperationsInput | number
    id_docente?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
  }

  export type EncabezadoFacturaUpdateWithoutCuatrimestreInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    Carrera?: CarreraUpdateOneRequiredWithoutEncabezadoFacturaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutEncabezadoFacturaNestedInput
    DetalleFactura?: DetalleFacturaUpdateManyWithoutEncabezadoFacturaNestedInput
  }

  export type EncabezadoFacturaUncheckedUpdateWithoutCuatrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    DetalleFactura?: DetalleFacturaUncheckedUpdateManyWithoutEncabezadoFacturaNestedInput
  }

  export type EncabezadoFacturaUncheckedUpdateManyWithoutCuatrimestreInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursoCreateManyMateriaInput = {
    id?: number
    id_docente: number
    horario: string
    aula: string
    id_cuatrimestre: number
  }

  export type CursoUpdateWithoutMateriaInput = {
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateOneRequiredWithoutCursoNestedInput
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutCursoNestedInput
    DetalleFactura?: DetalleFacturaUpdateManyWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateWithoutMateriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_docente?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    DetalleFactura?: DetalleFacturaUncheckedUpdateManyWithoutCursoNestedInput
    OfertaAcademica?: OfertaAcademicaUncheckedUpdateManyWithoutCursoNestedInput
    HistoricoAcademico?: HistoricoAcademicoUncheckedUpdateManyWithoutCursoNestedInput
    CuMatricula?: MatriculaUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateManyWithoutMateriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_docente?: IntFieldUpdateOperationsInput | number
    horario?: StringFieldUpdateOperationsInput | string
    aula?: StringFieldUpdateOperationsInput | string
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
  }

  export type DetalleFacturaCreateManyCursoInput = {
    id?: number
    id_encabezadofactura: number
    precio_unitario: number
  }

  export type OfertaAcademicaCreateManyCursoInput = {
    id?: number
    id_carrera: number
    id_cuatrimestre: number
    anno: string
  }

  export type HistoricoAcademicoCreateManyCursoInput = {
    id?: number
    id_usuario: number
    nota: number
  }

  export type MatriculaCreateManyCursoInput = {
    id?: number
    id_usuario: number
    fecha?: Date | string
    estado: string
  }

  export type DetalleFacturaUpdateWithoutCursoInput = {
    precio_unitario?: FloatFieldUpdateOperationsInput | number
    EncabezadoFactura?: EncabezadoFacturaUpdateOneRequiredWithoutDetalleFacturaNestedInput
  }

  export type DetalleFacturaUncheckedUpdateWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_encabezadofactura?: IntFieldUpdateOperationsInput | number
    precio_unitario?: FloatFieldUpdateOperationsInput | number
  }

  export type DetalleFacturaUncheckedUpdateManyWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_encabezadofactura?: IntFieldUpdateOperationsInput | number
    precio_unitario?: FloatFieldUpdateOperationsInput | number
  }

  export type OfertaAcademicaUpdateWithoutCursoInput = {
    anno?: StringFieldUpdateOperationsInput | string
    Cuatrimestre?: CuatrimestreUpdateOneRequiredWithoutOfertaAcademicaNestedInput
    Carrera?: CarreraUpdateOneRequiredWithoutOfertaAcademicaNestedInput
  }

  export type OfertaAcademicaUncheckedUpdateWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: StringFieldUpdateOperationsInput | string
  }

  export type OfertaAcademicaUncheckedUpdateManyWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_carrera?: IntFieldUpdateOperationsInput | number
    id_cuatrimestre?: IntFieldUpdateOperationsInput | number
    anno?: StringFieldUpdateOperationsInput | string
  }

  export type HistoricoAcademicoUpdateWithoutCursoInput = {
    nota?: FloatFieldUpdateOperationsInput | number
    Usuario?: UsuarioUpdateOneRequiredWithoutHistoricoAcademicoNestedInput
  }

  export type HistoricoAcademicoUncheckedUpdateWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    nota?: FloatFieldUpdateOperationsInput | number
  }

  export type HistoricoAcademicoUncheckedUpdateManyWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    nota?: FloatFieldUpdateOperationsInput | number
  }

  export type MatriculaUpdateWithoutCursoInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateOneRequiredWithoutMatriculaNestedInput
  }

  export type MatriculaUncheckedUpdateWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type MatriculaUncheckedUpdateManyWithoutCursoInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type DetalleFacturaCreateManyEncabezadoFacturaInput = {
    id?: number
    id_curso: number
    precio_unitario: number
  }

  export type DetalleFacturaUpdateWithoutEncabezadoFacturaInput = {
    precio_unitario?: FloatFieldUpdateOperationsInput | number
    Curso?: CursoUpdateOneRequiredWithoutDetalleFacturaNestedInput
  }

  export type DetalleFacturaUncheckedUpdateWithoutEncabezadoFacturaInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    precio_unitario?: FloatFieldUpdateOperationsInput | number
  }

  export type DetalleFacturaUncheckedUpdateManyWithoutEncabezadoFacturaInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_curso?: IntFieldUpdateOperationsInput | number
    precio_unitario?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}